{"0": {
    "doc": "Add-ons",
    "title": "Add-ons",
    "content": "The Ruby LSP add-on system is currently experimental and subject to changes in the API . Need help writing add-ons? Consider joining the #ruby-lsp-addons channel in the Ruby DX Slack workspace. ",
    "url": "/ruby-lsp/add-ons.html",
    
    "relUrl": "/add-ons.html"
  },"1": {
    "doc": "Add-ons",
    "title": "Motivation and goals",
    "content": "Editor features that are specific to certain tools or frameworks can be incredibly powerful. Typically, language servers are aimed at providing features for a particular programming language (like Ruby!) and not specific tools. This is reasonable since not every programmer uses the same combination of tools. Including tool specific functionality in the Ruby LSP would not scale well given the large number of tools in the ecosystem. It would also create a bottleneck for authors to push new features. Building separate tooling, on the other hand, increases fragmentation which tends to increase the effort required by users to configure their development environments. For these reasons, the Ruby LSP ships with an add-on system that authors can use to enhance the behavior of the base LSP with tool specific functionality, aimed at . | Allowing gem authors to export Ruby LSP add-ons from their own gems | Allowing LSP features to be enhanced by add-ons present in the application the developer is currently working on | Not requiring extra configuration from the user | Seamlessly integrating with the base features of the Ruby LSP | Providing add-on authors with the entire static analysis toolkit that the Ruby LSP uses | . ",
    "url": "/ruby-lsp/add-ons.html#motivation-and-goals",
    
    "relUrl": "/add-ons.html#motivation-and-goals"
  },"2": {
    "doc": "Add-ons",
    "title": "Guidelines",
    "content": "When building a Ruby LSP add-on, refer to these guidelines to ensure a good developer experience. | Performance over features. A single slow request may result in lack of responsiveness in the editor | There are two types of LSP requests: automatic (e.g.: semantic highlighting) and user initiated (go to definition). The performance of automatic requests is critical for responsiveness as they are executed every time the user types | Avoid duplicate work where possible. If something can be computed once and memoized, like configurations, do it | Do not mutate LSP state directly. Add-ons sometimes have access to important state such as document objects, which should never be mutated directly, but instead through the mechanisms provided by the LSP specification - like text edits | Do not over-notify users. It’s generally annoying and diverts attention from the current task | Show the right context at the right time. When adding visual features, think about when the information is relevant for users to avoid polluting the editor | . ",
    "url": "/ruby-lsp/add-ons.html#guidelines",
    
    "relUrl": "/add-ons.html#guidelines"
  },"3": {
    "doc": "Add-ons",
    "title": "Building a Ruby LSP add-on",
    "content": "Note: the Ruby LSP uses Sorbet. We recommend using Sorbet in add-ons as well, which allows authors to benefit from types declared by the Ruby LSP. As an example, check out Ruby LSP Rails, which is a Ruby LSP add-on to provide Rails related features. Activating the add-on . The Ruby LSP discovers add-ons based on the existence of an addon.rb file placed inside a ruby_lsp folder. For example, my_gem/lib/ruby_lsp/my_gem/addon.rb. This file must declare the add-on class, which can be used to perform any necessary activation when the server starts. Projects can also define their own private add-ons for functionality that only applies to a particular application. As long as a file matching ruby_lsp/**/addon.rb exists inside of the workspace (not necessarily at the root), it will be loaded by the Ruby LSP. # frozen_string_literal: true require \"ruby_lsp/addon\" module RubyLsp module MyGem class Addon &lt; ::RubyLsp::Addon # Performs any activation that needs to happen once when the language server is booted def activate(global_state, message_queue) end # Performs any cleanup when shutting down the server, like terminating a subprocess def deactivate end # Returns the name of the add-on def name \"Ruby LSP My Gem\" end # Defining a version for the add-on is mandatory. This version doesn't necessarily need to match the version of # the gem it belongs to def version \"0.1.0\" end end end end . Listeners . An essential component to add-ons are listeners. All Ruby LSP requests are listeners that handle specific node types. Listeners work in conjunction with a Prism::Dispatcher, which is responsible for dispatching events during the parsing of Ruby code. Each event corresponds to a specific node in the Abstract Syntax Tree (AST) of the code being parsed. Here’s a simple example of a listener: . # frozen_string_literal: true class MyListener def initialize(dispatcher) # Register to listen to `on_class_node_enter` events dispatcher.register(self, :on_class_node_enter) end # Define the handler method for the `on_class_node_enter` event def on_class_node_enter(node) $stderr.puts \"Hello, #{node.constant_path.slice}!\" end end dispatcher = Prism::Dispatcher.new MyListener.new(dispatcher) parse_result = Prism.parse(\"class Foo; end\") dispatcher.dispatch(parse_result.value) # Prints # =&gt; Hello, Foo! . In this example, the listener is registered to the dispatcher to listen for the :on_class_node_enter event. When a class node is encountered during the parsing of the code, a greeting message is outputted with the class name. This approach enables all add-on responses to be captured in a single round of AST visits, greatly improving performance. Enhancing features . There are two ways to enhance Ruby LSP features. One is handling DSLs that occur at a call site and that do not change which declarations exist in the project. A great example of this is the Rails validate method, which accepts a symbol that represents a method that gets dynamically invoked. That style of DSL is what we refer to as a call site DSL. class User &lt; ApplicationRecord # From Ruby's perspective, `:something` is just a regular symbol. It's Rails that defines this as a DSL and specifies # that the argument represents a method name. # # If an add-on wanted to handle go to definition or completion for these symbols, then it would need to enhance the # handling for call site DSLs validate :something private def something end end . The second way to augment the Ruby LSP is to handle declaration DSLs. These are DSLs that create declarations via meta-programming. To use another Rails example, belongs_to is a DSL that mutates the current class and adds extra methods based on the arguments passed to it. DSLs that add extra declarations should be handled through an indexing enhancement. class User &lt; ApplicationRecord # When this method is invoked, a bunch of new methods will be defined in the `User` class, such as `company` and # `company=`. By informing the Ruby LSP about the new methods through an indexing enhancement, features such as # go to definition, completion, hover, signature help and workspace symbol will automatically pick up the new # declaration belongs_to :company end . Dealing with call site DSLs . To enhance a request, the add-on must create a listener that will collect extra results that will be automatically appended to the base language server response. Additionally, Addon has to implement a factory method that instantiates the listener. When instantiating the listener, also note that a ResponseBuilders object is passed in. This object should be used to return responses back to the Ruby LSP. For example: to add a message on hover saying “Hello!” on top of the base hover behavior of the Ruby LSP, we can use the following listener implementation. # frozen_string_literal: true module RubyLsp module MyGem class Addon &lt; ::RubyLsp::Addon def activate(global_state, message_queue) @message_queue = message_queue @config = SomeConfiguration.new end def deactivate end def name \"Ruby LSP My Gem\" end def version \"0.1.0\" end def create_hover_listener(response_builder, node_context, dispatcher) # Use the listener factory methods to instantiate listeners with parameters sent by the LSP combined with any # pre-computed information in the add-on. These factory methods are invoked on every request Hover.new(response_builder, @config, dispatcher) end end class Hover # The Requests::Support::Common module provides some helper methods you may find helpful. include Requests::Support::Common # Listeners are initialized with the Prism::Dispatcher. This object is used by the Ruby LSP to emit the events # when it finds nodes during AST analysis. Listeners must register which nodes they want to handle with the # dispatcher (see below). # Listeners are initialized with a `ResponseBuilders` object. The listener will push the associated content # to this object, which will then build the Ruby LSP's response. # Additionally, listeners are instantiated with a message_queue to push notifications (not used in this example). # See \"Sending notifications to the client\" for more information. def initialize(response_builder, config, dispatcher) @response_builder = response_builder @config = config # Register that this listener will handle `on_constant_read_node_enter` events (i.e.: whenever a constant read # is found in the code) dispatcher.register(self, :on_constant_read_node_enter) end # Listeners must define methods for each event they registered with the dispatcher. In this case, we have to # define `on_constant_read_node_enter` to specify what this listener should do every time we find a constant def on_constant_read_node_enter(node) # Certain builders are made available to listeners to build LSP responses. The classes under # `RubyLsp::ResponseBuilders` are used to build responses conforming to the LSP Specification. # ResponseBuilders::Hover itself also requires a content category to be specified (title, links, # or documentation). @response_builder.push(\"Hello!\", category: :documentation) end end end end . Dealing with declaration DSLs . Add-ons can inform the Ruby LSP about declarations that are made via meta-programming. By ensuring that the index is populated with all declarations, features like go to definition, hover, completion, signature help and workspace symbol will all automatically work. To achieve this the add-on must create an indexing enhancement class and register it. Here’s an example of how to do it. Consider that a gem defines this DSL: . class MyThing &lt; MyLibrary::ParentClass # After invoking this method from the `MyLibrary::ParentClass`, a method called `new_method` will be created, # accepting a single required parameter named `a` my_dsl_that_creates_methods # Produces this with meta-programming # def my_method(a); end end . This is how you could write an enhancement to teach the Ruby LSP to understand that DSL: . class MyIndexingEnhancement &lt; RubyIndexer::Enhancement # This on call node handler is invoked any time during indexing when we find a method call. It can be used to insert # more entries into the index depending on the conditions def on_call_node_enter(node) return unless @listener.current_owner # Return early unless the method call is the one we want to handle return unless node.name == :my_dsl_that_creates_methods # Create a new entry to be inserted in the index. This entry will represent the declaration that is created via # meta-programming. All entries are defined in the `entry.rb` file. # # In this example, we will add a new method to the index location = node.location # Create the array of signatures that this method will accept. Every signatures is composed of a list of # parameters. The parameter classes represent each type of parameter signatures = [ RubyIndexer::Entry::Signature.new([RubyIndexer::Entry::RequiredParameter.new(name: :a)]) ] @listener.add_method( \"new_method\", # Name of the method location, # Prism location for the node defining this method signatures # Signatures available to invoke this method ) end # This method is invoked when the parser has finished processing the method call node. # It can be used to perform cleanups like popping a stack...etc. def on_call_node_leave(node); end end . With this the Ruby LSP should automatically handle calls to my_dsl_that_creates_methods and create an accurate representation of the declarations that will be available in the runtime. Registering formatters . Gems may also provide a formatter to be used by the Ruby LSP. To do that, the add-on must create a formatter runner and register it. The formatter is used if the rubyLsp.formatter option configured by the user matches the identifier registered. class MyFormatterRubyLspAddon &lt; RubyLsp::Addon def name \"My Formatter\" end def activate(global_state, message_queue) # The first argument is an identifier users can pick to select this formatter. To use this formatter, users must # have rubyLsp.formatter configured to \"my_formatter\" # The second argument is a class instance that implements the `FormatterRunner` interface (see below) global_state.register_formatter(\"my_formatter\", MyFormatterRunner.new) end end # Custom formatter class MyFormatter # If using Sorbet to develop the add-on, then include this interface to make sure the class is properly implemented include RubyLsp::Requests::Support::Formatter # Use the initialize method to perform any sort of ahead of time work. For example, reading configurations for your # formatter since they are unlikely to change between requests def initialize @config = read_config_file! end # IMPORTANT: None of the following methods should mutate the document in any way or that will lead to a corrupt state! # Provide formatting for a given document. This method should return the formatted string for the entire document def run_formatting(uri, document) source = document.source formatted_source = format_the_source_using_my_formatter(source) formatted_source end # Provide diagnostics for the given document. This method must return an array of `RubyLsp::Interface::Diagnostic` # objects def run_diagnostic(uri, document) end end . Sending notifications to the client . Sometimes, add-ons may need to send asynchronous information to the client. For example, a slow request might want to indicate progress or diagnostics may be computed in the background without blocking the language server. For this purpose, all add-ons receive the message queue when activated, which is a thread queue that can receive notifications for the client. The add-on should keep a reference to this message queue and pass it to listeners that are interested in using it. Note: do not close the message queue anywhere. The Ruby LSP will handle closing the message queue when appropriate. module RubyLsp module MyGem class Addon &lt; ::RubyLsp::Addon def activate(global_state, message_queue) @message_queue = message_queue end def deactivate; end def name \"Ruby LSP My Gem\" end def version \"0.1.0\" end def create_hover_listener(response_builder, node_context, index, dispatcher) MyHoverListener.new(@message_queue, response_builder, node_context, index, dispatcher) end end class MyHoverListener def initialize(message_queue, response_builder, node_context, index, dispatcher) @message_queue = message_queue @message_queue &lt;&lt; Notification.new( message: \"$/progress\", params: Interface::ProgressParams.new( token: \"progress-token-id\", value: Interface::WorkDoneProgressBegin.new(kind: \"begin\", title: \"Starting slow work!\"), ), ) end end end end . Registering for file update events . By default, the Ruby LSP listens for changes to files ending in .rb to continuously update its index when Ruby source code is modified. If your add-on uses a tool that is configured through a file (like RuboCop and its .rubocop.yml) you can register for changes to these files and react when the configuration changes. Note: you will receive events from ruby-lsp and other add-ons as well, in addition to your own registered ones. module RubyLsp module MyGem class Addon &lt; ::RubyLsp::Addon def activate(global_state, message_queue) register_additional_file_watchers(global_state, message_queue) end def deactivate; end def version \"0.1.0\" end def name \"My Addon\" end def register_additional_file_watchers(global_state, message_queue) # Clients are not required to implement this capability return unless global_state.supports_watching_files message_queue &lt;&lt; Request.register_watched_files( \"ruby-lsp-my-gem-file-watcher\", \"**/.my-config.yml\", registration_id: \"my-config-watcher\", ) end def workspace_did_change_watched_files(changes) if changes.any? { |change| change[:uri].end_with?(\".my-config.yml\") } # Do something to reload the config here end end end end end . Dependency constraints . While we figure out a good design for the add-ons API, breaking changes are bound to happen. To avoid having your add-on accidentally break editor functionality, you should define the version that your add-on depends on. There are two ways of achieving this. Add-ons that have a runtime dependency on the ruby-lsp . For add-ons that have a runtime dependency on the ruby-lsp gem, you can simply use regular gemspec constraints to define which version is supported. spec.add_dependency(\"ruby-lsp\", \"~&gt; 0.6.0\") . Add-ons that do not have a runtime dependency on the ruby-lsp . For add-ons that are defined inside other gems that do not wish to have a runtime dependency on ruby-lsp, please use the following API to ensure compatibility. If the Ruby LSP is automatically upgraded to a version not supported by an add-on using this approach, the add-on will simply not be activated with a warning and the functionality will not be available. The author must update to ensure compatibility with the current state of the API. # Declare that this add-on supports the base Ruby LSP version v0.18.0, but not v0.19 or above # # If the Ruby LSP is upgraded to v0.19.0, this add-on will fail gracefully to activate and a warning will be printed RubyLsp::Addon.depend_on_ruby_lsp!(\"~&gt; 0.18.0\") module RubyLsp module MyGem class Addon &lt; ::RubyLsp::Addon def activate(global_state, message_queue) end def deactivate; end def version \"0.1.0\" end def name \"My Addon\" end end end end . Testing add-ons . When writing unit tests for add-ons, it’s essential to keep in mind that code is rarely in its final state while the developer is coding. Therefore, be sure to test valid scenarios where the code is still incomplete. For example, if you are writing a feature related to require, do not test require \"library\" exclusively. Consider intermediate states the user might end up while typing. Additionally, consider syntax that is uncommon, yet still valid Ruby. # Still no argument require # With quotes autocompleted, but no content on the string require \"\" # Using uncommon, but valid syntax, such as invoking require directly on Kernel using parenthesis Kernel.require(\"library\") . The Ruby LSP exports a test helper which creates a server instance with a document already initialized with the desired content. This is useful to test the integration of your add-on with the language server. Add-ons are automatically loaded, so simply executing the desired language server request should already include your add-on’s contributions. require \"test_helper\" require \"ruby_lsp/test_helper\" class MyAddonTest &lt; Minitest::Test def test_my_addon_works source = &lt;&lt;~RUBY # Some test code that allows you to trigger your add-on's contribution class Foo def something end end RUBY with_server(source) do |server, uri| # Tell the server to execute the definition request server.process_message( id: 1, method: \"textDocument/definition\", params: { textDocument: { uri: uri.to_s, }, position: { line: 3, character: 5 } } ) # Pop the server's response to the definition request result = server.pop_response.response # Assert that the response includes your add-on's contribution assert_equal(123, result.response.location) end end end . ",
    "url": "/ruby-lsp/add-ons.html#building-a-ruby-lsp-add-on",
    
    "relUrl": "/add-ons.html#building-a-ruby-lsp-add-on"
  },"4": {
    "doc": "Composed Ruby LSP bundle",
    "title": "Composed Ruby LSP bundle",
    "content": "In language ecosystems other than Ruby, it is not super common to have to add editor tooling as part of your project dependencies. Usually, a language server is an executable that gets downloaded and then run independently from your projects. In the Ruby ecosystem, there are a few blockers to fully adopting this approach: . | Not writing the language server in Ruby would make it challenging to integrate seamlessly with existing tools used by the community that are already written in Ruby, like test frameworks, linters, formatters and so on | Discovering project dependencies automatically allows the language server to detect which files on disk must be read and indexed, so that we can extract declarations from gems without requiring any configuration from the user. This means that we need to integrate directly with Bundler | Bundler only allows requiring gems that are set up as part of the $LOAD_PATH. If the Ruby LSP executable was running independently from a global installation, then the Ruby process would only be able to require the Ruby LSP’s own dependencies, but it would not be able to require any gems used by the project being worked on. Not being able to require the project’s dependencies limits integrations that the language server can automatically make with linters, formatters, test frameworks and so on | . To overcome these limitations, while at the same time not requiring users to add ruby-lsp as a dependency of their projects, the Ruby LSP uses a composed bundle strategy. The flow of execution is as follows: . | The executable is run as ruby-lsp without bundle exec to indicate that the composed bundle must first be configured | The executable sets up a composed bundle under your_project/.ruby-lsp. The generated Gemfile includes the ruby-lsp gem and everything in the project’s Gemfile as well. It may also include debug and ruby-lsp-rails | After the composed bundle is fully set up, then the original ruby-lsp Ruby process is fully replaced by BUNDLE_GEMFILE=.ruby-lsp/Gemfile bundle exec ruby-lsp, thus launching the real language server with access to the project’s dependencies, but without requiring adding the gem to the project’s own Gemfile | . In addition to performing this setup, the composed bundle logic will also bundle install and attempt to auto-update the ruby-lsp language server gem to ensure fast distribution of bug fixes and new features. Setting up the composed bundle requires several integrations with Bundler and there are many edge cases to consider, like how to handle configurations or installing private dependencies. If you encounter a problem with the composed bundle setup, please let us know by reporting an issue. ",
    "url": "/ruby-lsp/composed-bundle.html",
    
    "relUrl": "/composed-bundle.html"
  },"5": {
    "doc": "Contributing",
    "title": "Contributing",
    "content": "If you plan to invest significant effort into a large pull request with multiple decisions that may impact the long term maintenance of the Ruby LSP, please open a discussion first to align on the direction. The ruby-lsp repository contains three sub-projects: . | the language server (ruby-lsp), which exists at the top level of the repository. Most features are implemented here since everything implemented in the server is available to all editors | the VS Code extension, which exists under the vscode directory. Any custom VS Code features are implemented here | the documentation website, which exists under the jekyll directory. All user facing documentation for both the Ruby LSP and the Rails add-on is contained here | . This contributing guide is split by each component. ",
    "url": "/ruby-lsp/contributing.html",
    
    "relUrl": "/contributing.html"
  },"6": {
    "doc": "Contributing",
    "title": "Initial setup",
    "content": "To start contributing to the Ruby LSP, ensure that all dependencies are installed as follows: . | bundle install on the top level will install Ruby dependencies | bundle install in the jekyll directory will install documentation dependencies | yarn install in the vscode directory will install Node.js dependencies for the VS Code extension | . ",
    "url": "/ruby-lsp/contributing.html#initial-setup",
    
    "relUrl": "/contributing.html#initial-setup"
  },"7": {
    "doc": "Contributing",
    "title": "Contributing to the server",
    "content": "This is the structure of the ruby-lsp gem: . | lib/ruby_indexer: the code indexer to extract declarations from the workspace | lib/ruby_lsp/*.rb: foundational pieces of the language server, such as workers, queues, handling requests and so on | lib/ruby_lsp/requests: request implementation. These match one to one with the language server specification | lib/ruby_lsp/listeners: Prism dispatcher listeners. Most of the server’s infrastructure relies on a listener pattern to maximize performance while traversing ASTs. Note that a single request may depend on more than one listener | . When adding or changing an existing feature, first identify which request is responsible for it in the specification. Then identify which file in the server implements that request and start thinking about the implementation. When using VS Code, open the ruby-lsp.code-workspace file instead of just opening the regular folder. It contains configurations for working with the sub projects side by side effectively. Debugging . Live debugging the server . It is possible to live debug the development instance of the language server that is currently running when using VS Code: . | CMD/CTRL + SHIFT + P to open the command palette | Search for Debug the Ruby LSP server. This command will restart the server in debug mode, allowing you to connect with a debugger. Note that the debug mode applies only until the editor is closed or Ruby LSP restarts | After the server has launched in debug mode, attach the debugger by going in Run and debug, selecting the Attach to existing server task and clicking run | You should now be able to put breakpoints in the UI and triggering requests will stop at those breakpoints | . Caveat: since you are debugging the language server instance that is currently running in your own editor, features will not be available if the execution is currently suspended at a breakpoint. Understanding Prism ASTs . The Ruby LSP uses Prism to parse and understand Ruby code. When working on a feature, it’s very common to need to inspect the structure of the Prism AST for a given code snippet, so that you can understand why a request is being triggered a certain way. If you’re using VS Code, you can use the show syntax tree command to inspect the structure of an AST for an entire document or selection. For other editors, using our IRB configurations is the easiest way of achieving the same: . | bundle exec irb to launch IRB with our configurations. It will require all libraries for you | Then parse the Ruby code you’d like to understand better and start inspecting | . source = &lt;&lt;~RUBY class Foo def bar end end RUBY ast = Prism.parse(source).value . Check the Prism documentation for more related information. Tracing LSP requests and responses . In VS Code, you can verify what’s happening in the server by enabling tracing, which allows for different levels of logging. { // Your JSON settings // // - `off`: no tracing // - `messages`: display requests and responses notifications // - `verbose`: display each request and response as JSON \"ruby lsp.trace.server\": \"messages\" } . Manually testing a change . After you made a change or added a new feature, you can verify it in the editor by restarting the language server. In VS Code, this can be achieved by running the command Ruby LSP: restart, which will reboot the server and pick up your changes. For other editors, you must manually restart the language server to pick up the latest changes. Debugging tests . In VS Code, we recommend: . | Setting breakpoints in the UI | Opening the test that will hit that breakpoint | Clicking the debug code lens button on top of examples | . Alternatively (and for other editors), adding a binding.b statement in the code and executing the test in the terminal will also allow you to debug the code. Writing tests . There are two types of tests in the Ruby LSP. The first type is likely familiar: standard Minitest files with a bunch of examples inside using the method declaration syntax. The second type of test is our fixture/expectation framework. Adding a new fixture under test/fixtures will automatically make the framework run all requests against that fixture. By default, the framework only checks that the features don’t crash when running against the fixture. This is useful for ensuring that critical requests don’t break when using less common Ruby syntax. To go beyond checking if the requests break for a fixture, you can add an expectation to test/expectations/NAME_OF_THE_REQUEST, which allows you to assert the expected response for a request and fixture combination. For example, if we have a test/fixtures/foo.rb, then adding a test/expectations/semantic_highlighting/foo.exp.json will make the framework verify that when running semantic highlighting in the foo.rb fixture, the foo.exp.json response is expected. Check existing fixture and expectation combinations for examples. When to use each type of test . The fixture/expectation framework is intended to be used mostly by full document requests (language server features that are computed for the entire file every time). Requests and features that are position specific or that operate under a different mechanism should just use regular Minitest tests. Running the test suite . There are multiple ways to execute tests available. # Run the entire test suite bundle exec rake # Run only indexing tests bundle exec rake test:indexer # Run only language server tests (excluding indexing) bundle exec rake test # Using the custom test framework to run a specific fixture example # bin/test test/requests/the_request_you_want_to_run_test.rb name_of_fixture bin/test test/requests/diagnostics_expectations_test.rb def_bad_formatting . Additionally, we use RuboCop for linting and Sorbet for type checking. # Run linting bundle exec rubocop # Run type checking bundle exec srb tc . ",
    "url": "/ruby-lsp/contributing.html#contributing-to-the-server",
    
    "relUrl": "/contributing.html#contributing-to-the-server"
  },"8": {
    "doc": "Contributing",
    "title": "Contributing to the VS Code extension",
    "content": "Before starting on this section, ensure that dependencies are installed. In addition to what’s described here, the VS Code extension API documentation is a great place to gather more context about how extensions interact with the editor. The VS Code extension currently has the following main parts: . | Version manager integrations for Ruby environment activation | A ruby/debug client implementation | A test controller implementation | A Copilot chat participant | A dependencies tree implementation | The LSP client | A workspace abstraction to represent each active workspace in the editor | . Testing changes . Open the ruby-lsp.code-workspace file instead of just opening the regular folder. It contains contains the configuration needed for using ‘Run and debug’ as described below. We try to ensure thorough testing as much as possible. However, some tests are difficult to write, in particular those that interact with VS Code widgets. For example, if running the test displays a dialog, the test has no easy way of clicking a button on it to continue execution. For these situations we use sinon to stub expected invocations and responses. Note: client.test.ts is an integration style test that boots the development version of the ruby-lsp gem and runs requests against it. Running tests . The easiest way to run tests is by selecting the Extension tests task in Run and debug and clicking run. That will run all tests and the results will appear in VS Code’s debug console. Alternatively, you can also run the tests through the terminal, which will download a test VS Code version inside the repository and run tests against it. You can avoid the download by running the tests through the launch task. Note: it is not possible to run a single test file or example. Live debugging . It is possible to live debug the development version of the extension. Detailed information can be found in the VS Code extension documentation, but this section includes a short description. Live debugging involves two VS Code windows. The first one is where you will be modifying the code and the second window will be where the development version of the extension is going to be running. You want to change the code in the first window, reload and verify the changes in the second window. | Start by launching the extension debugging with the Run extension task in the Run and debug panel. This will open the second VS Code window where the development version of the extension is running | Make the desired changes in the first original VS Code window | Click the reload button in the debug toolbar to load your recent changes into the second VS Code window | Perform the actions to verify your changes in the second window | . If you wish to perform step by step debugging, all you have to do is add breakpoints through the UI in the first window where you are modifying the code - not in the second window where the development version of the extension is running. ",
    "url": "/ruby-lsp/contributing.html#contributing-to-the-vs-code-extension",
    
    "relUrl": "/contributing.html#contributing-to-the-vs-code-extension"
  },"9": {
    "doc": "Contributing",
    "title": "Contributing to documentation",
    "content": "The Ruby LSP uses Jekyll to generate the documentation, whose source lives under the /jekyll folder. Before making any changes, ensure you performed initial setup. After that, follow these steps to make and verify your changes: . | Make the desired changes | Launch jekyll in development bundle exec jekyll serve . | Verify your changes locally by visiting http://localhost:4000/ruby-lsp | . ",
    "url": "/ruby-lsp/contributing.html#contributing-to-documentation",
    
    "relUrl": "/contributing.html#contributing-to-documentation"
  },"10": {
    "doc": "Contributing",
    "title": "Contributing to the Ruby LSP Rails add-on",
    "content": "See https://github.com/Shopify/ruby-lsp-rails/blob/main/CONTRIBUTING.md . ",
    "url": "/ruby-lsp/contributing.html#contributing-to-the-ruby-lsp-rails-add-on",
    
    "relUrl": "/contributing.html#contributing-to-the-ruby-lsp-rails-add-on"
  },"11": {
    "doc": "Design and roadmap",
    "title": "Ruby LSP design and roadmap",
    "content": ". | Design principles . | Favoring common development setups | Stability and performance over features | Accuracy, correctness and type checking | Extensibility | Relying on Bundler | . | Long term roadmap | . ",
    "url": "/ruby-lsp/design-and-roadmap.html#ruby-lsp-design-and-roadmap",
    
    "relUrl": "/design-and-roadmap.html#ruby-lsp-design-and-roadmap"
  },"12": {
    "doc": "Design and roadmap",
    "title": "Design principles",
    "content": "These are the mental models used to make decisions in respect to the Ruby LSP. Favoring common development setups . There are infinite ways in which one can configure their development environment. Not only is there a vast combination of tools that one can use (such as shells, plugins, version managers, operating systems and so on), but many tools allow for customization to alter their default behaviors. While there is no “right way” to use Ruby and configure the development environment, we have to draw a line somewhere in terms of what the Ruby LSP can support. Trying to account for every different setup and customization diverts efforts from improving the experience for the larger audience and increases the long term maintenance costs. Example: the Ruby on Rails Community survey reports that only 2% of developers are not using a version manager to install and configure their Ruby versions. While the popularity of each version manager varies, it’s reasonable to consider that using a version manager is the common way of working with Ruby. Based on this, we will always: . | Favor more common development setups and ways of working with Ruby | Favor defaults and conventions over customization | Aim to deliver a zero-configuration experience for common setups | Provide flexibility where possible as long as it does not compromise the default experience | . Stability and performance over features . Adding a more complete set of editor features or improving correctness is always desired. However, we will always prioritize the stability and the performance of Ruby LSP over adding new features. Even if a feature is useful or if a modification improves the correctness of existing functionality, if it degrades performance and negatively impacts the responsiveness of the editor it may actually result in a worse developer experience. Example: the Ruby syntax for constant references is ambiguous. It’s not possible to tell if a reference to Foo is referring to a class, a module or a constant just based on the syntax alone. Therefore, we started the semantic highlighting feature considering all constant references as namespaces, which is the token type available that more closely represents the three possibilities. To improve highlighting correctness, the Ruby LSP must resolve the references to figure out to which declaration they point to, so that we can assign the correct token type (class, namespace or constant). However, semantic highlighting is executed on every keypress and resolving constant references is an expensive operation - which could lead to lag in the editor. We may decide to not correct this behavior intentionally in favor of maintaining responsiveness. Accuracy, correctness and type checking . The Ruby LSP does not ship with a type system. It performs static analysis with some level of type checking, but falls back to built-in heuristics for scenarios where type annotations would be necessary. That means that it will provide accurate results where possible and fallback to simpler behavior in situations where a complete type system would be needed, delegating decisions to the user. Additionally, performance over features also governs accuracy. We may prefer showing a list of options to let the user decide instead of increasing the complexity of an implementation or degrading the overall LSP performance. If you require more accuracy in your editor, consider adopting a type system and type checker, such as Sorbet or Steep. This applies to multiple language server features such as go to definition, hover, completion and automated refactors. Consider the following examples: . Not all of the examples below are supported at the moment and this is not an exhaustive list. Please check the long term roadmap to see what’s planned . # Cases where we can provide a satisfactory experience without a type system ## Literals \"\".upcase 1.to_s {}.merge!({ a: 1 }) [].push(1) ## Scenarios where can assume the receiver type class Foo def bar; end def baz bar # method invoked directly on self end end ## Singleton methods with an explicit receiver Foo.some_singleton_method ## Constant references Foo::Bar # Cases where a type system would be required and we fallback to heuristics to provide features ## Meta-programming Foo.define_method(\"some#{interpolation}\") do |arg| end ## Methods invoked on the return values of other methods ## Not possible to provide accurate features without knowing the return type ## of invoke_foo var = invoke_foo var.upcase # &lt;- not accurate ## Same thing for chained method calls ## To know where the definition of `baz` is, we need to know the return type ## of `foo` and `bar` foo.bar.baz . Example: when using refactoring features you may be prompted to confirm a code modification as it could be incorrect. Or when trying to go to the definition of a method, you may be prompted with all declarations that match the method call’s name and arguments instead of jumping to the correct one directly. As another fallback mechanism, we want to explore using variable or method call names as a type hint to assist accuracy (not yet implemented). For example . # Typically, a type annotation for `find` would be necessary to discover # that the type of the `user` variable is `User`, allowing the LSP to # find the declaration of `do_something`. # # If we consider the variable name as a snake_case version of its type # we may be able to improve accuracy and deliver a nicer experience even # without the adoption of a type system user = User.find(1) user.do_something . Extensibility . In an effort to reduce tooling fragmentation in the Ruby ecosystem, we are experimenting with an add-on system for the Ruby LSP server. This allows other gems to enhance the Ruby LSP’s functionality without having to write a complete language server of their own, avoiding handling text synchronization, implementing features that depend exclusively on syntax (such as folding range) or caring about the editor’s encoding. We believe that a less fragmented tooling ecosystem leads to a better user experience that requires less configuration and consolidates efforts from the community. Our goal is to allow the Ruby LSP to connect to different formatters, linters, type checkers or even extract runtime information from running applications like Rails servers. You can learn more in the add-ons documentation. Relying on Bundler . Understanding the dependencies of projects where the Ruby LSP is being used on allows it to provide a zero configuration experience to users. It can automatically figure out which gems have to be indexed to provide features like go to definition or completion. That also allows it to connect to the formatter/linter being used, without asking for any configuration. To make that work, the Ruby LSP relies on Bundler, Ruby’s official dependency manager. This decision allows the LSP to easily get information about dependencies, but it also means that it is subject to how Bundler works. Example: gems need to be installed on the Ruby version used by the project for the Ruby LSP to find it (bundle install needs to be satisfied). It needs to be the same Ruby version because otherwise Bundler might resolve to a different set of versions for those dependencies, which could result in failure to install due to version constraints or the LSP indexing the incorrect version of a gem (which could lead to surfacing constants that do not exist in the version used by the project). Example: if we tried to run the Ruby LSP without the context of the project’s bundle, then we would not be able to require gems from it. Bundler only adds dependencies that are part of the current bundle to the load path. Ignoring the project’s bundle would make the LSP unable to require tools like RuboCop and its extensions. Based on this, we will always: . | Rely on Bundler to provide dependency information | Focus our efforts on Bundler integrations and helping improve Bundler itself | Only support other dependency management tools if it does not compromise the default experience through Bundler | . ",
    "url": "/ruby-lsp/design-and-roadmap.html#design-principles",
    
    "relUrl": "/design-and-roadmap.html#design-principles"
  },"13": {
    "doc": "Design and roadmap",
    "title": "Long term roadmap",
    "content": "The goal of this roadmap is to bring visibility into what we have planned for the Ruby LSP. This is not an exhaustive task list, but rather large milestones we wish to achieve. Please note that there are no guarantees about the order in which entries will be implemented or if they will be implemented at all given that we may uncover blockers along the way. Interested in contributing? Check out the issues tagged with help-wanted or good-first-issue. | Make Ruby environment activation more flexible and less coupled with shells | Stabilize APIs for Ruby LSP add-ons to allow other gems to enhance the base features | Full method support for definition, hover and completion | Improve accuracy of method features by handling class/module hierarchies | Improve accuracy of test code lens by checking which class a method inherits from | Explore using variable/method call names as a type hint | Develop strategy to index declarations made in native extensions or C code. For example, Ruby’s own Core classes | Add find references support . | References method support | References instance variable support | References local variable support | . | Add rename support | Add show type hierarchy support | Show index view on the VS Code extension allowing users to browse indexed gems | Add more refactoring code actions such as extract to method, extract to class/module, etc | Explore speeding up indexing by caching the index for gems | Explore speeding up indexing by making Prism AST allocations lazy | Add range formatting support for formatters that do support it | Add ERB support | Explore allowing add-ons to add support for arbitrary file types | Allow the Ruby LSP to connect to a typechecker add-on to improve accuracy | Make the Ruby LSP’s default functionality act as a fallback for the more accurate typechecker results | Introduce a mechanism for add-ons to be automatically detected without needing user configuration | Support intrinsics for new and similar methods | Allow navigation between related code, e.g. from test to implementation | . ",
    "url": "/ruby-lsp/design-and-roadmap.html#long-term-roadmap",
    
    "relUrl": "/design-and-roadmap.html#long-term-roadmap"
  },"14": {
    "doc": "Design and roadmap",
    "title": "Design and roadmap",
    "content": " ",
    "url": "/ruby-lsp/design-and-roadmap.html",
    
    "relUrl": "/design-and-roadmap.html"
  },"15": {
    "doc": "Editors",
    "title": "Editors",
    "content": "This file contains community driven instructions on how to set up the Ruby LSP in editors other than VS Code. For VS Code, use the official Ruby LSP extension. Some Ruby LSP features may be unavailable or limited due to incomplete implementations of the Language Server Protocol, such as dynamic feature registration, or file watching. If you wish to enable or disable features or configure other aspects of the language server, see initialization options. The command to launch the language server might depend on which editor and version manager combination you are using. In order to work properly, the Ruby LSP must be launched with the Ruby version being used by the project you are working on and with the correct Bundler environment set. If you normally launch your editor from the terminal in a shell session where the Ruby environment is already activated, then you can probably just use ruby-lsp as the command. If you’re seeing issues related to not finding the right gems or not being able to locate the ruby-lsp executable, then you may need to ensure that the environment is properly configured by the version manager before you try to run the ruby-lsp executable. How to do this will depend on which version manager you use. Here are some examples: . If your version manager exposes a command to run an executable within the context of the current Ruby, use that: . | mise x -- ruby-lsp | shadowenv exec -- ruby-lsp | . If your version manager creates gem executable shims that perform the automatic version switching, then use those: . | ~/.rbenv/shims/ruby-lsp | ~/.asdf/shims/ruby-lsp | . If your version manager doesn’t provide either of those, then activate the environment and run the executable: . | chruby $(cat .ruby-version) &amp;&amp; ruby-lsp | . These strategies will ensure that the ruby-lsp executable is invoked with the correct Ruby version, GEM_HOME and GEM_PATH, which are necessary for proper integration with your project. ",
    "url": "/ruby-lsp/editors.html",
    
    "relUrl": "/editors.html"
  },"16": {
    "doc": "Editors",
    "title": "All initialization options",
    "content": "Each LSP client can control various abilities of the LSP at startup. The following JSON dictionary contains all of the available initialization options. Generally, editor LSP clients will configure LSP servers using a dictionary in their configuration languages (JSON, Lua, ELisp, etc.). { \"initializationOptions\": { \"enabledFeatures\": { \"codeActions\": true, \"codeLens\": true, \"completion\": true, \"definition\": true, \"diagnostics\": true, \"documentHighlights\": true, \"documentLink\": true, \"documentSymbols\": true, \"foldingRanges\": true, \"formatting\": true, \"hover\": true, \"inlayHint\": true, \"onTypeFormatting\": true, \"selectionRanges\": true, \"semanticHighlighting\": true, \"signatureHelp\": true, \"typeHierarchy\": true, \"workspaceSymbol\": true }, \"featuresConfiguration\": { \"inlayHint\": { \"implicitHashValue\": true, \"implicitRescue\": true } }, \"indexing\": { \"excludedPatterns\": [\"path/to/excluded/file.rb\"], \"includedPatterns\": [\"path/to/included/file.rb\"], \"excludedGems\": [\"gem1\", \"gem2\", \"etc.\"], \"excludedMagicComments\": [\"compiled:true\"] }, \"formatter\": \"auto\", \"linters\": [], \"experimentalFeaturesEnabled\": false } } . | Emacs LSP Mode | Emacs Eglot | Neovim LSP | LazyVim LSP | Sublime Text LSP | Zed | RubyMine | Kate | Helix | . ",
    "url": "/ruby-lsp/editors.html#all-initialization-options",
    
    "relUrl": "/editors.html#all-initialization-options"
  },"17": {
    "doc": "Editors",
    "title": "Emacs Eglot",
    "content": "Eglot runs solargraph server by default. To set it up with ruby-lsp you need to put that in your init file: . (with-eval-after-load 'eglot (add-to-list 'eglot-server-programs '((ruby-mode ruby-ts-mode) \"ruby-lsp\"))) . When you run eglot command it will run ruby-lsp process for you. ",
    "url": "/ruby-lsp/editors.html#emacs-eglot",
    
    "relUrl": "/editors.html#emacs-eglot"
  },"18": {
    "doc": "Editors",
    "title": "Neovim",
    "content": "Note: Ensure that you are using Neovim 0.10 or newer. nvim-lspconfig . The nvim-lspconfig plugin has support for Ruby LSP. The Ruby LSP can be configured using the init_options key when setting up the LSP. A great example of this configuration style is enabling the Standard add-on for the Ruby LSP to enable formatting and pull-style diagnostics. The following snippet enables standard for both formatting and pull-diagnostic linting. local lspconfig = require('lspconfig') lspconfig.ruby_lsp.setup({ init_options = { formatter = 'standard', linters = { 'standard' }, }, }) . To configure an add-on, add the configuration addonSettings within init_options, for example: . init_options = { addonSettings = { [\"Ruby LSP Rails\"] = { enablePendingMigrationsPrompt = false, }, }, }, . Mason . You can use mason.nvim, along with mason-lspconfig.nvim: . local capabilities = vim.lsp.protocol.make_client_capabilities() local mason_lspconfig = require(\"mason-lspconfig\") local servers = { ruby_lsp = {}, } mason_lspconfig.setup { ensure_installed = vim.tbl_keys(servers), } mason_lspconfig.setup_handlers { function(server_name) require(\"lspconfig\")[server_name].setup { capabilities = capabilities, on_attach = on_attach, settings = servers[server_name], filetypes = (servers[server_name] or {}).filetypes, } end } . Using Mason to manage your installation of the Ruby LSP may cause errors . Mason installs the Ruby LSP in a folder shared among all your Rubies. Some of the Ruby LSP dependencies are C extensions, and they rely on the Ruby ABI to look and act a certain way when they were linked to Ruby. This causes issues when a shared folder is used. See this issue for further information. Built-In vim.lsp . Ensure that you are using NeoVim 0.11 or newer. You can also configure the Ruby LSP without the nvim-lspconfig plugin. Create an lsp directory inside your config directory and create a file ruby-lsp.lua inside it with the following content: . -- on Linux and macOS the default location is ~/.config/nvim/lsp/ruby-lsp.lua return { filetypes = { \"ruby\" }, cmd = { \"ruby-lsp\" } -- or { \"bundle\", \"exec\", \"ruby-lsp\" }, root_markers = { \"Gemfile\", \".git\" }, init_options = { formatter = 'standard', linters = { 'standard' }, addonSettings = { [\"Ruby LSP Rails\"] = { enablePendingMigrationsPrompt = false, }, }, }, } . Then you need to enable it, e.g., inside init.lua: . vim.lsp.enable(\"ruby-lsp\") . Additional setup (optional) . rubyLsp/workspace/dependencies is a custom method currently supported only in the VS Code plugin. The following snippet adds ShowRubyDeps command to show dependencies in the quickfix list. local function add_ruby_deps_command(client, bufnr) vim.api.nvim_buf_create_user_command(bufnr, \"ShowRubyDeps\", function(opts) local params = vim.lsp.util.make_text_document_params() local showAll = opts.args == \"all\" client.request(\"rubyLsp/workspace/dependencies\", params, function(error, result) if error then print(\"Error showing deps: \" .. error) return end local qf_list = {} for _, item in ipairs(result) do if showAll or item.dependency then table.insert(qf_list, { text = string.format(\"%s (%s) - %s\", item.name, item.version, item.dependency), filename = item.path }) end end vim.fn.setqflist(qf_list) vim.cmd('copen') end, bufnr) end, {nargs = \"?\", complete = function() return {\"all\"} end}) end require(\"lspconfig\").ruby_lsp.setup({ on_attach = function(client, buffer) add_ruby_deps_command(client, buffer) end, }) . ",
    "url": "/ruby-lsp/editors.html#neovim",
    
    "relUrl": "/editors.html#neovim"
  },"19": {
    "doc": "Editors",
    "title": "LazyVim LSP",
    "content": "As of v12.33.0, Ruby LSP is the default LSP for Ruby. To ensure the correct Ruby version is selected, we recommend disabling the mason option and specifying the appropriate command for your Ruby version manager as an absolute path. For example: . return { { \"neovim/nvim-lspconfig\", opts = { servers = { ruby_lsp = { mason = false, cmd = { vim.fn.expand(\"~/.asdf/shims/ruby-lsp\") }, }, }, }, }, } . ",
    "url": "/ruby-lsp/editors.html#lazyvim-lsp",
    
    "relUrl": "/editors.html#lazyvim-lsp"
  },"20": {
    "doc": "Editors",
    "title": "Sublime Text LSP",
    "content": "To configure the Ruby LSP using LSP for Sublime Text, add the following configuration to your LSP client configuration: . \"clients\": { \"ruby-lsp\": { \"enabled\": true, \"command\": [ \"ruby-lsp\" ], \"selector\": \"source.ruby\", \"initializationOptions\": { \"enabledFeatures\": { \"diagnostics\": false }, \"experimentalFeaturesEnabled\": true } } } . Restart LSP or Sublime Text and ruby-lsp will automatically activate when opening ruby files. ",
    "url": "/ruby-lsp/editors.html#sublime-text-lsp",
    
    "relUrl": "/editors.html#sublime-text-lsp"
  },"21": {
    "doc": "Editors",
    "title": "Zed",
    "content": "Zed has support for the Ruby LSP through the Ruby extension. Documentation can be found in Setting up Ruby LSP. ",
    "url": "/ruby-lsp/editors.html#zed",
    
    "relUrl": "/editors.html#zed"
  },"22": {
    "doc": "Editors",
    "title": "RubyMine",
    "content": "You can use the Ruby LSP with RubyMine (or IntelliJ IDEA Ultimate) through the following plugin. Note that there might be overlapping functionality when using it with RubyMine, given that the IDE provides similar features as the ones coming from the Ruby LSP. Ruby LSP plugin . ",
    "url": "/ruby-lsp/editors.html#rubymine",
    
    "relUrl": "/editors.html#rubymine"
  },"23": {
    "doc": "Editors",
    "title": "Kate",
    "content": "The LSP Client Plugin for Kate is configured by default to use Solargraph for Ruby. To use it with Ruby LSP, you can override particular configuration items in the “User Server Settings” in the LSP Client plugin as shown below: . { \"servers\": { \"ruby\": { \"command\": [\"ruby-lsp\"], \"url\": \"https://github.com/Shopify/ruby-lsp\" } } } . In the Kate settings, under the “LSP-Client” tab, the option “Incrementally synchronize documents with the LSP server” must be enabled. Otherwise, errors like this can occur when editing a Ruby file. Kate will start an instance of the Ruby LSP server in the background for any Ruby project matching the rootIndicationFileNames. If starting Ruby LSP succeeds, the entries in the LSP-Client menu are activated. Otherwise the error output can be inspected in the Output window. ",
    "url": "/ruby-lsp/editors.html#kate",
    
    "relUrl": "/editors.html#kate"
  },"24": {
    "doc": "Editors",
    "title": "Helix",
    "content": "To configure the Ruby LSP in Helix you first need to define it as a language server and then set it as the main language server for Ruby. This will also set ruby-lsp to be used as a formatter with its built-in rubocop integration. # languages.toml [language-server.ruby-lsp] command = \"ruby-lsp\" config = { diagnostics = true, formatting = true } [[language]] name = \"ruby\" language-servers = [\"ruby-lsp\"] auto-format = true . ",
    "url": "/ruby-lsp/editors.html#helix",
    
    "relUrl": "/editors.html#helix"
  },"25": {
    "doc": "Ruby LSP",
    "title": "Ruby LSP",
    "content": ". The Ruby LSP is an implementation of the language server protocol for Ruby, used to improve rich features in editors. It is a part of a wider goal to provide a state-of-the-art experience to Ruby developers using modern standards for cross-editor features, documentation and debugging. Want to discuss Ruby developer experience? Consider joining the public Ruby DX Slack workspace. ",
    "url": "/ruby-lsp/",
    
    "relUrl": "/"
  },"26": {
    "doc": "Ruby LSP",
    "title": "Table of Contents",
    "content": ". | Usage . | With VS Code | With other editors | Composed Ruby LSP bundle | Dependency Compatibility | . | Add-ons | General features . | Hover | Go-to-Definition | Completion | Signature Help | Code Lens for tests | Document symbol | Workspace symbol | Document link | Document highlight | Folding range | Semantic highlighting | Diagnostics | Formatting | Code actions | Inlay hints | On type formatting | Selection range | Show syntax tree | ERB support | Guessed types | Rename symbol | Find references | . | VS Code only features . | Dependencies view | Rails generator integrations | Debug client | Version manager integrations | Test explorer | . | Experimental Features . | Ancestors Hierarchy Request | Copilot chat participant | . | Configuration . | Configuring code indexing | . | Additional Resources | . ",
    "url": "/ruby-lsp/#table-of-contents",
    
    "relUrl": "/#table-of-contents"
  },"27": {
    "doc": "Ruby LSP",
    "title": "Usage",
    "content": "With VS Code . If using VS Code, all you have to do is install the Ruby LSP extension to get the extra features in the editor. Do not install the ruby-lsp gem manually. For more information on using and configuring the extension, see the extension page. With other editors . See editors for community instructions on setting up the Ruby LSP, which currently includes Emacs, Neovim, Sublime Text, and Zed. The gem can be installed by doing . gem install ruby-lsp . and the language server can be launched running ruby-lsp (without bundle exec in order to properly hook into your project’s dependencies). Composed Ruby LSP bundle . The Ruby LSP executable generates a composed bundle with the goal of not requiring users to add the ruby-lsp gem to their Gemfiles, and at the same time being able to hook into project dependencies. Learn more. Dependency Compatibility . The Ruby LSP can provide an enhanced experience if RuboCop is present in the project. While using it is optional, if you do choose to include RuboCop, make sure it’s version 1.4.0 or higher. ",
    "url": "/ruby-lsp/#usage",
    
    "relUrl": "/#usage"
  },"28": {
    "doc": "Ruby LSP",
    "title": "Add-ons",
    "content": "The Ruby LSP provides an add-on system that allows other gems to enhance the base functionality with more editor features. This is the mechanism that powers add-ons like . | Ruby LSP Rails | Ruby LSP RSpec | Ruby LSP rubyfmt | . Additionally, some tools may include a Ruby LSP add-on directly, like . | Standard Ruby (from v1.39.1) | . Other community driven add-ons can be found: . | by searching rubygems for the ruby-lsp prefix | in the community driven list of awesome-ruby-lsp | . For instructions on how to create add-ons, see the add-ons documentation. ",
    "url": "/ruby-lsp/#add-ons",
    
    "relUrl": "/#add-ons"
  },"29": {
    "doc": "Ruby LSP",
    "title": "General features",
    "content": "Note that none of the features in this section are specific to Ruby; they are general to all programming languages. Becoming familiar with them will enhance your ability to use the editor effectively. If you’re using VS Code, we recommend their excellent guides and documentation to learn more about the editor’s philosophy and feature set. Hover . The hover feature displays comments or documentation for the target constant or method when the cursor hovers over them. In VS Code, if you hover while pressing Command, it will also send a definition request to locate the possible target sources. And it will display the target’s source code if only one source is located (e.g., the class is not reopened in multiple places). Sorry, your browser doesn't support embedded videos. This video demonstrates the hover feature, showing how comments and documentation are displayed for the target constant or method. Go-to-Definition . Go-to-definition allows users to navigate to the target constant or method’s definition, whether they’re defined in your project or its dependencies. In VS Code this feature can be triggered by one of the following methods: . | Right click on the target, and then select Go to Definition | Placing the cursor on the target, and then hit F12 | Command + click the target | . With One Definition: . Users are taken directly to the source. Sorry, your browser doesn't support embedded videos. This video shows the go-to-definition feature in action, navigating directly to the source of the target constant or method. With Multiple Definitions: . Users see a dropdown with all the sources, along with a preview window on the side. Sorry, your browser doesn't support embedded videos. This video demonstrates the go-to-definition feature when multiple definitions are found, showing the dropdown and preview window. Completion . The completion feature provides users with completion candidates when the text they type matches certain indexed components. This helps speed up coding by reducing the need to type out full method names or constants. It also allows developers to discover constants or methods that are available to them. Sorry, your browser doesn't support embedded videos. This video illustrates the completion feature, providing completion candidates as the user types. Completion for method calls can only be provided when the type of the receiver is known. For example, when typing foo. it’s only possible to show method completion candidates if know the type of foo. Since the Ruby LSP does not require users to adopt a type system, completion for methods ends up being available only when types can be determined even without annotations (e.g.: methods invoked on literals, constants, direct instantiations of objects using new). If you would like to have more accurate completion, consider adopting a type system. Signature Help . Signature help often appears right after users finish typing a method, providing hints about the method’s parameters. This feature is invaluable for understanding the expected arguments and improving code accuracy. Sorry, your browser doesn't support embedded videos. This video demonstrates the signature help feature, showing hints about the parameters the target method takes. Code Lens . Code lenses are buttons that are added automatically depending on the context of the code. The Ruby LSP supports code lenses for unit tests, allowing you to run tests using VS Code’s test explorer, run the tests in the terminal or launch the debugger. The code lens request requires specific commands to be implemented in the editor in order to work. For VS Code, this is included with the Ruby LSP extension. If you are using a different editor, please check the editor’s documentation on how to define the required commands. Document symbol . Document symbol allows users to fuzzy search declarations inside the current file. It is also used to populate the breadcrumbs and the outline. Workspace symbol . Workspace symbol is the project-wide version of document symbol. It allows users to fuzzy search any declaration in the entire project. Document link . Document link makes magic source links clickable. This is used to connect two declarations for convenience. Note that the links are only processed if they are immediately above a declaration and not anywhere in the code. Document highlight . Document highlight reveals occurrences and declarations of the entity under the cursor. Folding range . Folding range allows users to fold code at relevant ranges of the source. Semantic highlighting . The semantic highlighting removes ambiguity from the language to achieve consistent editor highlighting. For example, with TextMate grammars alone, local variables and method invocations with no receivers or parenthesis can be confused, often resulting in incorrect highlighting. The Ruby LSP’s strategy for semantic highlighting is to return as few tokens as possible to ensure accurate highlighting. Processing a large number of tokens is expensive for editors and may result in lag. Semantic highlighting simply informs the editor of what type of tokens exist in a file. For example, the Ruby LSP tells the editor “this is a local variable” or “this is a method call”. However, this does not mean that themes necessarily make use of that information or that they support semantic highlighting. The Ruby extensions pack extension includes the Spinel theme, which is tailored for use with the Ruby language by fully leveraging all of Ruby LSP’s semantic information. If you wish to add better Ruby support to other themes, see the semantic highlighting for themes docs. Diagnostics . Diagnostics are linting, error, warning and any other type of information that gets surfaced based on the current state of the code. The Ruby LSP has native support for syntax errors and also supports showing linting errors. You can configure which linters to use as long as they have integrations for the Ruby LSP. Check the available configurations. Formatting . Formatting allows documents to be formatted automatically on save or manually if the editor supports it. Code actions . Quick fixes . The Ruby LSP supports fixing violations through quick fixes. Refactors . The Ruby LSP supports some code refactorings, like extract to variable, extract to method and switch block style. Inlay hints . Inlay hints display implicit information explicitly to the user. The goal is to make implicit behavior more discoverable and visible. By default, only implicit rescue hints are displayed. VS Code users can use the following settings to customize inlay hint behavior: . { // Enable all hints \"rubyLsp.featuresConfiguration.inlayHint.enableAll\": true, // Enable implicit rescue (defaults to true) \"rubyLsp.featuresConfiguration.inlayHint.implicitRescue\": true, // Enable implicit hash values (omitted hash values) \"rubyLsp.featuresConfiguration.inlayHint.implicitHashValue\": true } . To configure other editors, see the initialization options. On type formatting . On type formatting applies changes to the code as the user is typing. For example, the Ruby LSP auto completes the end tokens when breaking lines. In VS Code, format on type is disabled by default. You can enable it with \"editor.formatOnType\": true . Range formatting . Range formatting allows users to format a selection in the editor, without formatting the entire file. It is also the feature that enables format on paste to work. In VS Code, format on paste is disabled by default. You can enable it with \"editor.formatOnPaste\": true . Currently, only the Syntax Tree formatter has support for partially formatting a file. Supporting range formatting for RuboCop or Standard requires new APIs to be exposed so that the Ruby LSP can inform the formatter of the base indentation at the place of the selection. Additionally, the formatter can only apply corrections that make sense for the portion of the document. Selection range . Selection range (or smart ranges) expands or shrinks a selection based on the code’s constructs. In VS Code, this can be triggered with CTRL + SHIFT + LEFT/RIGHT ARROW to expand/shrink, respectively. Show syntax tree . Show syntax tree displays the Abstract Syntax Tree (AST) for the current Ruby document. This custom feature can either show the AST for the entire document or for a selection. This feature is not a part of the language server specification. It is a custom feature, which is implemented in the Ruby LSP’s VS Code extension. Other editors can implement a similar approach to achieve the same functionality . ERB support . The Ruby LSP can process ERB files and handle both the embedded Ruby and the host language portions of the file. For the embedded Ruby part, the Ruby LSP responds with all Ruby features you would normally see in regular Ruby files. For features for the host language, like HTML, the Ruby LSP delegates the requests to the language service registered to handle that file type. Request delegation has not yet been formalized as part of the LSP specification. Therefore, this requires custom code on the client (editor) side. The Ruby LSP VS Code extension ships with that custom implementation, but other editors will need to implement the same to support these features . The delegation of certain JavaScript features works partially. For example, completion inside an onclick attribute will sometimes display incorrect candidates. We believe this might be a limitation of request delegation in general and we’ve opened a discussion with VS Code to better understand it. Guessed types . Guessed types is a feature where the Ruby LSP attempts to identify the type of a receiver based on its identifier. For example: . # The receiver identifier here is `user` and so the Ruby LSP will assign to it the `User` type if that class exists user.name # Similarly, the receiver identifier here is `post` and so the LSP searches for the `Post` class @post.like! . The goal of this experiment is to understand if we can get better accuracy for the code that you already have. The hypothesis is that a reasonable amount of code already uses patterns like the ones in the example and, in those cases, we can achieve nicer results. However, identifiers are not the ideal medium for proper type annotations. It would not be possible to express anything complex, such as unions, intersections or generics. Additionally, it is very trivial to fool the type guessing by simply naming a variable with a type name that doesn’t match its actual type. pathname = something_that_returns_an_integer # This will show methods available in `Pathname`, despite the variable being an Integer pathname.a . We do not recommend renaming methods, instance variables or local variables for the sole purpose of getting better accuracy - readability should always come first. For example: . # It would not be a good idea to name every string \"string\" for the sake of getting better accuracy. # Using descriptive names will outweigh the benefits of the more accurate editor experience # don't string = something.other_thing # do title = something.other_thing name = foo . That said, this feature can also be used for quickly exploring methods available in classes. Simply type the lower case name of the class and completion can show the methods available. # Any class name as an identifier pathname.a integer.a file.a . To guess types, the Ruby LSP will first try to resolve a constant based on the receiver identifier and current nesting. If that does not identify any valid types, then it will fallback to matching based on the first match for the unqualified type name. For example: . module Admin class User end # Will match to `Admin::User` because the `user` reference is inside the `Admin` namespace user.a end module Blog class User end # Will match to `Blog::User` because the `user` reference is inside the `Blog` namespace user.a end # Will match to the first class that has the unqualified name of `User`. This may return `Admin::User` or `Blog::User` # randomly user.a . Rename symbol . Rename allows developers to rename all occurrences of the entity under the cursor across the entire project. In VS Code renaming can be triggered by right clicking the entity to rename or by pressing F2 on it. You can also preview the edits that will be applied by pressing CTRL/CMD + Enter after typing the desired new name. Rename is currently only supported for constants, module names and class names. Find references . The find references request allows users to both see a list of references or jump to reference locations. Note that only constants are currently supported, but support for methods, instance variables and local variables is planned. ",
    "url": "/ruby-lsp/#general-features",
    
    "relUrl": "/#general-features"
  },"30": {
    "doc": "Ruby LSP",
    "title": "VS Code features",
    "content": "The following features are all custom made for VS Code. Dependencies view . The Ruby LSP contributes a custom dependencies view panel that allows users to navigate the dependencies of their projects. Rails generator integrations . The Ruby LSP integrates with Rails generators, which can be invoked through the UI. All generated files are automatically opened and formatted using the project’s formatting configurations. Debug client . The Ruby LSP ships with a client for the debug gem. The client allows functionality such as code lens, but also enables launch configurations for starting a process with the visual debugger or attaching to an existing server. Version manager integrations . When working on many projects with different Ruby versions, the Ruby LSP needs to know which Ruby version is being used and where gems are installed in order to support automatic dependency detection and indexing. We support custom built integrations with the following version managers for automatic version switching with no need for any user actions: . | asdf | chruby | mise | rbenv | RubyInstaller | rvm | shadowenv | . Additionally, we provide the following escape hatches if the custom integrations are not enough: . | custom: define a custom shell script to activate the Ruby environment on any project | none: do nothing and rely on the environment inherited by VS Code | . Most version managers have some shell component to them in order to mutate the user’s environment in a terminal and point to the correct Ruby version. For this reason, the VS Code extension must invoke the user’s shell from the NodeJS process where it is running - otherwise the version manager wouldn’t be available for the integration. This can sometimes lead to Ruby environment activation problems. For example, certain shell plugins expect variables set by terminals to be present and fail if they aren’t. The NodeJS process running the extension will not have set these variables and therefore will be likely to fail. Finding a general solution to this problem is not trivial due to the number of different combinations of operating systems, shells, plugins and version managers. On top of those, people configure their shell environments differently. For example, some users may source their version managers in ~/.zshrc while others will do it in ~/.zshenv or ~/.zprofile. If experiencing issues, keep in mind that shell configurations could be interfering, check troubleshooting and, if none of the listed solutions work, please report an issue. ",
    "url": "/ruby-lsp/#vs-code-features",
    
    "relUrl": "/#vs-code-features"
  },"31": {
    "doc": "Ruby LSP",
    "title": "Experimental Features",
    "content": "Ruby LSP also provides experimental features that are not enabled by default. If you have feedback about these features, you can let us know in the DX Slack or by creating an issue. Ancestors Hierarchy Request . The ancestors hierarchy request feature aims to provide a better understanding of the inheritance hierarchy within your Ruby code. This feature helps developers trace the lineage of their classes and modules, making it easier to: . | Visualize the inheritance hierarchy of classes and modules. | Quickly navigate through the inheritance chain. | . Sorry, your browser doesn't support embedded videos. This video demonstrates the ancestors hierarchy request feature, visualizing the inheritance hierarchy. Why Is It Experimental? . This feature is supported by the Type Hierarchy Supertypes LSP request. During implementation, we encountered some ambiguities when applying it to Ruby. For example: . | Should the list include only classes (pure inheritance chain), or should it include modules too (current behavior)? | How should the inheritance chain of singleton classes be triggered and displayed? | If a class or module is reopened multiple times, it will appear multiple times in the list. In real-world applications, this can make the list very long. | . We created an issue to seek clarification from the LSP maintainers. We will adjust this feature’s design and behavior based on their response and your feedback. Copilot chat participant . The Ruby LSP includes a Copilot chat participant that comes with built-in knowledge of Ruby and Rails commands, helping you build these commands efficiently. ",
    "url": "/ruby-lsp/#experimental-features",
    
    "relUrl": "/#experimental-features"
  },"32": {
    "doc": "Ruby LSP",
    "title": "Configuration",
    "content": "Configuring code indexing . By default, the Ruby LSP indexes all Ruby files defined in the current project and all of its dependencies, including default gems, except for . | Gems that only appear under the :development group | All Ruby files under test/**/*.rb | . This behavior can be overridden and tuned. Learn how to configure it for VS Code. Note that indexing-dependent behavior, such as definition, hover, completion or workspace symbol will be impacted by the configuration changes. The older approach of using a .index.yml file has been deprecated and will be removed in a future release. # Exclude files based on a given pattern. Often used to exclude test files or fixtures excluded_patterns: - \"**/spec/**/*.rb\" # Include files based on a given pattern. Can be used to index Ruby files that use different extensions included_patterns: - \"**/bin/*\" # Exclude gems by name. If a gem is never referenced in the project's code and is only used as a tool, excluding it will # speed up indexing and reduce the amount of results in features like definition or completion excluded_gems: - rubocop - pathname # Include gems by name. Normally used to include development gems that are excluded by default included_gems: - prism . ",
    "url": "/ruby-lsp/#configuration",
    
    "relUrl": "/#configuration"
  },"33": {
    "doc": "Ruby LSP",
    "title": "Additional Resources",
    "content": ". | RubyConf 2022: Improving the development experience with language servers (Vinicius Stock) | Remote Ruby: Ruby Language Server with Vinicius Stock | RubyKaigi 2023: Code indexing - How language servers understand our code (Vinicius Stock) | . ",
    "url": "/ruby-lsp/#additional-resources",
    
    "relUrl": "/#additional-resources"
  },"34": {
    "doc": "Rails add-on",
    "title": "Rails add-on",
    "content": "Ruby LSP Rails is a Ruby LSP add-on that enhances the base Ruby LSP functionality with Rails-specific features. It provides improved code navigation, document symbols for Rails-specific elements, and runtime introspection capabilities. It communicates with a running Rails instance to provide dynamic information about the application, enabling more accurate and context-aware language server features. ",
    "url": "/ruby-lsp/rails-add-on.html",
    
    "relUrl": "/rails-add-on.html"
  },"35": {
    "doc": "Rails add-on",
    "title": "Table of Contents",
    "content": ". | Installation | Runtime Introspection | Features . | Document Symbol . | Active Record Callbacks, Validations, and Associations | Active Support Test Cases | . | Go to Controller Action Route | Go to Controller Action View | Go to Definition . | Go to Active Record Callback and Validation Definitions | Go to Active Record Associations | Go to Route Helper Definitions | . | Ruby File Operations . | Commands | . | Run and Debug . | Run Tests With Test Explorer | Run Tests In The Terminal | Debug Tests With VS Code | . | . | . ",
    "url": "/ruby-lsp/rails-add-on.html#table-of-contents",
    
    "relUrl": "/rails-add-on.html#table-of-contents"
  },"36": {
    "doc": "Rails add-on",
    "title": "Installation",
    "content": "The Rails add-on is installed automatically. Ruby LSP detects Rails projects and installs the Rails add-on for you. ",
    "url": "/ruby-lsp/rails-add-on.html#installation",
    
    "relUrl": "/rails-add-on.html#installation"
  },"37": {
    "doc": "Rails add-on",
    "title": "Runtime Introspection",
    "content": "LSP tooling is typically based on static analysis, but ruby-lsp-rails actually communicates with your Rails app for some features. When Ruby LSP Rails starts, it spawns a rails runner instance which runs server.rb. The add-on communicates with this process over a pipe (i.e. stdin and stdout) to fetch runtime information about the application. When extension is stopped (e.g. by quitting the editor), the server instance is shut down. ",
    "url": "/ruby-lsp/rails-add-on.html#runtime-introspection",
    
    "relUrl": "/rails-add-on.html#runtime-introspection"
  },"38": {
    "doc": "Rails add-on",
    "title": "Features",
    "content": "Document Symbol . Document Symbol is a way to represent the structure of a document. They are used to provide a quick overview of the document and to allow for quick navigation. Ruby LSP already provides document symbols for Ruby files, such as classes, modules, methods, etc. But the Rails add-on provides additional document symbols for Rails specific features. In VS Code, you can open the document symbols view by pressing Ctrl + Shift + O. Active Record Callbacks, Validations, and Associations . Navigates between Active Record callbacks, validations, and associations using the Document Symbol feature. Active Support Test Cases . Navigates between Active Support test cases using the Document Symbol feature. Go to Controller Action Route . Navigates to the route definition of a controller action using the Code Lens feature. Go to Controller Action View . Navigates to the view file(s) of a controller action using the Code Lens feature. Go to Definition . Go to definition is a feature that allows you to navigate to the definition of a symbol. In VS Code, you can trigger go to definition in 3 different ways: . | Select Go to Definition from the context menu | F12 on a symbol | Cmd + Click on a symbol | . In the following demos, we will use the Cmd + Click method to trigger go to definition. Go to Active Record Callback and Validation Definitions . Navigates to the definitions of Active Record callbacks and validations. Go to Active Record Associations . Navigates to the definitions of Active Record associations. Go to Route Helper Definitions . Ruby File Operations . The Ruby LSP extension provides a Ruby file operations icon in the Explorer view that can be used to trigger the Rails generate and Rails destroy commands. Commands . These commands are also available in the Command Palette. Rails Generate . Rails Destroy . Run and Debug . The Rails add-on provides 3 ways to run and debug ActiveSupport tests using the Code Lens feature. Run Tests With Test Explorer . Run Tests In The Terminal . Debug Tests With VS Code . ",
    "url": "/ruby-lsp/rails-add-on.html#features",
    
    "relUrl": "/rails-add-on.html#features"
  },"39": {
    "doc": "Rails add-on",
    "title": "Settings",
    "content": "The following setting configures aspects of the Rails add-on. Values shown are the defaults. // Settings for all add-ons \"rubyLsp.addonSettings\": { // Settings for the Rails add-on \"Ruby LSP Rails\": { // Enable prompt for pending migrations \"enablePendingMigrationsPrompt\": true } } . ",
    "url": "/ruby-lsp/rails-add-on.html#settings",
    
    "relUrl": "/rails-add-on.html#settings"
  },"40": {
    "doc": "Semantic Highlighting for Themes",
    "title": "Semantic Highlighting for Themes",
    "content": "Ruby LSP supports semantic highlighting, which informs editors about the right token types for each part of the code to the code to allow for rich and accurate highlighting. If you’re a theme developer or want to enhance the Ruby syntax highlighting in your editor, this guide provides a brief overview of the semantic tokens available and how to use them. The strategy taken by Ruby LSP is to only return tokens for syntax that is ambiguous in Ruby (as opposed to all existing tokens) to optimize for performance. An example of ambiguous syntax in Ruby are local variables and method calls. If you look at this line in isolation: . foo . it is not possible to tell if foo is a local variable or a method call. It depends on whether foo was assigned to something before or not. This is one scenario where semantic highlighting removes the ambiguity for themes, returning the correct token type by statically analyzing the code. To enhance a theme’s Ruby syntax highlighting using the Ruby LSP, check the information below. You may also want to check out the Spinel theme as an example, which uses all of the Ruby LSP’s semantic highlighting information. ",
    "url": "/ruby-lsp/semantic-highlighting.html",
    
    "relUrl": "/semantic-highlighting.html"
  },"41": {
    "doc": "Semantic Highlighting for Themes",
    "title": "Token types",
    "content": "According to the LSP specification, language servers can either use token types and modifiers from the default list or contribute new semantic tokens of their own. Currently, the Ruby LSP does not contribute any new semantic tokens and only uses the ones contained in the default list. ",
    "url": "/ruby-lsp/semantic-highlighting.html#token-types",
    
    "relUrl": "/semantic-highlighting.html#token-types"
  },"42": {
    "doc": "Semantic Highlighting for Themes",
    "title": "Token list",
    "content": "| Syntax | Type.Modifier | Note | . | Sorbet annotation methods such as let or cast | type | Not every annotation is handled | . | Method calls with any syntax | method |   | . | Constant references (including classes and modules) | namespace | We don’t yet differentiate between module and class references | . | Method definition | method.declaration |   | . | self | variable.default_library |   | . | Method, block and lambda arguments | parameter |   | . | Class declaration | class.declaration |   | . | Module declaration | class.declaration |   | . ",
    "url": "/ruby-lsp/semantic-highlighting.html#token-list",
    
    "relUrl": "/semantic-highlighting.html#token-list"
  },"43": {
    "doc": "Supported Versions Policy",
    "title": "Supported Versions Policy",
    "content": "For Ruby, we support the versions listed as being under normal maintenance. For Ruby on Rails, we support the versions listed as supported for bug fixes. This means that new features may not be available to older versions, but we still try to ensure that the Ruby LSP is stable. We will consider contributions to support other versions of these tools, as long as they not detrimental to the project’s overall health. ",
    "url": "/ruby-lsp/supported_versions.html",
    
    "relUrl": "/supported_versions.html"
  },"44": {
    "doc": "Test explorer",
    "title": "Test explorer",
    "content": "The new test explorer implementation is currently being rolled out to users! You can adopt it early by toggling this feature flag in your user or workspace settings . \"rubyLsp.featureFlags\": { \"fullTestDiscovery\": true } . The Ruby LSP implements VS Code’s test explorer, which allows users to execute the tests defined in their codebase in 4 modes directly from inside the editor: . | Run (default mode): runs the selected tests and displays results in the test results panel | Run in terminal: runs the selected tests in a terminal set up by the Ruby LSP | Debug: starts an interactive debugging session for the selected tests | Coverage: runs tests in coverage mode and shows results inside the editor | . ",
    "url": "/ruby-lsp/test_explorer.html",
    
    "relUrl": "/test_explorer.html"
  },"45": {
    "doc": "Test explorer",
    "title": "Design",
    "content": "Our design is based on addressing 2 main goals: . | Supporting Ruby’s diverse test frameworks without the need for extra editor extensions | Ensuring the solution is performant enough for large scale applications | . With these in mind, the Ruby LSP populates the test explorer panel through static analysis. Loading every single test into memory to perform runtime introspection as a discovery mechanism would not satisfy our performance goal. Tests are discovered for the entire codebase automatically when: . | the user clicks one of the test related code lenses | the user expands the explorer | . Support for different frameworks can be provided via our add-on API, both for discovering tests and defining how to execute them. Any framework contribution made via add-ons is automatically integrated with all modes of execution. By default, the Ruby LSP supports Minitest and Test Unit. When working on Rails applications, the Rails add-on is automatically included to support the declarative syntax included by ActiveSupport::TestCase. There is limited support to using multiple test frameworks in the same codebase. This use case is pretty uncommon and we will not make further investments into supporting it, in line with our design principle of favoring common setups . To discover all test files in the workspace with decent performance, the Ruby LSP uses a glob pattern based on conventions. For a test file to be discovered, the file path must match this glob: **/{test,spec,features}/**/{*_test.rb,test_*.rb,*_spec.rb,*.feature} . Dynamically defined tests . There is limited support for tests defined via meta-programming. Initially, they will not be present in the test explorer (as they often cannot be detected through static analysis). However, running a test file that includes dynamically defined tests will automatically populate the explorer with those tests, including the results of the execution. class MyTest &lt; Minitest::Spec # These are detected automatically describe \"something\" do it \"does a useful thing\" do end end # Dynamically defined tests like these are only discovered while running the entire file [:first, :second, :third].each do |name| it \"does the #{name} well\" do end end end . Dynamically defined anonymous tests are not supported properly because there’s no way to accurately reconcile their discovery with execution. class MyTest &lt; Minitest::Spec # Anonymous examples (no description) defined dynamically are not supported 5.times do it do end end end . Tests that accept external parameters . In Ruby, you can write tests that accept external parameters, like environment variables. class MyTest &lt; Minitest::Test # Using instance variable as an external argument if ENV[\"INCLUDE_SLOW_TESTS\"] def test_slow_operation end end # Using command line arguments to gate tests if ARGV.include?(\"--integration-tests\") def test_integration end end def test_other_things end end . Automatically detecting what type of external argument is required for each test is not trivial. Additionally, VS Code’s test explorer doesn’t have support for arguments when running tests out of the box and neither do its test items accept metadata. This scenario will not be supported by the Ruby LSP. ",
    "url": "/ruby-lsp/test_explorer.html#design",
    
    "relUrl": "/test_explorer.html#design"
  },"46": {
    "doc": "Test explorer",
    "title": "Connecting terminal tests to the explorer",
    "content": "When running tests in the terminal through a code lens or test explorer, the Ruby LSP and add-ons will hook up the execution commands with the expected reporters using the -r argument for ruby. You can manually hook up execution by adding the same. bundle exec ruby -r/path/to/ruby-lsp/reporter -Itest test/example_test.rb bundle exec ruby -r/path/to/ruby-lsp/reporter -Ispec spec/example_spec.rb . ",
    "url": "/ruby-lsp/test_explorer.html#connecting-terminal-tests-to-the-explorer",
    
    "relUrl": "/test_explorer.html#connecting-terminal-tests-to-the-explorer"
  },"47": {
    "doc": "Test explorer",
    "title": "Customization",
    "content": "When tests are running through any execution mode, we set the RUBY_LSP_TEST_RUNNER environment variable to allow users to customize behavior of their test suite if needed. Using coverage mode does not require any extra dependencies or configuration for collecting the coverage data. This is done automatically by the Ruby LSP through Ruby’s built-in coverage API. Users can also differentiate between the mode of execution, which is the value of the RUBY_LSP_TEST_RUNNER variable: . # test/test_helper.rb case ENV[\"RUBY_LSP_TEST_RUNNER\"] when \"run\" # Do something when using run or run in terminal modes when \"debug\" # Do something when using debug mode when \"coverage\" # Do something when using coverage mode else # Do something when running outside of the context of the Ruby LSP integration end . ",
    "url": "/ruby-lsp/test_explorer.html#customization",
    
    "relUrl": "/test_explorer.html#customization"
  },"48": {
    "doc": "Test explorer",
    "title": "Other editors",
    "content": "The test explorer functionality is not yet standardized as part of the language server specification, which means that it cannot be used by other editors without custom extension code to integrate all of the pieces together. As most of the implementation is on server side, if any editor supports similar UI elements and editor-side APIs (either directly or through plugins), it can integrate this feature as well. Below are the custom request specifications. Discover tests . This request is sent by the client to discover which test items exist for a given text document URI. Server capability: capabilities.experimental.full_test_discovery . Method: rubyLsp/discoverTests . Params: . interface DiscoverTestParams { textDocument: { uri: string; }; } . Response: . // Matches vscode.TestItem with some minor modifications interface TestItem { id: string; label: string; uri: string; range: { start: { line: number; character: number }, end: { line: number; character: number }}; tags: string[]; children: TestItem[]; } type Response = TestItem[]; . Resolve test commands . This request is sent by the client for the server to determine the minimum number of commands required to execute a given hierarchy of tests. For example, if we execute a test group (class) inside of the bar_test.rb file and 3 examples inside of the foo_test.rb file, the minimum required commands to execute them may look like this: . [ \"bin/rails test test/foo_test.rb:13:25:40\", \"bin/rails test test/bar_test.rb --name \\\"/^BarTest::NestedTest(#|::)/\\\"\" ] . Server capability: capabilities.experimental.full_test_discovery . Method: rubyLsp/resolveTestCommands . Params: . type Params = TestItem[]; . Response: . interface ResolveTestCommandsResult { // The array of commands required to execute the tests commands: string[]; // An optional array of custom LSP test reporters. Used to stream test results to the client side using JSON RPC // messages reporterPaths?: string[]; } . ",
    "url": "/ruby-lsp/test_explorer.html#other-editors",
    
    "relUrl": "/test_explorer.html#other-editors"
  },"49": {
    "doc": "Test framework add-ons",
    "title": "Test framework add-ons",
    "content": "Before diving into building test framework add-ons, read about the test explorer documentation first. The Ruby LSP’s test explorer includes built-in support for Minitest and Test Unit. Add-ons can add support for other test frameworks, like Active Support test case and RSpec. There are 3 main parts for contributing support for a new framework: . | Test discovery: identifying tests within the codebase and their structure | Command resolution: determining how to execute a specific test or group of tests | Custom reporting: displaying test execution results in the test explorer | . ",
    "url": "/ruby-lsp/test_framework_addons.html",
    
    "relUrl": "/test_framework_addons.html"
  },"50": {
    "doc": "Test framework add-ons",
    "title": "Test discovery",
    "content": "Test discovery is the process of populating the explorer view with the tests that exist in the codebase. The Ruby LSP extension is responsible for discovering all test files. The convention to be considered a test file is that it must match this glob pattern: **/{test,spec,features}/**/{*_test.rb,test_*.rb,*_spec.rb,*.feature}. It is possible to configure test frameworks to use different naming patterns, but this convention is established to guarantee that we can discover all test files with adequate performance and without requiring configuration from users. The part that add-ons are responsible for is discovering which tests exist inside of those files, which requires static analysis and rules that are framework dependent. Like most other add-on contribution points, test discovery can be enhanced by attaching a new listener to the process of discovering tests. module RubyLsp module MyTestFrameworkGem class Addon &lt; ::RubyLsp::Addon #: (GlobalState, Thread::Queue) -&gt; void def activate(global_state, message_queue) @global_state = global_state end # Declare the factory method that will hook a new listener into the test discovery process # @override #: (ResponseBuilders::TestCollection, Prism::Dispatcher, URI::Generic) -&gt; void def create_discover_tests_listener(response_builder, dispatcher, uri) # Because the Ruby LSP runs requests concurrently, there are no guarantees that we'll be done executing # activate when a request for test discovery comes in. If this happens, skip until the global state is ready return unless @global_state # Create our new test discovery listener, which will hook into the dispatcher TestDiscoveryListener.new(response_builder, @global_state, dispatcher, uri) end end end end . Next, the listener itself needs to be implemented. If the test framework being handled uses classes to define test groups, like Minitest and Test Unit, the Ruby LSP provides a parent class to make some aspects of the implementation easier and more standardized. Let’s take a look at this case first and then see how frameworks that don’t use classes can be handled (such as RSpec). In this example, test groups are defined with classes that inherit from MyTestFramework::Test and test examples are defined by creating methods prefixed with test_. module RubyLsp module MyTestFrameworkGem class TestDiscoveryListener &lt; Listeners::TestDiscovery #: (ResponseBuilders::TestCollection, GlobalState, Prism::Dispatcher, URI::Generic) -&gt; void def initialize(response_builder, global_state, dispatcher, uri) super(response_builder, global_state, dispatcher, uri) # Register on the dispatcher for the node events we are interested in dispatcher.register(self, :on_class_node_enter, :on_def_node_enter) end #: (Prism::ClassNode node) -&gt; void def on_class_node_enter(node) # Here we use the `with_test_ancestor_tracking` so that we can check if the class we just found inherits # from our framework's parent test class. This check is important because users can define any classes or # modules inside a test file and not all of them are runnable tests with_test_ancestor_tracking(node) do |name, ancestors| if ancestors.include?(\"MyTestFrameworkGem::Test\") # If the test class indeed inherits from our framework, then we can create a new test item representing # this test in the explorer. The expected arguments are: # # - id: a unique ID for this test item. Must match the same IDs reported during test execution # (explained in the next section) # - label: the label that will appear in the explorer # - uri: the URI where this test can be found (e.g.: file:///Users/me/src/my_project/test/my_test.rb). # has to be a URI::Generic object # - range: a RubyLsp::Interface::Range object describing the range inside of `uri` where we can find the # test definition # - framework: a framework ID that will be used for resolving test commands. Each add-on should only # resolve the items marked as their framework test_item = Requests::Support::TestItem.new( name, name, @uri, range_from_node(node), framework: :my_framework ) # Push the test item as an explorer entry @response_builder.add(test_item) # Push the test item for code lenses. This allows users to run tests by clicking the `Run`, # `Run in terminal` and `Debug` buttons directly on top of tests @response_builder.add_code_lens(test_item) end end end #: (Prism::DefNode) -&gt; void def on_def_node_enter(node) # If the method is not public, then it cannot be considered an example. The visibility stack is tracked # automatically by the `RubyLsp::Listeners::TestDiscovery` parent class return if @visibility_stack.last != :public # If the method name doesn't begin with `test_`, then it's not a test example name = node.name.to_s return unless name.start_with?(\"test_\") # The current group of a test example depends on which exact namespace nesting it is defined in. We can use # the Ruby LSP's index to get the fully qualified name of the current namespace using the `@nesting` variable # provided by the TestDiscovery parent class current_group_name = RubyIndexer::Index.actual_nesting(@nesting, nil).join(\"::\") # The test explorer is populated with a hierarchy of items. Groups have children, which can include other # groups and examples. Listeners should always add newly discovered children to the parent item where they # are discovered. For example: # # class MyTest &lt; MyFrameworkGem::Test # # # this NestedTest is a child of MyTest # class NestedTest &lt; MyFrameworkGem::Test # # # this example is a child of NestedTest # def test_something; end # end # # # This example is a child of MyTest # def test_something_else; end # end # # Get the current test item from the response builder using the ID. In this case, the immediate group # enclosing will be based on the nesting test_item = @response_builder[current_group_name] return unless test_item # Create the test item for the example. To make IDs unique, always include the group names as part of the ID # since users can define the same exact example name in multiple different groups example_item = Requests::Support::TestItem.new( \"#{current_group_name}##{name}\", name, @uri, range_from_node(node), framework: :my_framework, ) # Add the example item to both as an explorer entry and code lens test_item.add(example_item) @response_builder.add_code_lens(example_item) end end end end . Test item IDs have an implicit formatting requirement: groups must be separated by :: and examples must be separated by #. This is required even for frameworks that do not use classes and methods to define groups and examples. Including spaces in group or example IDs is allowed. For example, if we have the following test: . class MyTest &lt; MyFrameworkGem::Test class NestedTest &lt; MyFrameworkGem::Test def test_something; end end end . the expected ID for the item representing test_something should be MyTest::NestedTest#test_something. For frameworks that do not define test groups using classes, such as RSpec, the listener should not inherit from RubyLsp::Listeners::TestDiscovery. Instead, the logic can be implemented directly, based on the framework’s specific rules. module RubyLsp module MyTestFrameworkGem class MySpecListener #: (ResponseBuilders::TestCollection, GlobalState, Prism::Dispatcher, URI::Generic) -&gt; void def initialize(response_builder, global_state, dispatcher, uri) # Register on the dispatcher for the node events we are interested in dispatcher.register(self, :on_call_node_enter) @spec_name_stack = [] end #: (Prism::CallNode) -&gt; void def on_call_node_enter(node) method_name = node.message case method_name when \"describe\", \"context\" # Extract the name of this group from the call node's arguments # Create a test item and push it as entries and code lenses # Push the name of this group into the stack, so that we can find which group is current later when \"it\" # Extract the name of this example from the call node's arguments # Create a test item and push it as entries and code lenses end end end end end . ",
    "url": "/ruby-lsp/test_framework_addons.html#test-discovery",
    
    "relUrl": "/test_framework_addons.html#test-discovery"
  },"51": {
    "doc": "Test framework add-ons",
    "title": "Command resolution",
    "content": "Command resolution is the process of receiving a hierarchy of tests selected in the UI and determining the shell commands required to run them. It’s important that we minimize the number of these commands, to avoid having to spawn too many Ruby processes. For example, this is what consolidated commands could look like when trying to run two specific examples in different frameworks: . # Rails style execution (very similar to RSpec) bin/rails test /project/test/models/user_test.rb:10:25 # Test Unit style execution based on regexes bundle exec ruby -Itest /test/model_test.rb --testcase \\\"/^ModelTest\\\\$/\\\" --name \\\"/test_something\\\\$/ # Minitest style execution based on regexes bundle exec ruby -Itest /test/model_test.rb --name \\\"/^ModelTest#test_something\\\\$/\\\" . The add-on’s responsibility is to figure out how to execute test items that are associated with the framework they add support for. Add-ons mark test items with the right framework during discovery and should only resolve items that belong to them. Another important point is that test groups with an empty children array are being fully executed. For example: . # A test item hierarchy that means: execute the ModelTest#test_something specific example and no other tests [ { id: \"ModelTest\", uri: \"file:///test/model_test.rb\", label: \"ModelTest\", range: { start: { line: 0, character: 0 }, end: { line: 30, character: 3 }, }, tags: [\"framework:minitest\", \"test_group\"], children: [ { id: \"ModelTest#test_something\", uri: \"file:///test/model_test.rb\", label: \"test_something\", range: { start: { line: 1, character: 2 }, end: { line: 10, character: 3 }, }, tags: [\"framework:minitest\"], children: [], }, ], }, ] # A test item hierarchy that means: execute the entire ModelTest group with all examples and nested groups inside [ { id: \"ModelTest\", uri: \"file:///test/model_test.rb\", label: \"ModelTest\", range: { start: { line: 0, character: 0 }, end: { line: 30, character: 3 }, }, tags: [\"framework:minitest\", \"test_group\"], children: [], }, ] . Add-ons can define the resolve_test_commands method to define how to resolve the commands required to execute a hierarchy. It is the responsibility of the add-on to filter the hierarchy to only the items that are related to them. module RubyLsp module MyTestFrameworkGem class Addon &lt; ::RubyLsp::Addon # Items is the hierarchy of test items to be executed. The return is the list of minimum shell commands required # to run them #: (Array[Hash[Symbol, untyped]]) -&gt; Array[String] def resolve_test_commands(items) commands = [] queue = items.dup until queue.empty? item = queue.shift tags = Set.new(item[:tags]) next unless tags.include?(\"framework:my_framework\") children = item[:children] if tags.include?(\"test_dir\") # Handle running entire directories elsif tags.include?(\"test_file\") # Handle running entire files elsif tags.include?(\"test_group\") # Handle running groups else # Handle running examples end queue.concat(children) unless children.empty? end commands end end end end . You can refer to implementation examples for Minitest and Test Unit or Rails. ",
    "url": "/ruby-lsp/test_framework_addons.html#command-resolution",
    
    "relUrl": "/test_framework_addons.html#command-resolution"
  },"52": {
    "doc": "Test framework add-ons",
    "title": "Custom reporting",
    "content": "To report test execution results to the extension side, frameworks should be hooked up with a custom reporter that sends JSON RPC events. To hook up the custom reporter, add-ons should include all CLI arguments necessary as part of resolving test commands. For example: . bundle exec my_framework /path/to/project/test/foo_test.rb --reporter MyFrameworkLspReporter . To implement the reporter, the Ruby LSP already provides helpers for all of the supported events. It is a matter of ensuring that all events are produced when the test framework performs the associated actions. # An Lsp reporter for our example test framework # See lib/ruby_lsp/test_reporters/lsp_reporter.rb for all available helpers and events class MyFrameworkGemLspReporter # Record that an example started running. This shows the example as running in the UI def test_started_running(test_object) id = \"#{test_object.class.name}##{test_object.method_name}\" uri = URI::Generic.from_path(path: test_object.file_path) RubyLsp::LspReporter.instance.start_test(id: id, uri: uri, line: test_object.line_number) end # Record that an example passed, which shows a green checkmark in the UI def test_passed(test_object) RubyLsp::LspReporter.instance.record_pass(id: id, uri: uri) end # Record that an example errored, which shows a red X in the UI and displays the exception message def test_errored(test_object) RubyLsp::LspReporter.instance.record_skip(id: id, uri: uri, message: \"Test errored because...\") end # Record that an example failed, which shows a red X in the UI and displays the failure message def test_failed(test_object) RubyLsp::LspReporter.instance.record_fail(id: id, uri: uri, message: \"Test failed because...\") end # Record that an example skipped, which shows a skipped status in the UI def test_skipped(test_object) RubyLsp::LspReporter.instance.record_skip(id: id, uri: uri) end # Normal shutdown flow, when all tests ran without crashing the test process itself def after_all_tests_finished_running LspReporter.instance.shutdown end end # This is required to cleanup the explorer in case the normal execution of tests errors. For example, if the user # writes a bad require and the test process crashes before even starting to run examples MyFrameworkGem.after_run_is_completed do RubyLsp::LspReporter.instance.at_exit end . The IDs and URIs used to report results must match the ones used during test discovery to ensure that the outcomes are associated with the right items. If your test framework is based on Minitest or Test Unit and leverages their reporting structure, you may not need to add custom reporters. Instead, you can simply rely on the ones automatically registered and provided by the Ruby LSP. See our reporters for Minitest and Test Unit as examples. ",
    "url": "/ruby-lsp/test_framework_addons.html#custom-reporting",
    
    "relUrl": "/test_framework_addons.html#custom-reporting"
  },"53": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": " ",
    "url": "/ruby-lsp/troubleshooting.html",
    
    "relUrl": "/troubleshooting.html"
  },"54": {
    "doc": "Troubleshooting",
    "title": "How the Ruby LSP activation works",
    "content": "The Ruby LSP extension runs inside VS Code’s NodeJS runtime, like any other VS Code extension. This means that environment variables that are properly set in your shell may not exist inside the NodeJS process. To run the LSP server with the same Ruby version as your projects, we need to properly set these environment variables, which is done by invoking your Ruby version manager. The extension runs a command using your shell’s interactive mode, so that version managers configured in files such as ~/.zshrc are picked up automatically. The command then exports the environment information into JSON, so that we can inject it into the NodeJS process and appropriately set the Ruby version and gem installation paths. As an example, the activation script for zsh using rbenv as a version manager will look something like this: . # Invoke zsh using interactive mode (loads ~/.zshrc) to run a single command # The command is `rbenv exec ruby`, which automatically sets all relevant environment variables and selects the # specified Ruby version # We then print the activated environment as JSON. We read that JSON from the NodeJS process to insert the needed # environment variables in order to run Ruby correctly /bin/zsh -ic 'rbenv exec ruby -rjson -e \"puts JSON.dump(ENV.to_h)\"' . After activating the Ruby version, we then proceed to boot the server gem (ruby-lsp). To avoid having users include the ruby-lsp in their Gemfile, we create a composed bundle under the .ruby-lsp directory inside your project. ",
    "url": "/ruby-lsp/troubleshooting.html#how-the-ruby-lsp-activation-works",
    
    "relUrl": "/troubleshooting.html#how-the-ruby-lsp-activation-works"
  },"55": {
    "doc": "Troubleshooting",
    "title": "Common issues",
    "content": "There are several main sources of issues users typically face during activation: outdated version, shell problems, or Bundler related problems. Outdated Version . If using VS Code, the version of the extension is distinct from that of the server (the ruby-lsp gem). You can check the server version in the status center. In most cases, the server gem will be automatically updated. You can also trigger a manual update with the “Update language server gem” command in VS Code. You can also attempt an update from the command line with BUNDLE_GEMFILE=.ruby-lsp/Gemfile bundle update ruby-lsp . If you’re using any add-on gem, such as ruby-lsp-rspec, then ruby-lsp will also be present in your Gemfile.lock and it’s possible that an outdated add-on could prevent ruby-lsp from updating. Another possible scenario where the ruby-lsp gem cannot be updated is when one of its runtime dependencies are constrained by another gem in the application. For example, Ruby LSP has a dependency on RBS v3. If another gem constrains the version of RBS to an older release, it will not be possible to use newer versions of Ruby LSP. The 3 runtime dependencies of the Ruby LSP are rbs, prism and sorbet-runtime. If any of them are being constrained by the application, the Ruby LSP may fail to update. Running BUNDLE_GEMFILE=.ruby-lsp/Gemfile bundle outdated may help with understanding what is being constrained. Shell issues . When the extension invokes the shell and loads its config file (~/.zshrc, ~/.bashrc, etc), it is susceptible to issues that may be caused by how the shell or its plugins interact with the NodeJS process. For example . | Some plugins completely redirect the stderr pipe to implement their functionality (fixed on the Ruby LSP side by https://github.com/Shopify/vscode-ruby-lsp/pull/918) | Some plugins fail immediately or end up in an endless loop if they detect there’s no UI attached to the shell process. In this case, it’s not possible to fix from the Ruby LSP side since a shell invoked by NodeJS will never have a UI | . Additionally, some users experience an issue where VS Code selects the wrong shell, not respecting the SHELL environment variable. This usually ends up in having /bin/sh selected instead of your actual shell. If you are facing this problem, please try to . | Update VS Code to the latest version | Completely close VS Code and launch it from the terminal with code . (instead of opening VS Code from the launch icon) | . More context about this issue on https://github.com/Shopify/vscode-ruby-lsp/issues/901. Bundler issues . Firstly, ensure you are using the latest release of Bundler (run bundle update --bundler). If the extension successfully activated the Ruby environment, it may still fail when trying to compose the composed bundle to run the server gem. This could be a regular Bundler issue, like not being able to satisfy dependencies due to a conflicting version requirement, or it could be a configuration issue. For example, if the project has its linter/formatter put in an optional Gemfile group and that group is excluded in the Bundler configuration, the Ruby LSP will not be able to see those gems. # Gemfile # ... # If Bundler is configured to exclude this group, the Ruby LSP will not be able to find `rubocop` group :optional_group do gem \"rubocop\" end . If you experience Bundler related issues, double-check both your global and project-specific configuration to check if there’s anything that could be preventing the server from booting. You can print your Bundler configuration with . bundle config . Format on save dialogue won’t disappear . When VS Code requests formatting for a document, it opens a dialogue showing progress a couple of seconds after sending the request, closing it once the server has responded with the formatting result. If you are seeing that the dialogue is not going away, this likely doesn’t mean that formatting is taking very long or hanging. It likely means that the server crashed or got into a corrupt state and is simply not responding to any requests, which means the dialogue will never go away. This is always the result of a bug in the server. It should always fail gracefully without getting into a corrupt state that prevents it from responding to new requests coming from the editor. If you encounter this, please submit a bug report here including the steps that led to the server getting stuck. Missing Features . If you find that some features are working (such as formatting), but others aren’t (such as go to definition), and are working on a codebase that uses Sorbet, then this may indicate the Sorbet LSP isn’t running. To avoid duplicate/conflicting behavior, Ruby LSP disables some features when a Sorbet codebase is detected, with the intention that Sorbet can provide better accuracy. Gem installation locations and permissions . To launch the Ruby LSP server, the ruby-lsp gem must be installed. And in order to automatically index your project’s dependencies, they must also be installed so that we can read, parse and analyze their source files. The ruby-lsp gem is installed via gem install (using RubyGems). The project dependencies are installed via bundle install (using Bundler). If you use a non-default path to install your gems, please remember that RubyGems and Bundler require separate configurations to achieve that. For example, if you configure BUNDLE_PATH to point to vendor/bundle so that gems are installed inside the same directory as your project, bundle install will automatically pick that up and install them in the right place. But gem install will not as it requires a different setting to achieve it. You can apply your preferred installed locations for RubyGems by using the ~/.gemrc file. In that file, you can decide to either install it with --user-install or select a specific installation directory with --install-dir. gem: --user-install # Or gem: --install-dir /my/preferred/path/for/gem/install . One scenario where this is useful is if the user doesn’t have permissions for the default gem installation directory and gem install fails. For example, when using the system Ruby on certain Linux distributions. Using non-default gem installation paths may lead to other integration issues with version managers. For example, for Ruby 3.3.1 the default GEM_HOME is ~/.gem/ruby/3.3.0 (without the patch part of the version). However, chruby (and potentially other version managers) override GEM_HOME to include the version patch resulting in ~/.gem/ruby/3.3.1. When you install a gem using gem install --user-install, RubyGems ignores the GEM_HOME override and installs the gem inside ~/.gem/ruby/3.3.0. This results in executables not being found because chruby modified the PATH to only include executables installed under ~/.gem/ruby/3.3.1. Similarly, the majority of version managers don’t read your ~/.gemrc configurations. If you use a custom installation with --install-dir, it’s unlikely that the version manager will know about it. This may result in the gem executables not being found. Incompatibilities between RubyGems and version managers like this one are beyond the scope of the Ruby LSP and should be reported either to RubyGems or the respective version manager. Developing on containers . See the documentation. ",
    "url": "/ruby-lsp/troubleshooting.html#common-issues",
    
    "relUrl": "/troubleshooting.html#common-issues"
  },"56": {
    "doc": "Troubleshooting",
    "title": "Diagnosing the problem",
    "content": "Many activation issues are specific to how your development environment is configured. If you can reproduce the problem you are seeing, including information about these steps is the best way to ensure that we can fix the issue in a timely manner. Please include the steps taken to diagnose in your bug report. Check if the server is running . Check the status center. Does the server status say it’s running? If it is running, but you are missing certain features, please check our features documentation to ensure we already added support for it. If the feature is listed as fully supported, but not working for you, report an issue so that we can assist. Check the VS Code output tab . Many of the activation steps taken are logged in the Ruby LSP channel of VS Code’s Output tab. Check the logs to see if any entries hint at what the issue might be. Did the extension select your preferred shell? . Did it select your preferred version manager? You can define which version manager to use with the \"rubyLsp.rubyVersionManager\" setting. No output in the Ruby LSP channel? Check the Extension Host channel for any errors related to extension startup. Enable logging . You can enable logging to the VS Code output tab, as described in the Contributing docs. Environment activation failed . We listed version manager related information and tips in this documentation. My preferred version manager is not supported . We default to supporting the most common version managers, but that may not cover every single tool available. For these cases, we offer custom activation support. More context in the version manager documentation. Try to run the Ruby activation manually . If the extension is failing to activate the Ruby environment, try running the same command manually in your shell to see if the issue is exclusively related with the extension. The exact command used for activation is printed to the output tab. Try booting the server manually . If the Ruby environment seems to activate properly, but the server won’t boot, try to launch is manually from the terminal with . # Do not use bundle exec ruby-lsp . Is there any extra information given from booting the server manually? Or does it only fail when booting through the extension? . ",
    "url": "/ruby-lsp/troubleshooting.html#diagnosing-the-problem",
    
    "relUrl": "/troubleshooting.html#diagnosing-the-problem"
  },"57": {
    "doc": "Troubleshooting",
    "title": "Indexing",
    "content": "When Ruby LSP starts, it attempts to index your code as well as your dependencies as described in Configuring code indexing. In rare cases, Ruby LSP will encounter an error which prevents indexing from completing, which will result in incomplete information in the editor. Firstly, ensure that you are using the latest release of the ruby-lsp gem, as the problem may have been already fixed. To diagnose the particular file(s) causing a problem, run ruby-lsp-check. Please log an issue so that we can address it. If the code is not open source then please provide a minimal reproduction. In the meantime, you can configure Ruby LSP to ignore a particular gem or file for indexing. ",
    "url": "/ruby-lsp/troubleshooting.html#indexing",
    
    "relUrl": "/troubleshooting.html#indexing"
  },"58": {
    "doc": "Troubleshooting",
    "title": "After troubleshooting",
    "content": "If after troubleshooting the Ruby LSP is still not initializing properly, please report an issue here so that we can assist in fixing the problem. Remember to include the steps taken when trying to diagnose the issue. ",
    "url": "/ruby-lsp/troubleshooting.html#after-troubleshooting",
    
    "relUrl": "/troubleshooting.html#after-troubleshooting"
  },"59": {
    "doc": "Version Managers",
    "title": "Version Managers",
    "content": "This document contains information and tips to help Ruby LSP’s VS Code extension work with your Ruby version manager. ",
    "url": "/ruby-lsp/version-managers.html",
    
    "relUrl": "/version-managers.html"
  },"60": {
    "doc": "Version Managers",
    "title": "asdf",
    "content": "Ensure you on the latest release of asdf: https://asdf-vm.com/manage/commands.html. If asdf was installed through Homebrew then you may need to first run brew upgrade asdf. If you use asdf and the VS Code extension fails to activate the environment (as described in this issue), you may resolve it by updating asdf to the latest version with asdf update, and then restart VS Code. ",
    "url": "/ruby-lsp/version-managers.html#asdf",
    
    "relUrl": "/version-managers.html#asdf"
  },"61": {
    "doc": "Version Managers",
    "title": "Chruby",
    "content": "Ensure you are on the latest release of chruby. If you use chruby but don’t have a .ruby-version file in the project root, you can add .ruby-version to its parent folder as a fallback. For example, if /projects/my_project doesn’t have .ruby-version, chruby would read /projects/.ruby-version instead. ",
    "url": "/ruby-lsp/version-managers.html#chruby",
    
    "relUrl": "/version-managers.html#chruby"
  },"62": {
    "doc": "Version Managers",
    "title": "Mise",
    "content": "Ensure Mise is up-to-date: https://mise.jdx.dev/faq.html#mise-is-failing-or-not-working-right . ",
    "url": "/ruby-lsp/version-managers.html#mise",
    
    "relUrl": "/version-managers.html#mise"
  },"63": {
    "doc": "Version Managers",
    "title": "RVM",
    "content": "Ensure RVM is up-to-date: https://rvm.io/rvm/upgrading . ",
    "url": "/ruby-lsp/version-managers.html#rvm",
    
    "relUrl": "/version-managers.html#rvm"
  },"64": {
    "doc": "Version Managers",
    "title": "Custom activation",
    "content": "If you’re using a different version manager that’s not supported by this extension or if you’re manually inserting the Ruby executable into the PATH, you will probably need to define custom activation so that the extension can find the correct Ruby. For these cases, set rubyLsp.rubyVersionManager.identifier to \"custom\" and then set rubyLsp.customRubyCommand to a shell command that will activate the right Ruby version or add the Ruby bin folder to the PATH. Some examples: . { // Don't forget to set the manager to custom when using this option \"rubyLsp.rubyVersionManager\": { \"identifier\": \"custom\", }, // Using a different version manager than the ones included by default \"rubyLsp.customRubyCommand\": \"my_custom_version_manager activate\", // Adding a custom Ruby bin folder to the PATH \"rubyLsp.customRubyCommand\": \"PATH=/path/to/ruby/bin:$PATH\", } . ",
    "url": "/ruby-lsp/version-managers.html#custom-activation",
    
    "relUrl": "/version-managers.html#custom-activation"
  },"65": {
    "doc": "VS Code extension",
    "title": "Ruby LSP",
    "content": "The Ruby LSP is an implementation of the language server protocol for Ruby, used to improve rich features in editors. ",
    "url": "/ruby-lsp/vscode-extension.html#ruby-lsp",
    
    "relUrl": "/vscode-extension.html#ruby-lsp"
  },"66": {
    "doc": "VS Code extension",
    "title": "Features",
    "content": ". The Ruby LSP features include . | Semantic highlighting | Symbol search and code outline | RuboCop errors and warnings (diagnostics) | Format on save (with RuboCop or Syntax Tree) | Format on type | Debugging support | Running and debugging tests through VS Code’s UI | Go to definition | Showing documentation on hover | Completion | Fuzzy search declarations anywhere in the project (workspace symbol) | Running Rails generators from the UI | . See complete information about features here. If you experience issues, please see the troubleshooting guide. [Experimental] GitHub Copilot chat agent . For users of Copilot, the Ruby LSP contributes a Ruby agent for AI assisted development of Ruby applications. Below you can find the documentation of each command for the Ruby agent. For information about how to interact with Copilot Chat, check VS Code’s official documentation. Design command . The @ruby /design command is intended to be a domain driven design expert to help users model concepts for their Rails applications. Users should describe what type of application they are building and which concept they are trying to model. The command will read their Rails application’s schema and use their prompt, previous interactions and the schema information to provide suggestions of how to design the application. For example, . @ruby /design I'm working on a web application for schools. How do I model courses? And how do they relate to students? . The output is a suggested schema for courses including relationships with users. In the chat window, two buttons will appear: Generate with Rails, which invokes the Rails generators to create the models suggested, and Revert previous generation, which will delete files generated by a previous click in the generate button. As with most LLM chat functionality, suggestions may not be fully accurate, especially in the first iteration. Users can continue chatting with the @ruby agent to fine tune the suggestions given, before deciding to move forward with generation. If you have feedback about this feature, you can let us know in the DX Slack or by creating an issue. ",
    "url": "/ruby-lsp/vscode-extension.html#features",
    
    "relUrl": "/vscode-extension.html#features"
  },"67": {
    "doc": "VS Code extension",
    "title": "Usage",
    "content": "Search for Shopify.ruby-lsp in the extensions tab and click install. By default, the Ruby LSP will generate a .ruby-lsp directory with a composed bundle that includes the server gem. Additionally, it will attempt to use available version managers to select the correct Ruby version for any given project. Refer to configuration for more options. Commands . Available commands are listed below and can always be found by searching for the Ruby LSP prefix in the command palette (Default hotkey: CMD + SHIFT + P). | Command | Description | . | Ruby LSP: Start | Start the Ruby LSP server | . | Ruby LSP: Restart | Restart the Ruby LSP server | . | Ruby LSP: Stop | Stop the Ruby LSP server | . | Ruby LSP: Update language server gem | Updates the ruby-lsp server gem to the latest version | . Snippets . This extension provides convenience snippets for common Ruby constructs, such as blocks, classes, methods or even unit test boilerplates. Find the full list here. Configuration . Enable or disable features . The Ruby LSP allows disabling specific features. To do so, open the language status center right next to the language mode Ruby and select Manage right next to enabled features. Ruby version managers . To boot the server properly, the Ruby LSP uses a version manager to activate the right environment variables that point Bundler to the Ruby and gem paths. This is especially necessary when switching between projects that use different Ruby versions - since those paths change and need to be reactivated. By default, the Ruby LSP will attempt to automatically determine which version manager it should use, checking which ones are available (auto option). If that fails, then the version manager must be manually configured. You can do so by clicking Change version manager in the language status center or by changing your VS Code user settings. // Available options are // \"auto\" (select version manager automatically) // \"none\" (do not use a version manager) // \"custom\" (use rubyLsp.customRubyCommand for finding/activating Ruby) // \"asdf\" // \"chruby\" // \"rbenv\" // \"rvm\" // \"shadowenv\" // \"mise\" { \"rubyLsp.rubyVersionManager\": { \"identifier\": \"chruby\", }, } . To make sure that the Ruby LSP can find the version manager scripts, make sure that they are loaded in the shell’s configuration script (e.g.: ~/.bashrc, ~/.zshrc) and that the SHELL environment variable is set and pointing to the default shell. For manager-specific notes, setting up custom activation for managers not listed above and community-contributed examples, please see version managers. Configuring a formatter . The tool to be used for formatting files can be configured with the following setting. // Available options // auto: automatically detect the formatter based on the app's bundle (default) // none: do not use a formatter (disables format on save and related diagnostics) // all other options are the name of the formatter (e.g.: rubocop or syntax_tree) \"rubyLsp.formatter\": \"auto\" . Ruby version requirement . By default, the Ruby LSP uses the current project’s Ruby version and bundle. This allows the LSP to index the correct gem versions, and to ensure formatting behavior is consistent with CI. The Ruby LSP and its main dependency Prism (the new Ruby parser) both follow the same policy, which is to support only Ruby versions that are not beyond their end-of-life. If you’re working on a project with an older Ruby version, it might be possible to install older versions of the server gem to get support for older rubies, but that might also involve using older versions of the VS Code extension - since some functionality requires implementations in both client and server. The other alternative is to use a custom Gemfile separate from the project with a different Ruby version. Notice that certain functionality may be degraded or require manual configuration, since the Ruby LSP will not be able to inspect the project’s real bundle to discover dependencies. Please see the instructions below. Using a custom Gemfile . If you are working on a project using an older version of Ruby not supported by Ruby LSP, then you may specify a separate Gemfile for development tools. Note: when using this, gems will not be installed automatically and neither will ruby-lsp upgrades. Create a directory to store the composed bundle outside of the project that uses the old Ruby version. Inside that directory, add your preferred version manager configuration to select a supported Ruby version. For example, if using chruby, it would look like this: . # the/directory/.ruby-version 3.2.2 . Create a Gemfile for development tools inside that directory. # the/directory/Gemfile source \"https://rubygems.org\" gem \"ruby-lsp\" gem \"rubocop\" . Take in mind that formatters, linters and their extensions should be included in the custom gemfile; you might need to add more gems than the ones shown above. e.g: If you are using rubocop, you would also need to add them: . gem \"rubocop-packaging\" gem \"rubocop-performance\" gem \"rubocop-rspec\" gem \"rubocop-shopify\" gem \"rubocop-thread_safety\" . Run bundle install inside that directory to generate a lockfile. After the directory contains the custom Gemfile and the version manager configuration, use the following configuration in VS Code to point the Ruby LSP to that Gemfile. { \"rubyLsp.bundleGemfile\": \"../../path/to/the/directory/Gemfile\", } . rubyLsp.bundleGemfile can be a relative or absolute path. Configuring VS Code debugger . To configure the VS Code debugger, you can use the “Debug: Add configuration…” command to create a launch.json file in the .vscode directory of your project. This command would generate the following configuration: . { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"ruby_lsp\", \"name\": \"Debug\", \"request\": \"launch\", \"program\": \"ruby ${file}\", }, { \"type\": \"ruby_lsp\", \"request\": \"launch\", \"name\": \"Debug test file\", \"program\": \"ruby -Itest ${relativeFile}\", }, { \"type\": \"ruby_lsp\", \"request\": \"attach\", \"name\": \"Attach to existing server\", }, ], } . Debugging live processes . Instead of launching a process to debug every time, you may want to attach the VS Code debugger to an existing process, such as a Rails server. Follow these instructions to do so. Install debug gem. Verify by running bundle exec rdbg -v . Run your application with the debugger attached, so that the extension can connect to it. bundle exec rdbg -O -n -c -- bin/rails server -p 3000 . For better integrated rails tests support also install ruby-lsp-rails gem. VS Code configurations . In addition to the Ruby LSP’s own configuration, there are some VS Code settings that may need to be changed to get the most of the Ruby LSP. These settings are not specific to the Ruby LSP, but they impact all language servers and take precedence over any other configurations. These are the settings that may impact the Ruby LSP’s behavior and their explanations. { // All of these settings are scoped only to the Ruby language \"[ruby]\": { \"editor.defaultFormatter\": \"Shopify.ruby-lsp\", // Use the Ruby LSP as the default formatter \"editor.formatOnSave\": true, // Format files automatically when saving \"editor.tabSize\": 2, // Use 2 spaces for indentation \"editor.insertSpaces\": true, // Use spaces and not tabs for indentation \"editor.semanticHighlighting.enabled\": true, // Enable semantic highlighting \"editor.formatOnType\": true, // Enable formatting while typing }, } . Multi-root workspaces . Multi-root workspaces are VS Code’s way to allow users to organize a single repository into multiple distinct concerns. Notice that this does not necessarily match the concept of a project. For example, a web application with separate directories for its frontend and backend may be conceptually considered as a single project, but you can still configure the frontend and backend directories to be different workspaces. The advantage of adopting this configuration is that VS Code and all extensions are informed about which directories should be considered as possible workspace roots. Instead of having to configure each extension or tool individually so they are aware of your project structure, you only have to do that once for the entire repository. Some examples of functionality that benefits from multi-root workspaces: . | Extensions that have to integrate with project dependencies (Gemfile, package.json), such as debuggers, language servers, formatters and other tools, are informed about where to search for these files (allowing for automatic detection) | If launch.json configurations are placed inside a workspace, VS Code will know to launch them from the appropriate directory (Ruby LSP example), without requiring you to specify the cwd | When opening a terminal, VS Code will offer to open the terminal on all configured workspaces | . The Ruby LSP supports multi-root workspaces by spawning a separate language server for each one of them. This strategy is preferred over a single language server that supports multiple workspaces because each workspace could be using a different Ruby version and completely different gems - which would be impossible to support in a single Ruby process. What matters to properly spawn the Ruby LSP is knowing where the main Gemfile of each workspace inside of the same repository is. Example configurations . To make sure Ruby LSP works well with your multi-root workspace project, please read through the instructions below and configure it following the examples. After configuring, do not forget to tell VS Code to open the workspace from the code-workspace file . Consider a project where the top level of the repository is a Rails application and a sub-directory called frontend contains a React application that implements the frontend layer. my_project/ frontend/ Gemfile Gemfile.lock config.ru super_awesome_project.code-workspace . A possible configuration for the super_awesome_project would be this: . { \"folders\": [ // At the top level of the repository, we have the Rails application { \"name\": \"rails\", \"path\": \".\", }, // Inside the frontend directory, we have the React frontend { \"name\": \"react\", \"path\": \"frontend\", }, ], \"settings\": { // To avoid having VS Code display the same files twice, we can simply exclude the frontend sub-directory. This // means it will only show up as a separate workspace \"files.exclude\": { \"frontend\": true, }, }, } . Now consider a monorepo where both the client and the server are under sub-directories. my_project/ client/ server/ Gemfile Gemfile.lock super_awesome_project.code-workspace . In this case, we can configure the workspaces as: . { \"folders\": [ // Both parts of the project (client and server) are inside sub-directories. But since the top level might contain // some documentation or build files, we still want it to show up { \"name\": \"awesome_project\", \"path\": \".\", }, // Inside the client directory, we have the client part of the project { \"name\": \"client\", \"path\": \"client\", }, // Inside the server directory, we have the server part of the project { \"name\": \"server\", \"path\": \"server\", }, ], \"settings\": { // We don't want to show duplicates, so we hide the directories that are already showing up as workspaces \"files.exclude\": { \"server\": true, \"client\": true, }, }, } . For more information, read VS Code’s workspace documentation and multi-root workspace documentation. Developing on containers . The Ruby LSP is a detached language server, which means it’s a background process that runs separately from the VS Code instance. To provide its functionality, the Ruby LSP must be running in the same place where your project files exist and dependencies are installed. VS Code supports connecting to containers out of the box, which makes all editor features work seamlessly. That includes language servers, the integrated terminal, etc. The VS Code documentation has instructions on how to develop on containers locally or remotely. Please check the following resources before opening an issue: . | Developing inside a Container | Advanced container configuration | . Please note that only Docker is officially supported as a backend by the Dev Container extension. 1 . ",
    "url": "/ruby-lsp/vscode-extension.html#usage",
    
    "relUrl": "/vscode-extension.html#usage"
  },"68": {
    "doc": "VS Code extension",
    "title": "Telemetry",
    "content": "The Ruby LSP does not collect any telemetry by default, but it supports hooking up to a private metrics service if desired. This can be useful if you’d like to understand adoption, performance or catch errors of the Ruby LSP within your team or company. To collect metrics, another VS Code extension (typically a private one) should define the command getTelemetrySenderObject. This command should return an object that implements the vscode.TelemetrySender interface, thus defining where data and error reports should be sent to. For example: . // Your private VS Code extension class Telemetry implements vscode.TelemetrySender { constructor() { // Initialize some API service or whatever is needed to collect metrics } sendEventData(eventName: string, data: EventData): void { // Send events to some API or accumulate them to be sent in batch when `flush` is invoked by VS Code } sendErrorData(error: Error, data?: Record&lt;string, any&gt; | undefined): void { // Send errors to some API or accumulate them to be sent in batch when `flush` is invoked by VS Code } async flush() { // Optional function to flush accumulated events and errors } } export async function activate(context: vscode.ExtensionContext) { const telemetry = new Telemetry(); await telemetry.activate(); // Register the command that the Ruby LSP will search for to hook into context.subscriptions.push( vscode.commands.registerCommand(\"getTelemetrySenderObject\", () =&gt; { return telemetry; }), ); } . ",
    "url": "/ruby-lsp/vscode-extension.html#telemetry",
    
    "relUrl": "/vscode-extension.html#telemetry"
  },"69": {
    "doc": "VS Code extension",
    "title": "Formatting",
    "content": "When rubyLsp.formatter is set to auto, Ruby LSP tries to determine which formatter to use. If the bundle has a direct dependency on a supported formatter, such as rubocop or syntax_tree, that will be used. Otherwise, formatting will be disabled and you will need add one to the bundle. Using globally installed formatters or linters is not supported, they must in your Gemfile or gemspec. ",
    "url": "/ruby-lsp/vscode-extension.html#formatting",
    
    "relUrl": "/vscode-extension.html#formatting"
  },"70": {
    "doc": "VS Code extension",
    "title": "Indexing Configuration",
    "content": "To configure indexing, pass a JSON hash as part of the Ruby LSP configuration, for example: . // PROJECT/.vscode/settings.json { \"rubyLsp.indexing\": { \"excludedPatterns\": [\"**/test/**/*.rb\"], \"includedPatterns\": [\"**/bin/**/*\"], \"excludedGems\": [\"rubocop\", \"rubocop-performance\"], \"excludedMagicComments\": [\"compiled:true\"], }, } . ",
    "url": "/ruby-lsp/vscode-extension.html#indexing-configuration",
    
    "relUrl": "/vscode-extension.html#indexing-configuration"
  },"71": {
    "doc": "VS Code extension",
    "title": "VS Code extension",
    "content": " ",
    "url": "/ruby-lsp/vscode-extension.html",
    
    "relUrl": "/vscode-extension.html"
  }
}
