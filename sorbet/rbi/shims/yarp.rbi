# typed: strict

=begin
This file is generated by the templates/template.rb script and should not be
modified manually. See templates/rbi/yarp.rbi.erb
if you are looking to modify the template
=end

module YARP
  class Node
    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(Location) }
    def location; end
  end

  class Location
    sig { returns(String) }
    def slice; end

    sig { returns(T::Array[Comment]) }
    def comments; end
  end

  class Comment
    sig { returns(Location) }
    def location; end
  end

  # Represents the use of the `alias` keyword to alias a global variable.
  #
  #     alias $foo $bar
  #     ^^^^^^^^^^^^^^^
  class AliasGlobalVariableNode < Node
    sig { returns(Node) }
    attr_reader :new_name

    sig { returns(Node) }
    attr_reader :old_name

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(new_name: Node, old_name: Node, keyword_loc: Location, location: Location).void }
    def initialize(new_name, old_name, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AliasGlobalVariableNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `alias` keyword to alias a method.
  #
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasMethodNode < Node
    sig { returns(Node) }
    attr_reader :new_name

    sig { returns(Node) }
    attr_reader :old_name

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(new_name: Node, old_name: Node, keyword_loc: Location, location: Location).void }
    def initialize(new_name, old_name, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AliasMethodNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an alternation pattern in pattern matching.
  #
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    sig { returns(Node) }
    attr_reader :left

    sig { returns(Node) }
    attr_reader :right

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).void }
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AlternationPatternNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&` operator or the `and` keyword.
  #
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    sig { returns(Node) }
    attr_reader :left

    sig { returns(Node) }
    attr_reader :right

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).void }
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AndNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a set of arguments to a method or a keyword.
  #
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :arguments

    sig { params(arguments: T::Array[Node], location: Location).void }
    def initialize(arguments, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ArgumentsNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an array literal. This can be a regular array using brackets or
  # a special array using % like %w or %i.
  #
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :elements

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(elements: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).void }
    def initialize(elements, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ArrayNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an array pattern in pattern matching.
  #
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  #
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  #
  #     foo in *1
  #     ^^^^^^^^^
  #
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  #
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :constant

    sig { returns(T::Array[Node]) }
    attr_reader :requireds

    sig { returns(T.nilable(Node)) }
    attr_reader :rest

    sig { returns(T::Array[Node]) }
    attr_reader :posts

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(constant: T.nilable(Node), requireds: T::Array[Node], rest: T.nilable(Node), posts: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).void }
    def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ArrayPatternNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a hash key/value pair.
  #
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    sig { returns(Node) }
    attr_reader :key

    sig { returns(T.nilable(Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { params(key: Node, value: T.nilable(Node), operator_loc: T.nilable(Location), location: Location).void }
    def initialize(key, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AssocNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a splat in a hash literal.
  #
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :value

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(value: T.nilable(Node), operator_loc: Location, location: Location).void }
    def initialize(value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(AssocSplatNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents reading a reference to a field in the previous match.
  #
  #     $'
  #     ^^
  class BackReferenceReadNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BackReferenceReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a begin statement.
  #
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :begin_keyword_loc

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(T.nilable(RescueNode)) }
    attr_reader :rescue_clause

    sig { returns(T.nilable(ElseNode)) }
    attr_reader :else_clause

    sig { returns(T.nilable(EnsureNode)) }
    attr_reader :ensure_clause

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig { params(begin_keyword_loc: T.nilable(Location), statements: T.nilable(StatementsNode), rescue_clause: T.nilable(RescueNode), else_clause: T.nilable(ElseNode), ensure_clause: T.nilable(EnsureNode), end_keyword_loc: T.nilable(Location), location: Location).void }
    def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BeginNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def begin_keyword; end

    sig { returns(T.nilable(String)) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents block method arguments.
  #
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :expression

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(expression: T.nilable(Node), operator_loc: Location, location: Location).void }
    def initialize(expression, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BlockArgumentNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a block local variable.
  #
  #     a { |; b| }
  #            ^
  class BlockLocalVariableNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BlockLocalVariableNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a block of ruby code.
  #
  # [1, 2, 3].each { |i| puts x }
  #                ^^^^^^^^^^^^^^
  class BlockNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(T.nilable(BlockParametersNode)) }
    attr_reader :parameters

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(locals: T::Array[Symbol], parameters: T.nilable(BlockParametersNode), body: T.nilable(Node), opening_loc: Location, closing_loc: Location, location: Location).void }
    def initialize(locals, parameters, body, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BlockNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a block parameter to a method, block, or lambda definition.
  #
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    sig { returns(T.nilable(Symbol)) }
    attr_reader :name

    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BlockParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a block's parameters declaration.
  #
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    sig { returns(T.nilable(ParametersNode)) }
    attr_reader :parameters

    sig { returns(T::Array[Node]) }
    attr_reader :locals

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(parameters: T.nilable(ParametersNode), locals: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).void }
    def initialize(parameters, locals, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BlockParametersNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `break` keyword.
  #
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(arguments: T.nilable(ArgumentsNode), keyword_loc: Location, location: Location).void }
    def initialize(arguments, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(BreakNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator on a call.
  #
  #     foo.bar &&= value
  #     ^^^^^^^^^^^^^^^^^
  class CallAndWriteNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(Location)) }
    attr_reader :call_operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :message_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(String) }
    attr_reader :read_name

    sig { returns(String) }
    attr_reader :write_name

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location).void }
    def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CallAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def call_operator; end

    sig { returns(T.nilable(String)) }
    def message; end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def safe_navigation?; end

    sig { returns(T::Boolean) }
    def variable_call?; end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a method call, in all of the various forms that can take.
  #
  #     foo
  #     ^^^
  #
  #     foo()
  #     ^^^^^
  #
  #     +foo
  #     ^^^^
  #
  #     foo + bar
  #     ^^^^^^^^^
  #
  #     foo.bar
  #     ^^^^^^^
  #
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(Location)) }
    attr_reader :call_operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :message_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(T.nilable(BlockNode)) }
    attr_reader :block

    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(String) }
    attr_reader :name

    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), block: T.nilable(BlockNode), flags: Integer, name: String, location: Location).void }
    def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CallNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def call_operator; end

    sig { returns(T.nilable(String)) }
    def message; end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def safe_navigation?; end

    sig { returns(T::Boolean) }
    def variable_call?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of an assignment operator on a call.
  #
  #     foo.bar += baz
  #     ^^^^^^^^^^^^^^
  class CallOperatorWriteNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(Location)) }
    attr_reader :call_operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :message_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(String) }
    attr_reader :read_name

    sig { returns(String) }
    attr_reader :write_name

    sig { returns(Symbol) }
    attr_reader :operator

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator: Symbol, operator_loc: Location, value: Node, location: Location).void }
    def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CallOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def call_operator; end

    sig { returns(T.nilable(String)) }
    def message; end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def safe_navigation?; end

    sig { returns(T::Boolean) }
    def variable_call?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator on a call.
  #
  #     foo.bar ||= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOrWriteNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(Location)) }
    attr_reader :call_operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :message_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(String) }
    attr_reader :read_name

    sig { returns(String) }
    attr_reader :write_name

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location).void }
    def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CallOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def call_operator; end

    sig { returns(T.nilable(String)) }
    def message; end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def safe_navigation?; end

    sig { returns(T::Boolean) }
    def variable_call?; end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a local variable in pattern matching.
  #
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    sig { returns(Node) }
    attr_reader :value

    sig { returns(Node) }
    attr_reader :target

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(value: Node, target: Node, operator_loc: Location, location: Location).void }
    def initialize(value, target, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CapturePatternNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of a case statement.
  #
  # case true
  # ^^^^^^^^^
  # when false
  # end
  class CaseNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :predicate

    sig { returns(T::Array[Node]) }
    attr_reader :conditions

    sig { returns(T.nilable(ElseNode)) }
    attr_reader :consequent

    sig { returns(Location) }
    attr_reader :case_keyword_loc

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { params(predicate: T.nilable(Node), conditions: T::Array[Node], consequent: T.nilable(ElseNode), case_keyword_loc: Location, end_keyword_loc: Location, location: Location).void }
    def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(CaseNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def case_keyword; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a class declaration involving the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(Location) }
    attr_reader :class_keyword_loc

    sig { returns(Node) }
    attr_reader :constant_path

    sig { returns(T.nilable(Location)) }
    attr_reader :inheritance_operator_loc

    sig { returns(T.nilable(Node)) }
    attr_reader :superclass

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { returns(Symbol) }
    attr_reader :name

    sig { params(locals: T::Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: T.nilable(Location), superclass: T.nilable(Node), body: T.nilable(Node), end_keyword_loc: Location, name: Symbol, location: Location).void }
    def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def class_keyword; end

    sig { returns(T.nilable(String)) }
    def inheritance_operator; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to a class variable.
  #
  #     @@target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ClassVariableAndWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a class variable using an operator that isn't `=`.
  #
  #     @@target += value
  #     ^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :operator

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to a class variable.
  #
  #     @@target ||= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableOrWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents referencing a class variable.
  #
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a class variable in a context that doesn't have an explicit value.
  #
  #     @@foo, @@bar = baz
  #     ^^^^^  ^^^^^
  class ClassVariableTargetNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a class variable.
  #
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: T.nilable(Location), location: Location).void }
    def initialize(name, name_loc, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ClassVariableWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to a constant.
  #
  #     Target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantAndWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a constant using an operator that isn't `=`.
  #
  #     Target += value
  #     ^^^^^^^^^^^^^^^
  class ConstantOperatorWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :operator

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to a constant.
  #
  #     Target ||= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOrWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to a constant path.
  #
  #     Parent::Child &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathAndWriteNode < Node
    sig { returns(ConstantPathNode) }
    attr_reader :target

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).void }
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents accessing a constant through a path of `::` operators.
  #
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :parent

    sig { returns(Node) }
    attr_reader :child

    sig { returns(Location) }
    attr_reader :delimiter_loc

    sig { params(parent: T.nilable(Node), child: Node, delimiter_loc: Location, location: Location).void }
    def initialize(parent, child, delimiter_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def delimiter; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a constant path using an operator that isn't `=`.
  #
  #     Parent::Child += value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorWriteNode < Node
    sig { returns(ConstantPathNode) }
    attr_reader :target

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :operator

    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location).void }
    def initialize(target, operator_loc, value, operator, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to a constant path.
  #
  #     Parent::Child ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOrWriteNode < Node
    sig { returns(ConstantPathNode) }
    attr_reader :target

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).void }
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a constant path in a context that doesn't have an explicit value.
  #
  #     Foo::Foo, Bar::Bar = baz
  #     ^^^^^^^^  ^^^^^^^^
  class ConstantPathTargetNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :parent

    sig { returns(Node) }
    attr_reader :child

    sig { returns(Location) }
    attr_reader :delimiter_loc

    sig { params(parent: T.nilable(Node), child: Node, delimiter_loc: Location, location: Location).void }
    def initialize(parent, child, delimiter_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def delimiter; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a constant path.
  #
  #     ::Foo = 1
  #     ^^^^^^^^^
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  #
  #     ::Foo::Bar = 1
  #     ^^^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    sig { returns(ConstantPathNode) }
    attr_reader :target

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).void }
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantPathWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents referencing a constant.
  #
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a constant in a context that doesn't have an explicit value.
  #
  #     Foo, Bar = baz
  #     ^^^  ^^^
  class ConstantTargetNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a constant.
  #
  #     Foo = 1
  #     ^^^^^^^
  class ConstantWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ConstantWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a method definition.
  #
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(ParametersNode)) }
    attr_reader :parameters

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(Location) }
    attr_reader :def_keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :equal_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig { params(name: Symbol, name_loc: Location, receiver: T.nilable(Node), parameters: T.nilable(ParametersNode), body: T.nilable(Node), locals: T::Array[Symbol], def_keyword_loc: Location, operator_loc: T.nilable(Location), lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), equal_loc: T.nilable(Location), end_keyword_loc: T.nilable(Location), location: Location).void }
    def initialize(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(DefNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def def_keyword; end

    sig { returns(T.nilable(String)) }
    def operator; end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { returns(T.nilable(String)) }
    def equal; end

    sig { returns(T.nilable(String)) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `defined?` keyword.
  #
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(lparen_loc: T.nilable(Location), value: Node, rparen_loc: T.nilable(Location), keyword_loc: Location, location: Location).void }
    def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(DefinedNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  #
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    sig { returns(Location) }
    attr_reader :else_keyword_loc

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig { params(else_keyword_loc: Location, statements: T.nilable(StatementsNode), end_keyword_loc: T.nilable(Location), location: Location).void }
    def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ElseNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def else_keyword; end

    sig { returns(T.nilable(String)) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an interpolated set of statements.
  #
  #     "foo #{bar}"
  #          ^^^^^^
  class EmbeddedStatementsNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(opening_loc: Location, statements: T.nilable(StatementsNode), closing_loc: Location, location: Location).void }
    def initialize(opening_loc, statements, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(EmbeddedStatementsNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an interpolated variable.
  #
  #     "foo #@bar"
  #          ^^^^^
  class EmbeddedVariableNode < Node
    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :variable

    sig { params(operator_loc: Location, variable: Node, location: Location).void }
    def initialize(operator_loc, variable, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(EmbeddedVariableNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an `ensure` clause in a `begin` statement.
  #
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    sig { returns(Location) }
    attr_reader :ensure_keyword_loc

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { params(ensure_keyword_loc: Location, statements: T.nilable(StatementsNode), end_keyword_loc: Location, location: Location).void }
    def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(EnsureNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def ensure_keyword; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the literal `false` keyword.
  #
  #     false
  #     ^^^^^
  class FalseNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(FalseNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a find pattern in pattern matching.
  #
  #     foo in *bar, baz, *qux
  #     ^^^^^^^^^^^^^^^^^^^^^^
  #
  #     foo in [*bar, baz, *qux]
  #     ^^^^^^^^^^^^^^^^^^^^^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :constant

    sig { returns(Node) }
    attr_reader :left

    sig { returns(T::Array[Node]) }
    attr_reader :requireds

    sig { returns(Node) }
    attr_reader :right

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(constant: T.nilable(Node), left: Node, requireds: T::Array[Node], right: Node, opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).void }
    def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(FindPatternNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `..` or `...` operators to create flip flops.
  #
  #     baz if foo .. bar
  #            ^^^^^^^^^^
  class FlipFlopNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :left

    sig { returns(T.nilable(Node)) }
    attr_reader :right

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(left: T.nilable(Node), right: T.nilable(Node), operator_loc: Location, flags: Integer, location: Location).void }
    def initialize(left, right, operator_loc, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(FlipFlopNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(T::Boolean) }
    def exclude_end?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a floating point number literal.
  #
  #     1.0
  #     ^^^
  class FloatNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(FloatNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `for` keyword.
  #
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    sig { returns(Node) }
    attr_reader :index

    sig { returns(Node) }
    attr_reader :collection

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :for_keyword_loc

    sig { returns(Location) }
    attr_reader :in_keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :do_keyword_loc

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { params(index: Node, collection: Node, statements: T.nilable(StatementsNode), for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: T.nilable(Location), end_keyword_loc: Location, location: Location).void }
    def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ForNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def for_keyword; end

    sig { returns(String) }
    def in_keyword; end

    sig { returns(T.nilable(String)) }
    def do_keyword; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents forwarding all arguments to this method to another method.
  #
  #     def foo(...)
  #       bar(...)
  #       ^^^^^^^^
  #     end
  class ForwardingArgumentsNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ForwardingArgumentsNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  #
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ForwardingParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `super` keyword without parentheses or arguments.
  #
  #     super
  #     ^^^^^
  class ForwardingSuperNode < Node
    sig { returns(T.nilable(BlockNode)) }
    attr_reader :block

    sig { params(block: T.nilable(BlockNode), location: Location).void }
    def initialize(block, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ForwardingSuperNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to a global variable.
  #
  #     $target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableAndWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a global variable using an operator that isn't `=`.
  #
  #     $target += value
  #     ^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :operator

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to a global variable.
  #
  #     $target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOrWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents referencing a global variable.
  #
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a global variable in a context that doesn't have an explicit value.
  #
  #     $foo, $bar = baz
  #     ^^^^  ^^^^
  class GlobalVariableTargetNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a global variable.
  #
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(GlobalVariableWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a hash literal.
  #
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :elements

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(opening_loc: Location, elements: T::Array[Node], closing_loc: Location, location: Location).void }
    def initialize(opening_loc, elements, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(HashNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a hash pattern in pattern matching.
  #
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  #
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  class HashPatternNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :constant

    sig { returns(T::Array[Node]) }
    attr_reader :assocs

    sig { returns(T.nilable(Node)) }
    attr_reader :kwrest

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(constant: T.nilable(Node), assocs: T::Array[Node], kwrest: T.nilable(Node), opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).void }
    def initialize(constant, assocs, kwrest, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(HashPatternNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `if` keyword, either in the block form or the modifier form.
  #
  #     bar if foo
  #     ^^^^^^^^^^
  #
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  class IfNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :if_keyword_loc

    sig { returns(Node) }
    attr_reader :predicate

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(T.nilable(Node)) }
    attr_reader :consequent

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig { params(if_keyword_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), consequent: T.nilable(Node), end_keyword_loc: T.nilable(Location), location: Location).void }
    def initialize(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(IfNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def if_keyword; end

    sig { returns(T.nilable(String)) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an imaginary number literal.
  #
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    sig { returns(Node) }
    attr_reader :numeric

    sig { params(numeric: Node, location: Location).void }
    def initialize(numeric, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ImaginaryNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a node that is implicitly being added to the tree but doesn't
  # correspond directly to a node in the source.
  #
  #     { foo: }
  #       ^^^^
  #
  #     { Foo: }
  #       ^^^^
  class ImplicitNode < Node
    sig { returns(Node) }
    attr_reader :value

    sig { params(value: Node, location: Location).void }
    def initialize(value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ImplicitNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `in` keyword in a case statement.
  #
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    sig { returns(Node) }
    attr_reader :pattern

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :in_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :then_loc

    sig { params(pattern: Node, statements: T.nilable(StatementsNode), in_loc: Location, then_loc: T.nilable(Location), location: Location).void }
    def initialize(pattern, statements, in_loc, then_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def in; end

    sig { returns(T.nilable(String)) }
    def then; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to an instance variable.
  #
  #     @target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableAndWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to an instance variable using an operator that isn't `=`.
  #
  #     @target += value
  #     ^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :operator

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to an instance variable.
  #
  #     @target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOrWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents referencing an instance variable.
  #
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to an instance variable in a context that doesn't have an explicit value.
  #
  #     @foo, @bar = baz
  #     ^^^^  ^^^^
  class InstanceVariableTargetNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to an instance variable.
  #
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InstanceVariableWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an integer number literal.
  #
  #     1
  #     ^
  class IntegerNode < Node
    sig { returns(Integer) }
    attr_reader :flags

    sig { params(flags: Integer, location: Location).void }
    def initialize(flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(IntegerNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T::Boolean) }
    def binary?; end

    sig { returns(T::Boolean) }
    def octal?; end

    sig { returns(T::Boolean) }
    def decimal?; end

    sig { returns(T::Boolean) }
    def hexadecimal?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a regular expression literal that contains interpolation that
  # is being used in the predicate of a conditional to implicitly match
  # against the last line read by an IO object.
  #
  #     if /foo #{bar} baz/ then end
  #        ^^^^^^^^^^^^^^^^
  class InterpolatedMatchLastLineNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :parts

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, flags: Integer, location: Location).void }
    def initialize(opening_loc, parts, closing_loc, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InterpolatedMatchLastLineNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { returns(T::Boolean) }
    def ignore_case?; end

    sig { returns(T::Boolean) }
    def extended?; end

    sig { returns(T::Boolean) }
    def multi_line?; end

    sig { returns(T::Boolean) }
    def euc_jp?; end

    sig { returns(T::Boolean) }
    def ascii_8bit?; end

    sig { returns(T::Boolean) }
    def windows_31j?; end

    sig { returns(T::Boolean) }
    def utf_8?; end

    sig { returns(T::Boolean) }
    def once?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a regular expression literal that contains interpolation.
  #
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :parts

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, flags: Integer, location: Location).void }
    def initialize(opening_loc, parts, closing_loc, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InterpolatedRegularExpressionNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { returns(T::Boolean) }
    def ignore_case?; end

    sig { returns(T::Boolean) }
    def extended?; end

    sig { returns(T::Boolean) }
    def multi_line?; end

    sig { returns(T::Boolean) }
    def euc_jp?; end

    sig { returns(T::Boolean) }
    def ascii_8bit?; end

    sig { returns(T::Boolean) }
    def windows_31j?; end

    sig { returns(T::Boolean) }
    def utf_8?; end

    sig { returns(T::Boolean) }
    def once?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a string literal that contains interpolation.
  #
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :parts

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(opening_loc: T.nilable(Location), parts: T::Array[Node], closing_loc: T.nilable(Location), location: Location).void }
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InterpolatedStringNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a symbol literal that contains interpolation.
  #
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :parts

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { params(opening_loc: T.nilable(Location), parts: T::Array[Node], closing_loc: T.nilable(Location), location: Location).void }
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InterpolatedSymbolNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an xstring literal that contains interpolation.
  #
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[Node]) }
    attr_reader :parts

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, location: Location).void }
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(InterpolatedXStringNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a hash literal without opening and closing braces.
  #
  #     foo(a: b)
  #         ^^^^
  class KeywordHashNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :elements

    sig { params(elements: T::Array[Node], location: Location).void }
    def initialize(elements, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(KeywordHashNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b:)
  #           ^^
  #     end
  #
  #     def a(b: 1)
  #           ^^^^
  #     end
  class KeywordParameterNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(Node)) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, value: T.nilable(Node), location: Location).void }
    def initialize(name, name_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(KeywordParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a keyword rest parameter to a method, block, or lambda definition.
  #
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    sig { returns(T.nilable(Symbol)) }
    attr_reader :name

    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(KeywordRestParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents using a lambda literal (not the lambda method call).
  #
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(T.nilable(BlockParametersNode)) }
    attr_reader :parameters

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { params(locals: T::Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: T.nilable(BlockParametersNode), body: T.nilable(Node), location: Location).void }
    def initialize(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LambdaNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `&&=` operator for assignment to a local variable.
  #
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableAndWriteNode < Node
    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :depth

    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location).void }
    def initialize(name_loc, operator_loc, value, name, depth, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableAndWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents assigning to a local variable using an operator that isn't `=`.
  #
  #     target += value
  #     ^^^^^^^^^^^^^^^
  class LocalVariableOperatorWriteNode < Node
    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Symbol) }
    attr_reader :operator

    sig { returns(Integer) }
    attr_reader :depth

    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location).void }
    def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableOperatorWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||=` operator for assignment to a local variable.
  #
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOrWriteNode < Node
    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :depth

    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location).void }
    def initialize(name_loc, operator_loc, value, name, depth, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableOrWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents reading a local variable. Note that this requires that a local
  # variable of the same name has already been written to in the same scope,
  # otherwise it is parsed as a method call.
  #
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :depth

    sig { params(name: Symbol, depth: Integer, location: Location).void }
    def initialize(name, depth, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a local variable in a context that doesn't have an explicit value.
  #
  #     foo, bar = baz
  #     ^^^  ^^^
  class LocalVariableTargetNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :depth

    sig { params(name: Symbol, depth: Integer, location: Location).void }
    def initialize(name, depth, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing to a local variable.
  #
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :depth

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Node) }
    attr_reader :value

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location).void }
    def initialize(name, depth, name_loc, value, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(LocalVariableWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a regular expression literal used in the predicate of a
  # conditional to implicitly match against the last line read by an IO
  # object.
  #
  #     if /foo/i then end
  #        ^^^^^^
  class MatchLastLineNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :content_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location).void }
    def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MatchLastLineNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(String) }
    def closing; end

    sig { returns(T::Boolean) }
    def ignore_case?; end

    sig { returns(T::Boolean) }
    def extended?; end

    sig { returns(T::Boolean) }
    def multi_line?; end

    sig { returns(T::Boolean) }
    def euc_jp?; end

    sig { returns(T::Boolean) }
    def ascii_8bit?; end

    sig { returns(T::Boolean) }
    def windows_31j?; end

    sig { returns(T::Boolean) }
    def utf_8?; end

    sig { returns(T::Boolean) }
    def once?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the modifier `in` operator.
  #
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    sig { returns(Node) }
    attr_reader :value

    sig { returns(Node) }
    attr_reader :pattern

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(value: Node, pattern: Node, operator_loc: Location, location: Location).void }
    def initialize(value, pattern, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MatchPredicateNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `=>` operator.
  #
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    sig { returns(Node) }
    attr_reader :value

    sig { returns(Node) }
    attr_reader :pattern

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(value: Node, pattern: Node, operator_loc: Location, location: Location).void }
    def initialize(value, pattern, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MatchRequiredNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents writing local variables using a regular expression match with
  # named capture groups.
  #
  #     /(?<foo>bar)/ =~ baz
  #     ^^^^^^^^^^^^^^^^^^^^
  class MatchWriteNode < Node
    sig { returns(CallNode) }
    attr_reader :call

    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { params(call: CallNode, locals: T::Array[Symbol], location: Location).void }
    def initialize(call, locals, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MatchWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a node that is missing from the source and results in a syntax
  # error.
  class MissingNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MissingNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a module declaration involving the `module` keyword.
  #
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(Location) }
    attr_reader :module_keyword_loc

    sig { returns(Node) }
    attr_reader :constant_path

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { returns(Symbol) }
    attr_reader :name

    sig { params(locals: T::Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: T.nilable(Node), end_keyword_loc: Location, name: Symbol, location: Location).void }
    def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ModuleNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def module_keyword; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^
  class MultiTargetNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :targets

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { params(targets: T::Array[Node], lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), location: Location).void }
    def initialize(targets, lparen_loc, rparen_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MultiTargetNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a write to a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :targets

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(targets: T::Array[Node], lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), operator_loc: Location, value: Node, location: Location).void }
    def initialize(targets, lparen_loc, rparen_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(MultiWriteNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `next` keyword.
  #
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(arguments: T.nilable(ArgumentsNode), keyword_loc: Location, location: Location).void }
    def initialize(arguments, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(NextNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `nil` keyword.
  #
  #     nil
  #     ^^^
  class NilNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(NilNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of `**nil` inside method arguments.
  #
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(operator_loc: Location, keyword_loc: Location, location: Location).void }
    def initialize(operator_loc, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(NoKeywordsParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents reading a numbered reference to a capture in the previous match.
  #
  #     $1
  #     ^^
  class NumberedReferenceReadNode < Node
    sig { returns(Integer) }
    attr_reader :number

    sig { params(number: Integer, location: Location).void }
    def initialize(number, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(NumberedReferenceReadNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an optional parameter to a method, block, or lambda definition.
  #
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { returns(Location) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :value

    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).void }
    def initialize(name, name_loc, operator_loc, value, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(OptionalParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `||` operator or the `or` keyword.
  #
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    sig { returns(Node) }
    attr_reader :left

    sig { returns(Node) }
    attr_reader :right

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).void }
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(OrNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the list of parameters on a method, block, or lambda definition.
  #
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :requireds

    sig { returns(T::Array[Node]) }
    attr_reader :optionals

    sig { returns(T.nilable(RestParameterNode)) }
    attr_reader :rest

    sig { returns(T::Array[Node]) }
    attr_reader :posts

    sig { returns(T::Array[Node]) }
    attr_reader :keywords

    sig { returns(T.nilable(Node)) }
    attr_reader :keyword_rest

    sig { returns(T.nilable(BlockParameterNode)) }
    attr_reader :block

    sig { params(requireds: T::Array[Node], optionals: T::Array[Node], rest: T.nilable(RestParameterNode), posts: T::Array[Node], keywords: T::Array[Node], keyword_rest: T.nilable(Node), block: T.nilable(BlockParameterNode), location: Location).void }
    def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ParametersNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a parenthesized expression
  #
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(body: T.nilable(Node), opening_loc: Location, closing_loc: Location, location: Location).void }
    def initialize(body, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ParenthesesNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `^` operator for pinning an expression in a
  # pattern matching expression.
  #
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    sig { returns(Node) }
    attr_reader :expression

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Location) }
    attr_reader :lparen_loc

    sig { returns(Location) }
    attr_reader :rparen_loc

    sig { params(expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location).void }
    def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(PinnedExpressionNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def lparen; end

    sig { returns(String) }
    def rparen; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `^` operator for pinning a variable in a pattern
  # matching expression.
  #
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    sig { returns(Node) }
    attr_reader :variable

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(variable: Node, operator_loc: Location, location: Location).void }
    def initialize(variable, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(PinnedVariableNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `END` keyword.
  #
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(statements: T.nilable(StatementsNode), keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location).void }
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(PostExecutionNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `BEGIN` keyword.
  #
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(statements: T.nilable(StatementsNode), keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location).void }
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(PreExecutionNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # The top level node of any parse tree.
  class ProgramNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(StatementsNode) }
    attr_reader :statements

    sig { params(locals: T::Array[Symbol], statements: StatementsNode, location: Location).void }
    def initialize(locals, statements, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ProgramNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `..` or `...` operators.
  #
  #     1..2
  #     ^^^^
  #
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    sig { returns(T.nilable(Node)) }
    attr_reader :left

    sig { returns(T.nilable(Node)) }
    attr_reader :right

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(left: T.nilable(Node), right: T.nilable(Node), operator_loc: Location, flags: Integer, location: Location).void }
    def initialize(left, right, operator_loc, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RangeNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(T::Boolean) }
    def exclude_end?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a rational number literal.
  #
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    sig { returns(Node) }
    attr_reader :numeric

    sig { params(numeric: Node, location: Location).void }
    def initialize(numeric, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RationalNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `redo` keyword.
  #
  #     redo
  #     ^^^^
  class RedoNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RedoNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a regular expression literal with no interpolation.
  #
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :content_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location).void }
    def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RegularExpressionNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(String) }
    def closing; end

    sig { returns(T::Boolean) }
    def ignore_case?; end

    sig { returns(T::Boolean) }
    def extended?; end

    sig { returns(T::Boolean) }
    def multi_line?; end

    sig { returns(T::Boolean) }
    def euc_jp?; end

    sig { returns(T::Boolean) }
    def ascii_8bit?; end

    sig { returns(T::Boolean) }
    def windows_31j?; end

    sig { returns(T::Boolean) }
    def utf_8?; end

    sig { returns(T::Boolean) }
    def once?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a destructured required parameter node.
  #
  #     def foo((bar, baz))
  #             ^^^^^^^^^^
  #     end
  class RequiredDestructuredParameterNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :parameters

    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { params(parameters: T::Array[Node], opening_loc: Location, closing_loc: Location, location: Location).void }
    def initialize(parameters, opening_loc, closing_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RequiredDestructuredParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a required parameter to a method, block, or lambda definition.
  #
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    sig { returns(Symbol) }
    attr_reader :name

    sig { params(name: Symbol, location: Location).void }
    def initialize(name, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RequiredParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an expression modified with a rescue.
  #
  #   foo rescue nil
  #   ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    sig { returns(Node) }
    attr_reader :expression

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(Node) }
    attr_reader :rescue_expression

    sig { params(expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location).void }
    def initialize(expression, keyword_loc, rescue_expression, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RescueModifierNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a rescue statement.
  #
  #     begin
  #     rescue Foo, *splat, Bar => ex
  #     ^^^^^^
  #       foo
  #     end
  #
  # `Foo, *splat, Bar` are in the `exceptions` field.
  # `ex` is in the `exception` field.
  class RescueNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T::Array[Node]) }
    attr_reader :exceptions

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Node)) }
    attr_reader :reference

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(T.nilable(RescueNode)) }
    attr_reader :consequent

    sig { params(keyword_loc: Location, exceptions: T::Array[Node], operator_loc: T.nilable(Location), reference: T.nilable(Node), statements: T.nilable(StatementsNode), consequent: T.nilable(RescueNode), location: Location).void }
    def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RescueNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a rest parameter to a method, block, or lambda definition.
  #
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    sig { returns(T.nilable(Symbol)) }
    attr_reader :name

    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).void }
    def initialize(name, name_loc, operator_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RestParameterNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `retry` keyword.
  #
  #     retry
  #     ^^^^^
  class RetryNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(RetryNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `return` keyword.
  #
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { params(keyword_loc: Location, arguments: T.nilable(ArgumentsNode), location: Location).void }
    def initialize(keyword_loc, arguments, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(ReturnNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the `self` keyword.
  #
  #     self
  #     ^^^^
  class SelfNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SelfNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a singleton class declaration involving the `class` keyword.
  #
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    sig { returns(T::Array[Symbol]) }
    attr_reader :locals

    sig { returns(Location) }
    attr_reader :class_keyword_loc

    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(Node) }
    attr_reader :expression

    sig { returns(T.nilable(Node)) }
    attr_reader :body

    sig { returns(Location) }
    attr_reader :end_keyword_loc

    sig { params(locals: T::Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: T.nilable(Node), end_keyword_loc: Location, location: Location).void }
    def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SingletonClassNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def class_keyword; end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `__ENCODING__` keyword.
  #
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SourceEncodingNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `__FILE__` keyword.
  #
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    sig { returns(String) }
    attr_reader :filepath

    sig { params(filepath: String, location: Location).void }
    def initialize(filepath, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SourceFileNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `__LINE__` keyword.
  #
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SourceLineNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the splat operator.
  #
  #     [*a]
  #      ^^
  class SplatNode < Node
    sig { returns(Location) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Node)) }
    attr_reader :expression

    sig { params(operator_loc: Location, expression: T.nilable(Node), location: Location).void }
    def initialize(operator_loc, expression, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SplatNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a set of statements contained within some scope.
  #
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :body

    sig { params(body: T::Array[Node], location: Location).void }
    def initialize(body, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(StatementsNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of compile-time string concatenation.
  #
  #     "foo" "bar"
  #     ^^^^^^^^^^^
  class StringConcatNode < Node
    sig { returns(Node) }
    attr_reader :left

    sig { returns(Node) }
    attr_reader :right

    sig { params(left: Node, right: Node, location: Location).void }
    def initialize(left, right, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(StringConcatNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a string literal, a string contained within a `%w` list, or
  # plain string content within an interpolated string.
  #
  #     "foo"
  #     ^^^^^
  #
  #     %w[foo]
  #        ^^^
  #
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :content_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { params(flags: Integer, opening_loc: T.nilable(Location), content_loc: Location, closing_loc: T.nilable(Location), unescaped: String, location: Location).void }
    def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(StringNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T::Boolean) }
    def frozen?; end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `super` keyword with parentheses or arguments.
  #
  #     super()
  #     ^^^^^^^
  #
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  class SuperNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(T.nilable(BlockNode)) }
    attr_reader :block

    sig { params(keyword_loc: Location, lparen_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), rparen_loc: T.nilable(Location), block: T.nilable(BlockNode), location: Location).void }
    def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SuperNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents a symbol literal or a symbol contained within a `%i` list.
  #
  #     :foo
  #     ^^^^
  #
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :value_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { params(opening_loc: T.nilable(Location), value_loc: T.nilable(Location), closing_loc: T.nilable(Location), unescaped: String, location: Location).void }
    def initialize(opening_loc, value_loc, closing_loc, unescaped, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(SymbolNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String)) }
    def opening; end

    sig { returns(T.nilable(String)) }
    def value; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the literal `true` keyword.
  #
  #     true
  #     ^^^^
  class TrueNode < Node
    sig { params(location: Location).void }
    def initialize(location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(TrueNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `undef` keyword.
  #
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    sig { returns(T::Array[Node]) }
    attr_reader :names

    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { params(names: T::Array[Node], keyword_loc: Location, location: Location).void }
    def initialize(names, keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(UndefNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  #
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  #
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(Node) }
    attr_reader :predicate

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(T.nilable(ElseNode)) }
    attr_reader :consequent

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig { params(keyword_loc: Location, predicate: Node, statements: T.nilable(StatementsNode), consequent: T.nilable(ElseNode), end_keyword_loc: T.nilable(Location), location: Location).void }
    def initialize(keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(UnlessNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def end_keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  #
  #     bar until foo
  #     ^^^^^^^^^^^^^
  #
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(Node) }
    attr_reader :predicate

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(keyword_loc: Location, closing_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), flags: Integer, location: Location).void }
    def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(UntilNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def begin_modifier?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `when` keyword within a case statement.
  #
  #     case true
  #     when true
  #     ^^^^^^^^^
  #     end
  class WhenNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T::Array[Node]) }
    attr_reader :conditions

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { params(keyword_loc: Location, conditions: T::Array[Node], statements: T.nilable(StatementsNode), location: Location).void }
    def initialize(keyword_loc, conditions, statements, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(WhenNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  #
  #     bar while foo
  #     ^^^^^^^^^^^^^
  #
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(Node) }
    attr_reader :predicate

    sig { returns(T.nilable(StatementsNode)) }
    attr_reader :statements

    sig { returns(Integer) }
    attr_reader :flags

    sig { params(keyword_loc: Location, closing_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), flags: Integer, location: Location).void }
    def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    def set_newline_flag(newline_marked); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(WhileNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def closing; end

    sig { returns(T::Boolean) }
    def begin_modifier?; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents an xstring literal with no interpolation.
  #
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    sig { returns(Location) }
    attr_reader :opening_loc

    sig { returns(Location) }
    attr_reader :content_loc

    sig { returns(Location) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location).void }
    def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(XStringNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(String) }
    def closing; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  # Represents the use of the `yield` keyword.
  #
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    sig { returns(Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(ArgumentsNode)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { params(keyword_loc: Location, lparen_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), rparen_loc: T.nilable(Location), location: Location).void }
    def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(YieldNode) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String)) }
    def lparen; end

    sig { returns(T.nilable(String)) }
    def rparen; end

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  module CallNodeFlags
    # &. operator
    SAFE_NAVIGATION = 1 << 0

    # a call that could have been a local variable
    VARIABLE_CALL = 1 << 1
          end

  module IntegerBaseFlags
    # 0b prefix
    BINARY = 1 << 0

    # 0o or 0 prefix
    OCTAL = 1 << 1

    # 0d or no prefix
    DECIMAL = 1 << 2

    # 0x prefix
    HEXADECIMAL = 1 << 3
          end

  module LoopFlags
    # a loop after a begin statement, so the body is executed first before the condition
    BEGIN_MODIFIER = 1 << 0
          end

  module RangeFlags
    # ... operator
    EXCLUDE_END = 1 << 0
          end

  module RegularExpressionFlags
    # i - ignores the case of characters when matching
    IGNORE_CASE = 1 << 0

    # x - ignores whitespace and allows comments in regular expressions
    EXTENDED = 1 << 1

    # m - allows $ to match the end of lines within strings
    MULTI_LINE = 1 << 2

    # e - forces the EUC-JP encoding
    EUC_JP = 1 << 3

    # n - forces the ASCII-8BIT encoding
    ASCII_8BIT = 1 << 4

    # s - forces the Windows-31J encoding
    WINDOWS_31J = 1 << 5

    # u - forces the UTF-8 encoding
    UTF_8 = 1 << 6

    # o - only interpolates values into the regular expression once
    ONCE = 1 << 7
          end

  module StringFlags
    # frozen by virtue of a frozen_string_literal comment
    FROZEN = 1 << 0
          end

  class Visitor < BasicVisitor
    # Visit a AliasGlobalVariableNode node
    sig { params(node: AliasGlobalVariableNode).void }
    def visit_alias_global_variable_node(node); end

    # Visit a AliasMethodNode node
    sig { params(node: AliasMethodNode).void }
    def visit_alias_method_node(node); end

    # Visit a AlternationPatternNode node
    sig { params(node: AlternationPatternNode).void }
    def visit_alternation_pattern_node(node); end

    # Visit a AndNode node
    sig { params(node: AndNode).void }
    def visit_and_node(node); end

    # Visit a ArgumentsNode node
    sig { params(node: ArgumentsNode).void }
    def visit_arguments_node(node); end

    # Visit a ArrayNode node
    sig { params(node: ArrayNode).void }
    def visit_array_node(node); end

    # Visit a ArrayPatternNode node
    sig { params(node: ArrayPatternNode).void }
    def visit_array_pattern_node(node); end

    # Visit a AssocNode node
    sig { params(node: AssocNode).void }
    def visit_assoc_node(node); end

    # Visit a AssocSplatNode node
    sig { params(node: AssocSplatNode).void }
    def visit_assoc_splat_node(node); end

    # Visit a BackReferenceReadNode node
    sig { params(node: BackReferenceReadNode).void }
    def visit_back_reference_read_node(node); end

    # Visit a BeginNode node
    sig { params(node: BeginNode).void }
    def visit_begin_node(node); end

    # Visit a BlockArgumentNode node
    sig { params(node: BlockArgumentNode).void }
    def visit_block_argument_node(node); end

    # Visit a BlockLocalVariableNode node
    sig { params(node: BlockLocalVariableNode).void }
    def visit_block_local_variable_node(node); end

    # Visit a BlockNode node
    sig { params(node: BlockNode).void }
    def visit_block_node(node); end

    # Visit a BlockParameterNode node
    sig { params(node: BlockParameterNode).void }
    def visit_block_parameter_node(node); end

    # Visit a BlockParametersNode node
    sig { params(node: BlockParametersNode).void }
    def visit_block_parameters_node(node); end

    # Visit a BreakNode node
    sig { params(node: BreakNode).void }
    def visit_break_node(node); end

    # Visit a CallAndWriteNode node
    sig { params(node: CallAndWriteNode).void }
    def visit_call_and_write_node(node); end

    # Visit a CallNode node
    sig { params(node: CallNode).void }
    def visit_call_node(node); end

    # Visit a CallOperatorWriteNode node
    sig { params(node: CallOperatorWriteNode).void }
    def visit_call_operator_write_node(node); end

    # Visit a CallOrWriteNode node
    sig { params(node: CallOrWriteNode).void }
    def visit_call_or_write_node(node); end

    # Visit a CapturePatternNode node
    sig { params(node: CapturePatternNode).void }
    def visit_capture_pattern_node(node); end

    # Visit a CaseNode node
    sig { params(node: CaseNode).void }
    def visit_case_node(node); end

    # Visit a ClassNode node
    sig { params(node: ClassNode).void }
    def visit_class_node(node); end

    # Visit a ClassVariableAndWriteNode node
    sig { params(node: ClassVariableAndWriteNode).void }
    def visit_class_variable_and_write_node(node); end

    # Visit a ClassVariableOperatorWriteNode node
    sig { params(node: ClassVariableOperatorWriteNode).void }
    def visit_class_variable_operator_write_node(node); end

    # Visit a ClassVariableOrWriteNode node
    sig { params(node: ClassVariableOrWriteNode).void }
    def visit_class_variable_or_write_node(node); end

    # Visit a ClassVariableReadNode node
    sig { params(node: ClassVariableReadNode).void }
    def visit_class_variable_read_node(node); end

    # Visit a ClassVariableTargetNode node
    sig { params(node: ClassVariableTargetNode).void }
    def visit_class_variable_target_node(node); end

    # Visit a ClassVariableWriteNode node
    sig { params(node: ClassVariableWriteNode).void }
    def visit_class_variable_write_node(node); end

    # Visit a ConstantAndWriteNode node
    sig { params(node: ConstantAndWriteNode).void }
    def visit_constant_and_write_node(node); end

    # Visit a ConstantOperatorWriteNode node
    sig { params(node: ConstantOperatorWriteNode).void }
    def visit_constant_operator_write_node(node); end

    # Visit a ConstantOrWriteNode node
    sig { params(node: ConstantOrWriteNode).void }
    def visit_constant_or_write_node(node); end

    # Visit a ConstantPathAndWriteNode node
    sig { params(node: ConstantPathAndWriteNode).void }
    def visit_constant_path_and_write_node(node); end

    # Visit a ConstantPathNode node
    sig { params(node: ConstantPathNode).void }
    def visit_constant_path_node(node); end

    # Visit a ConstantPathOperatorWriteNode node
    sig { params(node: ConstantPathOperatorWriteNode).void }
    def visit_constant_path_operator_write_node(node); end

    # Visit a ConstantPathOrWriteNode node
    sig { params(node: ConstantPathOrWriteNode).void }
    def visit_constant_path_or_write_node(node); end

    # Visit a ConstantPathTargetNode node
    sig { params(node: ConstantPathTargetNode).void }
    def visit_constant_path_target_node(node); end

    # Visit a ConstantPathWriteNode node
    sig { params(node: ConstantPathWriteNode).void }
    def visit_constant_path_write_node(node); end

    # Visit a ConstantReadNode node
    sig { params(node: ConstantReadNode).void }
    def visit_constant_read_node(node); end

    # Visit a ConstantTargetNode node
    sig { params(node: ConstantTargetNode).void }
    def visit_constant_target_node(node); end

    # Visit a ConstantWriteNode node
    sig { params(node: ConstantWriteNode).void }
    def visit_constant_write_node(node); end

    # Visit a DefNode node
    sig { params(node: DefNode).void }
    def visit_def_node(node); end

    # Visit a DefinedNode node
    sig { params(node: DefinedNode).void }
    def visit_defined_node(node); end

    # Visit a ElseNode node
    sig { params(node: ElseNode).void }
    def visit_else_node(node); end

    # Visit a EmbeddedStatementsNode node
    sig { params(node: EmbeddedStatementsNode).void }
    def visit_embedded_statements_node(node); end

    # Visit a EmbeddedVariableNode node
    sig { params(node: EmbeddedVariableNode).void }
    def visit_embedded_variable_node(node); end

    # Visit a EnsureNode node
    sig { params(node: EnsureNode).void }
    def visit_ensure_node(node); end

    # Visit a FalseNode node
    sig { params(node: FalseNode).void }
    def visit_false_node(node); end

    # Visit a FindPatternNode node
    sig { params(node: FindPatternNode).void }
    def visit_find_pattern_node(node); end

    # Visit a FlipFlopNode node
    sig { params(node: FlipFlopNode).void }
    def visit_flip_flop_node(node); end

    # Visit a FloatNode node
    sig { params(node: FloatNode).void }
    def visit_float_node(node); end

    # Visit a ForNode node
    sig { params(node: ForNode).void }
    def visit_for_node(node); end

    # Visit a ForwardingArgumentsNode node
    sig { params(node: ForwardingArgumentsNode).void }
    def visit_forwarding_arguments_node(node); end

    # Visit a ForwardingParameterNode node
    sig { params(node: ForwardingParameterNode).void }
    def visit_forwarding_parameter_node(node); end

    # Visit a ForwardingSuperNode node
    sig { params(node: ForwardingSuperNode).void }
    def visit_forwarding_super_node(node); end

    # Visit a GlobalVariableAndWriteNode node
    sig { params(node: GlobalVariableAndWriteNode).void }
    def visit_global_variable_and_write_node(node); end

    # Visit a GlobalVariableOperatorWriteNode node
    sig { params(node: GlobalVariableOperatorWriteNode).void }
    def visit_global_variable_operator_write_node(node); end

    # Visit a GlobalVariableOrWriteNode node
    sig { params(node: GlobalVariableOrWriteNode).void }
    def visit_global_variable_or_write_node(node); end

    # Visit a GlobalVariableReadNode node
    sig { params(node: GlobalVariableReadNode).void }
    def visit_global_variable_read_node(node); end

    # Visit a GlobalVariableTargetNode node
    sig { params(node: GlobalVariableTargetNode).void }
    def visit_global_variable_target_node(node); end

    # Visit a GlobalVariableWriteNode node
    sig { params(node: GlobalVariableWriteNode).void }
    def visit_global_variable_write_node(node); end

    # Visit a HashNode node
    sig { params(node: HashNode).void }
    def visit_hash_node(node); end

    # Visit a HashPatternNode node
    sig { params(node: HashPatternNode).void }
    def visit_hash_pattern_node(node); end

    # Visit a IfNode node
    sig { params(node: IfNode).void }
    def visit_if_node(node); end

    # Visit a ImaginaryNode node
    sig { params(node: ImaginaryNode).void }
    def visit_imaginary_node(node); end

    # Visit a ImplicitNode node
    sig { params(node: ImplicitNode).void }
    def visit_implicit_node(node); end

    # Visit a InNode node
    sig { params(node: InNode).void }
    def visit_in_node(node); end

    # Visit a InstanceVariableAndWriteNode node
    sig { params(node: InstanceVariableAndWriteNode).void }
    def visit_instance_variable_and_write_node(node); end

    # Visit a InstanceVariableOperatorWriteNode node
    sig { params(node: InstanceVariableOperatorWriteNode).void }
    def visit_instance_variable_operator_write_node(node); end

    # Visit a InstanceVariableOrWriteNode node
    sig { params(node: InstanceVariableOrWriteNode).void }
    def visit_instance_variable_or_write_node(node); end

    # Visit a InstanceVariableReadNode node
    sig { params(node: InstanceVariableReadNode).void }
    def visit_instance_variable_read_node(node); end

    # Visit a InstanceVariableTargetNode node
    sig { params(node: InstanceVariableTargetNode).void }
    def visit_instance_variable_target_node(node); end

    # Visit a InstanceVariableWriteNode node
    sig { params(node: InstanceVariableWriteNode).void }
    def visit_instance_variable_write_node(node); end

    # Visit a IntegerNode node
    sig { params(node: IntegerNode).void }
    def visit_integer_node(node); end

    # Visit a InterpolatedMatchLastLineNode node
    sig { params(node: InterpolatedMatchLastLineNode).void }
    def visit_interpolated_match_last_line_node(node); end

    # Visit a InterpolatedRegularExpressionNode node
    sig { params(node: InterpolatedRegularExpressionNode).void }
    def visit_interpolated_regular_expression_node(node); end

    # Visit a InterpolatedStringNode node
    sig { params(node: InterpolatedStringNode).void }
    def visit_interpolated_string_node(node); end

    # Visit a InterpolatedSymbolNode node
    sig { params(node: InterpolatedSymbolNode).void }
    def visit_interpolated_symbol_node(node); end

    # Visit a InterpolatedXStringNode node
    sig { params(node: InterpolatedXStringNode).void }
    def visit_interpolated_x_string_node(node); end

    # Visit a KeywordHashNode node
    sig { params(node: KeywordHashNode).void }
    def visit_keyword_hash_node(node); end

    # Visit a KeywordParameterNode node
    sig { params(node: KeywordParameterNode).void }
    def visit_keyword_parameter_node(node); end

    # Visit a KeywordRestParameterNode node
    sig { params(node: KeywordRestParameterNode).void }
    def visit_keyword_rest_parameter_node(node); end

    # Visit a LambdaNode node
    sig { params(node: LambdaNode).void }
    def visit_lambda_node(node); end

    # Visit a LocalVariableAndWriteNode node
    sig { params(node: LocalVariableAndWriteNode).void }
    def visit_local_variable_and_write_node(node); end

    # Visit a LocalVariableOperatorWriteNode node
    sig { params(node: LocalVariableOperatorWriteNode).void }
    def visit_local_variable_operator_write_node(node); end

    # Visit a LocalVariableOrWriteNode node
    sig { params(node: LocalVariableOrWriteNode).void }
    def visit_local_variable_or_write_node(node); end

    # Visit a LocalVariableReadNode node
    sig { params(node: LocalVariableReadNode).void }
    def visit_local_variable_read_node(node); end

    # Visit a LocalVariableTargetNode node
    sig { params(node: LocalVariableTargetNode).void }
    def visit_local_variable_target_node(node); end

    # Visit a LocalVariableWriteNode node
    sig { params(node: LocalVariableWriteNode).void }
    def visit_local_variable_write_node(node); end

    # Visit a MatchLastLineNode node
    sig { params(node: MatchLastLineNode).void }
    def visit_match_last_line_node(node); end

    # Visit a MatchPredicateNode node
    sig { params(node: MatchPredicateNode).void }
    def visit_match_predicate_node(node); end

    # Visit a MatchRequiredNode node
    sig { params(node: MatchRequiredNode).void }
    def visit_match_required_node(node); end

    # Visit a MatchWriteNode node
    sig { params(node: MatchWriteNode).void }
    def visit_match_write_node(node); end

    # Visit a MissingNode node
    sig { params(node: MissingNode).void }
    def visit_missing_node(node); end

    # Visit a ModuleNode node
    sig { params(node: ModuleNode).void }
    def visit_module_node(node); end

    # Visit a MultiTargetNode node
    sig { params(node: MultiTargetNode).void }
    def visit_multi_target_node(node); end

    # Visit a MultiWriteNode node
    sig { params(node: MultiWriteNode).void }
    def visit_multi_write_node(node); end

    # Visit a NextNode node
    sig { params(node: NextNode).void }
    def visit_next_node(node); end

    # Visit a NilNode node
    sig { params(node: NilNode).void }
    def visit_nil_node(node); end

    # Visit a NoKeywordsParameterNode node
    sig { params(node: NoKeywordsParameterNode).void }
    def visit_no_keywords_parameter_node(node); end

    # Visit a NumberedReferenceReadNode node
    sig { params(node: NumberedReferenceReadNode).void }
    def visit_numbered_reference_read_node(node); end

    # Visit a OptionalParameterNode node
    sig { params(node: OptionalParameterNode).void }
    def visit_optional_parameter_node(node); end

    # Visit a OrNode node
    sig { params(node: OrNode).void }
    def visit_or_node(node); end

    # Visit a ParametersNode node
    sig { params(node: ParametersNode).void }
    def visit_parameters_node(node); end

    # Visit a ParenthesesNode node
    sig { params(node: ParenthesesNode).void }
    def visit_parentheses_node(node); end

    # Visit a PinnedExpressionNode node
    sig { params(node: PinnedExpressionNode).void }
    def visit_pinned_expression_node(node); end

    # Visit a PinnedVariableNode node
    sig { params(node: PinnedVariableNode).void }
    def visit_pinned_variable_node(node); end

    # Visit a PostExecutionNode node
    sig { params(node: PostExecutionNode).void }
    def visit_post_execution_node(node); end

    # Visit a PreExecutionNode node
    sig { params(node: PreExecutionNode).void }
    def visit_pre_execution_node(node); end

    # Visit a ProgramNode node
    sig { params(node: ProgramNode).void }
    def visit_program_node(node); end

    # Visit a RangeNode node
    sig { params(node: RangeNode).void }
    def visit_range_node(node); end

    # Visit a RationalNode node
    sig { params(node: RationalNode).void }
    def visit_rational_node(node); end

    # Visit a RedoNode node
    sig { params(node: RedoNode).void }
    def visit_redo_node(node); end

    # Visit a RegularExpressionNode node
    sig { params(node: RegularExpressionNode).void }
    def visit_regular_expression_node(node); end

    # Visit a RequiredDestructuredParameterNode node
    sig { params(node: RequiredDestructuredParameterNode).void }
    def visit_required_destructured_parameter_node(node); end

    # Visit a RequiredParameterNode node
    sig { params(node: RequiredParameterNode).void }
    def visit_required_parameter_node(node); end

    # Visit a RescueModifierNode node
    sig { params(node: RescueModifierNode).void }
    def visit_rescue_modifier_node(node); end

    # Visit a RescueNode node
    sig { params(node: RescueNode).void }
    def visit_rescue_node(node); end

    # Visit a RestParameterNode node
    sig { params(node: RestParameterNode).void }
    def visit_rest_parameter_node(node); end

    # Visit a RetryNode node
    sig { params(node: RetryNode).void }
    def visit_retry_node(node); end

    # Visit a ReturnNode node
    sig { params(node: ReturnNode).void }
    def visit_return_node(node); end

    # Visit a SelfNode node
    sig { params(node: SelfNode).void }
    def visit_self_node(node); end

    # Visit a SingletonClassNode node
    sig { params(node: SingletonClassNode).void }
    def visit_singleton_class_node(node); end

    # Visit a SourceEncodingNode node
    sig { params(node: SourceEncodingNode).void }
    def visit_source_encoding_node(node); end

    # Visit a SourceFileNode node
    sig { params(node: SourceFileNode).void }
    def visit_source_file_node(node); end

    # Visit a SourceLineNode node
    sig { params(node: SourceLineNode).void }
    def visit_source_line_node(node); end

    # Visit a SplatNode node
    sig { params(node: SplatNode).void }
    def visit_splat_node(node); end

    # Visit a StatementsNode node
    sig { params(node: StatementsNode).void }
    def visit_statements_node(node); end

    # Visit a StringConcatNode node
    sig { params(node: StringConcatNode).void }
    def visit_string_concat_node(node); end

    # Visit a StringNode node
    sig { params(node: StringNode).void }
    def visit_string_node(node); end

    # Visit a SuperNode node
    sig { params(node: SuperNode).void }
    def visit_super_node(node); end

    # Visit a SymbolNode node
    sig { params(node: SymbolNode).void }
    def visit_symbol_node(node); end

    # Visit a TrueNode node
    sig { params(node: TrueNode).void }
    def visit_true_node(node); end

    # Visit a UndefNode node
    sig { params(node: UndefNode).void }
    def visit_undef_node(node); end

    # Visit a UnlessNode node
    sig { params(node: UnlessNode).void }
    def visit_unless_node(node); end

    # Visit a UntilNode node
    sig { params(node: UntilNode).void }
    def visit_until_node(node); end

    # Visit a WhenNode node
    sig { params(node: WhenNode).void }
    def visit_when_node(node); end

    # Visit a WhileNode node
    sig { params(node: WhileNode).void }
    def visit_while_node(node); end

    # Visit a XStringNode node
    sig { params(node: XStringNode).void }
    def visit_x_string_node(node); end

    # Visit a YieldNode node
    sig { params(node: YieldNode).void }
    def visit_yield_node(node); end
        end

  module DSL
    private

    # Create a new Location object
    sig { params(source: T.nilable(Source), start_offset: Integer, length: Integer).returns(Location) }
    def Location(source, start_offset, length); end

    # Create a new AliasGlobalVariableNode node
    sig { params(new_name: Node, old_name: Node, keyword_loc: Location, location: Location).returns(AliasGlobalVariableNode) }
    def AliasGlobalVariableNode(new_name, old_name, keyword_loc, location); end
    # Create a new AliasMethodNode node
    sig { params(new_name: Node, old_name: Node, keyword_loc: Location, location: Location).returns(AliasMethodNode) }
    def AliasMethodNode(new_name, old_name, keyword_loc, location); end
    # Create a new AlternationPatternNode node
    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).returns(AlternationPatternNode) }
    def AlternationPatternNode(left, right, operator_loc, location); end
    # Create a new AndNode node
    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).returns(AndNode) }
    def AndNode(left, right, operator_loc, location); end
    # Create a new ArgumentsNode node
    sig { params(arguments: T::Array[Node], location: Location).returns(ArgumentsNode) }
    def ArgumentsNode(arguments, location); end
    # Create a new ArrayNode node
    sig { params(elements: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).returns(ArrayNode) }
    def ArrayNode(elements, opening_loc, closing_loc, location); end
    # Create a new ArrayPatternNode node
    sig { params(constant: T.nilable(Node), requireds: T::Array[Node], rest: T.nilable(Node), posts: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).returns(ArrayPatternNode) }
    def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, location); end
    # Create a new AssocNode node
    sig { params(key: Node, value: T.nilable(Node), operator_loc: T.nilable(Location), location: Location).returns(AssocNode) }
    def AssocNode(key, value, operator_loc, location); end
    # Create a new AssocSplatNode node
    sig { params(value: T.nilable(Node), operator_loc: Location, location: Location).returns(AssocSplatNode) }
    def AssocSplatNode(value, operator_loc, location); end
    # Create a new BackReferenceReadNode node
    sig { params(location: Location).returns(BackReferenceReadNode) }
    def BackReferenceReadNode(location); end
    # Create a new BeginNode node
    sig { params(begin_keyword_loc: T.nilable(Location), statements: T.nilable(StatementsNode), rescue_clause: T.nilable(RescueNode), else_clause: T.nilable(ElseNode), ensure_clause: T.nilable(EnsureNode), end_keyword_loc: T.nilable(Location), location: Location).returns(BeginNode) }
    def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end
    # Create a new BlockArgumentNode node
    sig { params(expression: T.nilable(Node), operator_loc: Location, location: Location).returns(BlockArgumentNode) }
    def BlockArgumentNode(expression, operator_loc, location); end
    # Create a new BlockLocalVariableNode node
    sig { params(name: Symbol, location: Location).returns(BlockLocalVariableNode) }
    def BlockLocalVariableNode(name, location); end
    # Create a new BlockNode node
    sig { params(locals: T::Array[Symbol], parameters: T.nilable(BlockParametersNode), body: T.nilable(Node), opening_loc: Location, closing_loc: Location, location: Location).returns(BlockNode) }
    def BlockNode(locals, parameters, body, opening_loc, closing_loc, location); end
    # Create a new BlockParameterNode node
    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).returns(BlockParameterNode) }
    def BlockParameterNode(name, name_loc, operator_loc, location); end
    # Create a new BlockParametersNode node
    sig { params(parameters: T.nilable(ParametersNode), locals: T::Array[Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).returns(BlockParametersNode) }
    def BlockParametersNode(parameters, locals, opening_loc, closing_loc, location); end
    # Create a new BreakNode node
    sig { params(arguments: T.nilable(ArgumentsNode), keyword_loc: Location, location: Location).returns(BreakNode) }
    def BreakNode(arguments, keyword_loc, location); end
    # Create a new CallAndWriteNode node
    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location).returns(CallAndWriteNode) }
    def CallAndWriteNode(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator_loc, value, location); end
    # Create a new CallNode node
    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), block: T.nilable(BlockNode), flags: Integer, name: String, location: Location).returns(CallNode) }
    def CallNode(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end
    # Create a new CallOperatorWriteNode node
    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator: Symbol, operator_loc: Location, value: Node, location: Location).returns(CallOperatorWriteNode) }
    def CallOperatorWriteNode(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator, operator_loc, value, location); end
    # Create a new CallOrWriteNode node
    sig { params(receiver: T.nilable(Node), call_operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), closing_loc: T.nilable(Location), flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location).returns(CallOrWriteNode) }
    def CallOrWriteNode(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, flags, read_name, write_name, operator_loc, value, location); end
    # Create a new CapturePatternNode node
    sig { params(value: Node, target: Node, operator_loc: Location, location: Location).returns(CapturePatternNode) }
    def CapturePatternNode(value, target, operator_loc, location); end
    # Create a new CaseNode node
    sig { params(predicate: T.nilable(Node), conditions: T::Array[Node], consequent: T.nilable(ElseNode), case_keyword_loc: Location, end_keyword_loc: Location, location: Location).returns(CaseNode) }
    def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end
    # Create a new ClassNode node
    sig { params(locals: T::Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: T.nilable(Location), superclass: T.nilable(Node), body: T.nilable(Node), end_keyword_loc: Location, name: Symbol, location: Location).returns(ClassNode) }
    def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end
    # Create a new ClassVariableAndWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(ClassVariableAndWriteNode) }
    def ClassVariableAndWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new ClassVariableOperatorWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).returns(ClassVariableOperatorWriteNode) }
    def ClassVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end
    # Create a new ClassVariableOrWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(ClassVariableOrWriteNode) }
    def ClassVariableOrWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new ClassVariableReadNode node
    sig { params(name: Symbol, location: Location).returns(ClassVariableReadNode) }
    def ClassVariableReadNode(name, location); end
    # Create a new ClassVariableTargetNode node
    sig { params(name: Symbol, location: Location).returns(ClassVariableTargetNode) }
    def ClassVariableTargetNode(name, location); end
    # Create a new ClassVariableWriteNode node
    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: T.nilable(Location), location: Location).returns(ClassVariableWriteNode) }
    def ClassVariableWriteNode(name, name_loc, value, operator_loc, location); end
    # Create a new ConstantAndWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(ConstantAndWriteNode) }
    def ConstantAndWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new ConstantOperatorWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).returns(ConstantOperatorWriteNode) }
    def ConstantOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end
    # Create a new ConstantOrWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(ConstantOrWriteNode) }
    def ConstantOrWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new ConstantPathAndWriteNode node
    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).returns(ConstantPathAndWriteNode) }
    def ConstantPathAndWriteNode(target, operator_loc, value, location); end
    # Create a new ConstantPathNode node
    sig { params(parent: T.nilable(Node), child: Node, delimiter_loc: Location, location: Location).returns(ConstantPathNode) }
    def ConstantPathNode(parent, child, delimiter_loc, location); end
    # Create a new ConstantPathOperatorWriteNode node
    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location).returns(ConstantPathOperatorWriteNode) }
    def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, location); end
    # Create a new ConstantPathOrWriteNode node
    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).returns(ConstantPathOrWriteNode) }
    def ConstantPathOrWriteNode(target, operator_loc, value, location); end
    # Create a new ConstantPathTargetNode node
    sig { params(parent: T.nilable(Node), child: Node, delimiter_loc: Location, location: Location).returns(ConstantPathTargetNode) }
    def ConstantPathTargetNode(parent, child, delimiter_loc, location); end
    # Create a new ConstantPathWriteNode node
    sig { params(target: ConstantPathNode, operator_loc: Location, value: Node, location: Location).returns(ConstantPathWriteNode) }
    def ConstantPathWriteNode(target, operator_loc, value, location); end
    # Create a new ConstantReadNode node
    sig { params(name: Symbol, location: Location).returns(ConstantReadNode) }
    def ConstantReadNode(name, location); end
    # Create a new ConstantTargetNode node
    sig { params(name: Symbol, location: Location).returns(ConstantTargetNode) }
    def ConstantTargetNode(name, location); end
    # Create a new ConstantWriteNode node
    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).returns(ConstantWriteNode) }
    def ConstantWriteNode(name, name_loc, value, operator_loc, location); end
    # Create a new DefNode node
    sig { params(name: Symbol, name_loc: Location, receiver: T.nilable(Node), parameters: T.nilable(ParametersNode), body: T.nilable(Node), locals: T::Array[Symbol], def_keyword_loc: Location, operator_loc: T.nilable(Location), lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), equal_loc: T.nilable(Location), end_keyword_loc: T.nilable(Location), location: Location).returns(DefNode) }
    def DefNode(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end
    # Create a new DefinedNode node
    sig { params(lparen_loc: T.nilable(Location), value: Node, rparen_loc: T.nilable(Location), keyword_loc: Location, location: Location).returns(DefinedNode) }
    def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, location); end
    # Create a new ElseNode node
    sig { params(else_keyword_loc: Location, statements: T.nilable(StatementsNode), end_keyword_loc: T.nilable(Location), location: Location).returns(ElseNode) }
    def ElseNode(else_keyword_loc, statements, end_keyword_loc, location); end
    # Create a new EmbeddedStatementsNode node
    sig { params(opening_loc: Location, statements: T.nilable(StatementsNode), closing_loc: Location, location: Location).returns(EmbeddedStatementsNode) }
    def EmbeddedStatementsNode(opening_loc, statements, closing_loc, location); end
    # Create a new EmbeddedVariableNode node
    sig { params(operator_loc: Location, variable: Node, location: Location).returns(EmbeddedVariableNode) }
    def EmbeddedVariableNode(operator_loc, variable, location); end
    # Create a new EnsureNode node
    sig { params(ensure_keyword_loc: Location, statements: T.nilable(StatementsNode), end_keyword_loc: Location, location: Location).returns(EnsureNode) }
    def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, location); end
    # Create a new FalseNode node
    sig { params(location: Location).returns(FalseNode) }
    def FalseNode(location); end
    # Create a new FindPatternNode node
    sig { params(constant: T.nilable(Node), left: Node, requireds: T::Array[Node], right: Node, opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).returns(FindPatternNode) }
    def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, location); end
    # Create a new FlipFlopNode node
    sig { params(left: T.nilable(Node), right: T.nilable(Node), operator_loc: Location, flags: Integer, location: Location).returns(FlipFlopNode) }
    def FlipFlopNode(left, right, operator_loc, flags, location); end
    # Create a new FloatNode node
    sig { params(location: Location).returns(FloatNode) }
    def FloatNode(location); end
    # Create a new ForNode node
    sig { params(index: Node, collection: Node, statements: T.nilable(StatementsNode), for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: T.nilable(Location), end_keyword_loc: Location, location: Location).returns(ForNode) }
    def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end
    # Create a new ForwardingArgumentsNode node
    sig { params(location: Location).returns(ForwardingArgumentsNode) }
    def ForwardingArgumentsNode(location); end
    # Create a new ForwardingParameterNode node
    sig { params(location: Location).returns(ForwardingParameterNode) }
    def ForwardingParameterNode(location); end
    # Create a new ForwardingSuperNode node
    sig { params(block: T.nilable(BlockNode), location: Location).returns(ForwardingSuperNode) }
    def ForwardingSuperNode(block, location); end
    # Create a new GlobalVariableAndWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(GlobalVariableAndWriteNode) }
    def GlobalVariableAndWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new GlobalVariableOperatorWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).returns(GlobalVariableOperatorWriteNode) }
    def GlobalVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end
    # Create a new GlobalVariableOrWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(GlobalVariableOrWriteNode) }
    def GlobalVariableOrWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new GlobalVariableReadNode node
    sig { params(name: Symbol, location: Location).returns(GlobalVariableReadNode) }
    def GlobalVariableReadNode(name, location); end
    # Create a new GlobalVariableTargetNode node
    sig { params(name: Symbol, location: Location).returns(GlobalVariableTargetNode) }
    def GlobalVariableTargetNode(name, location); end
    # Create a new GlobalVariableWriteNode node
    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).returns(GlobalVariableWriteNode) }
    def GlobalVariableWriteNode(name, name_loc, value, operator_loc, location); end
    # Create a new HashNode node
    sig { params(opening_loc: Location, elements: T::Array[Node], closing_loc: Location, location: Location).returns(HashNode) }
    def HashNode(opening_loc, elements, closing_loc, location); end
    # Create a new HashPatternNode node
    sig { params(constant: T.nilable(Node), assocs: T::Array[Node], kwrest: T.nilable(Node), opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: Location).returns(HashPatternNode) }
    def HashPatternNode(constant, assocs, kwrest, opening_loc, closing_loc, location); end
    # Create a new IfNode node
    sig { params(if_keyword_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), consequent: T.nilable(Node), end_keyword_loc: T.nilable(Location), location: Location).returns(IfNode) }
    def IfNode(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end
    # Create a new ImaginaryNode node
    sig { params(numeric: Node, location: Location).returns(ImaginaryNode) }
    def ImaginaryNode(numeric, location); end
    # Create a new ImplicitNode node
    sig { params(value: Node, location: Location).returns(ImplicitNode) }
    def ImplicitNode(value, location); end
    # Create a new InNode node
    sig { params(pattern: Node, statements: T.nilable(StatementsNode), in_loc: Location, then_loc: T.nilable(Location), location: Location).returns(InNode) }
    def InNode(pattern, statements, in_loc, then_loc, location); end
    # Create a new InstanceVariableAndWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(InstanceVariableAndWriteNode) }
    def InstanceVariableAndWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new InstanceVariableOperatorWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location).returns(InstanceVariableOperatorWriteNode) }
    def InstanceVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end
    # Create a new InstanceVariableOrWriteNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(InstanceVariableOrWriteNode) }
    def InstanceVariableOrWriteNode(name, name_loc, operator_loc, value, location); end
    # Create a new InstanceVariableReadNode node
    sig { params(name: Symbol, location: Location).returns(InstanceVariableReadNode) }
    def InstanceVariableReadNode(name, location); end
    # Create a new InstanceVariableTargetNode node
    sig { params(name: Symbol, location: Location).returns(InstanceVariableTargetNode) }
    def InstanceVariableTargetNode(name, location); end
    # Create a new InstanceVariableWriteNode node
    sig { params(name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location).returns(InstanceVariableWriteNode) }
    def InstanceVariableWriteNode(name, name_loc, value, operator_loc, location); end
    # Create a new IntegerNode node
    sig { params(flags: Integer, location: Location).returns(IntegerNode) }
    def IntegerNode(flags, location); end
    # Create a new InterpolatedMatchLastLineNode node
    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, flags: Integer, location: Location).returns(InterpolatedMatchLastLineNode) }
    def InterpolatedMatchLastLineNode(opening_loc, parts, closing_loc, flags, location); end
    # Create a new InterpolatedRegularExpressionNode node
    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, flags: Integer, location: Location).returns(InterpolatedRegularExpressionNode) }
    def InterpolatedRegularExpressionNode(opening_loc, parts, closing_loc, flags, location); end
    # Create a new InterpolatedStringNode node
    sig { params(opening_loc: T.nilable(Location), parts: T::Array[Node], closing_loc: T.nilable(Location), location: Location).returns(InterpolatedStringNode) }
    def InterpolatedStringNode(opening_loc, parts, closing_loc, location); end
    # Create a new InterpolatedSymbolNode node
    sig { params(opening_loc: T.nilable(Location), parts: T::Array[Node], closing_loc: T.nilable(Location), location: Location).returns(InterpolatedSymbolNode) }
    def InterpolatedSymbolNode(opening_loc, parts, closing_loc, location); end
    # Create a new InterpolatedXStringNode node
    sig { params(opening_loc: Location, parts: T::Array[Node], closing_loc: Location, location: Location).returns(InterpolatedXStringNode) }
    def InterpolatedXStringNode(opening_loc, parts, closing_loc, location); end
    # Create a new KeywordHashNode node
    sig { params(elements: T::Array[Node], location: Location).returns(KeywordHashNode) }
    def KeywordHashNode(elements, location); end
    # Create a new KeywordParameterNode node
    sig { params(name: Symbol, name_loc: Location, value: T.nilable(Node), location: Location).returns(KeywordParameterNode) }
    def KeywordParameterNode(name, name_loc, value, location); end
    # Create a new KeywordRestParameterNode node
    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).returns(KeywordRestParameterNode) }
    def KeywordRestParameterNode(name, name_loc, operator_loc, location); end
    # Create a new LambdaNode node
    sig { params(locals: T::Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: T.nilable(BlockParametersNode), body: T.nilable(Node), location: Location).returns(LambdaNode) }
    def LambdaNode(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end
    # Create a new LocalVariableAndWriteNode node
    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location).returns(LocalVariableAndWriteNode) }
    def LocalVariableAndWriteNode(name_loc, operator_loc, value, name, depth, location); end
    # Create a new LocalVariableOperatorWriteNode node
    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location).returns(LocalVariableOperatorWriteNode) }
    def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, name, operator, depth, location); end
    # Create a new LocalVariableOrWriteNode node
    sig { params(name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location).returns(LocalVariableOrWriteNode) }
    def LocalVariableOrWriteNode(name_loc, operator_loc, value, name, depth, location); end
    # Create a new LocalVariableReadNode node
    sig { params(name: Symbol, depth: Integer, location: Location).returns(LocalVariableReadNode) }
    def LocalVariableReadNode(name, depth, location); end
    # Create a new LocalVariableTargetNode node
    sig { params(name: Symbol, depth: Integer, location: Location).returns(LocalVariableTargetNode) }
    def LocalVariableTargetNode(name, depth, location); end
    # Create a new LocalVariableWriteNode node
    sig { params(name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location).returns(LocalVariableWriteNode) }
    def LocalVariableWriteNode(name, depth, name_loc, value, operator_loc, location); end
    # Create a new MatchLastLineNode node
    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location).returns(MatchLastLineNode) }
    def MatchLastLineNode(opening_loc, content_loc, closing_loc, unescaped, flags, location); end
    # Create a new MatchPredicateNode node
    sig { params(value: Node, pattern: Node, operator_loc: Location, location: Location).returns(MatchPredicateNode) }
    def MatchPredicateNode(value, pattern, operator_loc, location); end
    # Create a new MatchRequiredNode node
    sig { params(value: Node, pattern: Node, operator_loc: Location, location: Location).returns(MatchRequiredNode) }
    def MatchRequiredNode(value, pattern, operator_loc, location); end
    # Create a new MatchWriteNode node
    sig { params(call: CallNode, locals: T::Array[Symbol], location: Location).returns(MatchWriteNode) }
    def MatchWriteNode(call, locals, location); end
    # Create a new MissingNode node
    sig { params(location: Location).returns(MissingNode) }
    def MissingNode(location); end
    # Create a new ModuleNode node
    sig { params(locals: T::Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: T.nilable(Node), end_keyword_loc: Location, name: Symbol, location: Location).returns(ModuleNode) }
    def ModuleNode(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end
    # Create a new MultiTargetNode node
    sig { params(targets: T::Array[Node], lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), location: Location).returns(MultiTargetNode) }
    def MultiTargetNode(targets, lparen_loc, rparen_loc, location); end
    # Create a new MultiWriteNode node
    sig { params(targets: T::Array[Node], lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), operator_loc: Location, value: Node, location: Location).returns(MultiWriteNode) }
    def MultiWriteNode(targets, lparen_loc, rparen_loc, operator_loc, value, location); end
    # Create a new NextNode node
    sig { params(arguments: T.nilable(ArgumentsNode), keyword_loc: Location, location: Location).returns(NextNode) }
    def NextNode(arguments, keyword_loc, location); end
    # Create a new NilNode node
    sig { params(location: Location).returns(NilNode) }
    def NilNode(location); end
    # Create a new NoKeywordsParameterNode node
    sig { params(operator_loc: Location, keyword_loc: Location, location: Location).returns(NoKeywordsParameterNode) }
    def NoKeywordsParameterNode(operator_loc, keyword_loc, location); end
    # Create a new NumberedReferenceReadNode node
    sig { params(number: Integer, location: Location).returns(NumberedReferenceReadNode) }
    def NumberedReferenceReadNode(number, location); end
    # Create a new OptionalParameterNode node
    sig { params(name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location).returns(OptionalParameterNode) }
    def OptionalParameterNode(name, name_loc, operator_loc, value, location); end
    # Create a new OrNode node
    sig { params(left: Node, right: Node, operator_loc: Location, location: Location).returns(OrNode) }
    def OrNode(left, right, operator_loc, location); end
    # Create a new ParametersNode node
    sig { params(requireds: T::Array[Node], optionals: T::Array[Node], rest: T.nilable(RestParameterNode), posts: T::Array[Node], keywords: T::Array[Node], keyword_rest: T.nilable(Node), block: T.nilable(BlockParameterNode), location: Location).returns(ParametersNode) }
    def ParametersNode(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end
    # Create a new ParenthesesNode node
    sig { params(body: T.nilable(Node), opening_loc: Location, closing_loc: Location, location: Location).returns(ParenthesesNode) }
    def ParenthesesNode(body, opening_loc, closing_loc, location); end
    # Create a new PinnedExpressionNode node
    sig { params(expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location).returns(PinnedExpressionNode) }
    def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, location); end
    # Create a new PinnedVariableNode node
    sig { params(variable: Node, operator_loc: Location, location: Location).returns(PinnedVariableNode) }
    def PinnedVariableNode(variable, operator_loc, location); end
    # Create a new PostExecutionNode node
    sig { params(statements: T.nilable(StatementsNode), keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location).returns(PostExecutionNode) }
    def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location); end
    # Create a new PreExecutionNode node
    sig { params(statements: T.nilable(StatementsNode), keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location).returns(PreExecutionNode) }
    def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location); end
    # Create a new ProgramNode node
    sig { params(locals: T::Array[Symbol], statements: StatementsNode, location: Location).returns(ProgramNode) }
    def ProgramNode(locals, statements, location); end
    # Create a new RangeNode node
    sig { params(left: T.nilable(Node), right: T.nilable(Node), operator_loc: Location, flags: Integer, location: Location).returns(RangeNode) }
    def RangeNode(left, right, operator_loc, flags, location); end
    # Create a new RationalNode node
    sig { params(numeric: Node, location: Location).returns(RationalNode) }
    def RationalNode(numeric, location); end
    # Create a new RedoNode node
    sig { params(location: Location).returns(RedoNode) }
    def RedoNode(location); end
    # Create a new RegularExpressionNode node
    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location).returns(RegularExpressionNode) }
    def RegularExpressionNode(opening_loc, content_loc, closing_loc, unescaped, flags, location); end
    # Create a new RequiredDestructuredParameterNode node
    sig { params(parameters: T::Array[Node], opening_loc: Location, closing_loc: Location, location: Location).returns(RequiredDestructuredParameterNode) }
    def RequiredDestructuredParameterNode(parameters, opening_loc, closing_loc, location); end
    # Create a new RequiredParameterNode node
    sig { params(name: Symbol, location: Location).returns(RequiredParameterNode) }
    def RequiredParameterNode(name, location); end
    # Create a new RescueModifierNode node
    sig { params(expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location).returns(RescueModifierNode) }
    def RescueModifierNode(expression, keyword_loc, rescue_expression, location); end
    # Create a new RescueNode node
    sig { params(keyword_loc: Location, exceptions: T::Array[Node], operator_loc: T.nilable(Location), reference: T.nilable(Node), statements: T.nilable(StatementsNode), consequent: T.nilable(RescueNode), location: Location).returns(RescueNode) }
    def RescueNode(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end
    # Create a new RestParameterNode node
    sig { params(name: T.nilable(Symbol), name_loc: T.nilable(Location), operator_loc: Location, location: Location).returns(RestParameterNode) }
    def RestParameterNode(name, name_loc, operator_loc, location); end
    # Create a new RetryNode node
    sig { params(location: Location).returns(RetryNode) }
    def RetryNode(location); end
    # Create a new ReturnNode node
    sig { params(keyword_loc: Location, arguments: T.nilable(ArgumentsNode), location: Location).returns(ReturnNode) }
    def ReturnNode(keyword_loc, arguments, location); end
    # Create a new SelfNode node
    sig { params(location: Location).returns(SelfNode) }
    def SelfNode(location); end
    # Create a new SingletonClassNode node
    sig { params(locals: T::Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: T.nilable(Node), end_keyword_loc: Location, location: Location).returns(SingletonClassNode) }
    def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end
    # Create a new SourceEncodingNode node
    sig { params(location: Location).returns(SourceEncodingNode) }
    def SourceEncodingNode(location); end
    # Create a new SourceFileNode node
    sig { params(filepath: String, location: Location).returns(SourceFileNode) }
    def SourceFileNode(filepath, location); end
    # Create a new SourceLineNode node
    sig { params(location: Location).returns(SourceLineNode) }
    def SourceLineNode(location); end
    # Create a new SplatNode node
    sig { params(operator_loc: Location, expression: T.nilable(Node), location: Location).returns(SplatNode) }
    def SplatNode(operator_loc, expression, location); end
    # Create a new StatementsNode node
    sig { params(body: T::Array[Node], location: Location).returns(StatementsNode) }
    def StatementsNode(body, location); end
    # Create a new StringConcatNode node
    sig { params(left: Node, right: Node, location: Location).returns(StringConcatNode) }
    def StringConcatNode(left, right, location); end
    # Create a new StringNode node
    sig { params(flags: Integer, opening_loc: T.nilable(Location), content_loc: Location, closing_loc: T.nilable(Location), unescaped: String, location: Location).returns(StringNode) }
    def StringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location); end
    # Create a new SuperNode node
    sig { params(keyword_loc: Location, lparen_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), rparen_loc: T.nilable(Location), block: T.nilable(BlockNode), location: Location).returns(SuperNode) }
    def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end
    # Create a new SymbolNode node
    sig { params(opening_loc: T.nilable(Location), value_loc: T.nilable(Location), closing_loc: T.nilable(Location), unescaped: String, location: Location).returns(SymbolNode) }
    def SymbolNode(opening_loc, value_loc, closing_loc, unescaped, location); end
    # Create a new TrueNode node
    sig { params(location: Location).returns(TrueNode) }
    def TrueNode(location); end
    # Create a new UndefNode node
    sig { params(names: T::Array[Node], keyword_loc: Location, location: Location).returns(UndefNode) }
    def UndefNode(names, keyword_loc, location); end
    # Create a new UnlessNode node
    sig { params(keyword_loc: Location, predicate: Node, statements: T.nilable(StatementsNode), consequent: T.nilable(ElseNode), end_keyword_loc: T.nilable(Location), location: Location).returns(UnlessNode) }
    def UnlessNode(keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end
    # Create a new UntilNode node
    sig { params(keyword_loc: Location, closing_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), flags: Integer, location: Location).returns(UntilNode) }
    def UntilNode(keyword_loc, closing_loc, predicate, statements, flags, location); end
    # Create a new WhenNode node
    sig { params(keyword_loc: Location, conditions: T::Array[Node], statements: T.nilable(StatementsNode), location: Location).returns(WhenNode) }
    def WhenNode(keyword_loc, conditions, statements, location); end
    # Create a new WhileNode node
    sig { params(keyword_loc: Location, closing_loc: T.nilable(Location), predicate: Node, statements: T.nilable(StatementsNode), flags: Integer, location: Location).returns(WhileNode) }
    def WhileNode(keyword_loc, closing_loc, predicate, statements, flags, location); end
    # Create a new XStringNode node
    sig { params(opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location).returns(XStringNode) }
    def XStringNode(opening_loc, content_loc, closing_loc, unescaped, location); end
    # Create a new YieldNode node
    sig { params(keyword_loc: Location, lparen_loc: T.nilable(Location), arguments: T.nilable(ArgumentsNode), rparen_loc: T.nilable(Location), location: Location).returns(YieldNode) }
    def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, location); end
  end
end
