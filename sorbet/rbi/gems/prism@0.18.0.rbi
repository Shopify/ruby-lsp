# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.

# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism.rbi.erb
# if you are looking to modify the template
# =end

# The Prism Ruby parser.
#
# "Parsing Ruby is suddenly manageable!"
#   - You, hopefully
#
# source://prism//lib/prism.rb#8
module Prism
  class << self
    # Mirror the Prism.dump API by using the serialization API.
    def dump(*_arg0); end

    # Mirror the Prism.dump_file API by using the serialization API.
    def dump_file(*_arg0); end

    # Mirror the Prism.lex API by using the serialization API.
    def lex(*_arg0); end

    # :call-seq:
    #   Prism::lex_compat(source, **options) -> Array
    #
    # Returns an array of tokens that closely resembles that of the Ripper lexer.
    # The only difference is that since we don't keep track of lexer state in the
    # same way, it's going to always return the NONE state.
    #
    # For supported options, see Prism::parse.
    #
    # source://prism//lib/prism.rb#46
    def lex_compat(source, **options); end

    # Mirror the Prism.lex_file API by using the serialization API.
    def lex_file(*_arg0); end

    # :call-seq:
    #   Prism::lex_ripper(source) -> Array
    #
    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # source://prism//lib/prism.rb#56
    def lex_ripper(source); end

    # :call-seq:
    #   Prism::load(source, serialized) -> ParseResult
    #
    # Load the serialized AST using the source as a reference into a tree.
    #
    # source://prism//lib/prism.rb#64
    def load(source, serialized); end

    # Mirror the Prism.parse API by using the serialization API.
    def parse(*_arg0); end

    # Mirror the Prism.parse_comments API by using the serialization API.
    def parse_comments(*_arg0); end

    # Mirror the Prism.parse_file API by using the serialization API. This uses
    # native strings instead of Ruby strings because it allows us to use mmap when
    # it is available.
    def parse_file(*_arg0); end

    # Mirror the Prism.parse_file_comments API by using the serialization
    # API. This uses native strings instead of Ruby strings because it allows us
    # to use mmap when it is available.
    def parse_file_comments(*_arg0); end

    # Mirror the Prism.parse_lex API by using the serialization API.
    def parse_lex(*_arg0); end

    # Mirror the Prism.parse_lex_file API by using the serialization API.
    def parse_lex_file(*_arg0); end
  end
end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#52
class Prism::AliasGlobalVariableNode < ::Prism::Node
  # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
  #
  # @return [AliasGlobalVariableNode] a new instance of AliasGlobalVariableNode
  #
  # source://prism//lib/prism/node.rb#63
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#71
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#76
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#86
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#81
  def compact_child_nodes; end

  # def copy: (**params) -> AliasGlobalVariableNode
  #
  # source://prism//lib/prism/node.rb#91
  sig { params(params: T.untyped).returns(Prism::AliasGlobalVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#76
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#104
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#114
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#109
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#60
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism//lib/prism/node.rb#54
  sig { returns(Prism::Node) }
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism//lib/prism/node.rb#57
  sig { returns(Prism::Node) }
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#138
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#148
    def type; end
  end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#157
class Prism::AliasMethodNode < ::Prism::Node
  # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
  #
  # @return [AliasMethodNode] a new instance of AliasMethodNode
  #
  # source://prism//lib/prism/node.rb#168
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#176
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#181
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#191
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#186
  def compact_child_nodes; end

  # def copy: (**params) -> AliasMethodNode
  #
  # source://prism//lib/prism/node.rb#196
  sig { params(params: T.untyped).returns(Prism::AliasMethodNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#181
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#209
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#219
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#214
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#165
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism//lib/prism/node.rb#159
  sig { returns(Prism::Node) }
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism//lib/prism/node.rb#162
  sig { returns(Prism::Node) }
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#243
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#253
    def type; end
  end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#262
class Prism::AlternationPatternNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # source://prism//lib/prism/node.rb#273
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#281
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#286
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#296
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#291
  def compact_child_nodes; end

  # def copy: (**params) -> AlternationPatternNode
  #
  # source://prism//lib/prism/node.rb#301
  sig { params(params: T.untyped).returns(Prism::AlternationPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#286
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#314
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#324
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism//lib/prism/node.rb#264
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#319
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#270
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism//lib/prism/node.rb#267
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#348
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#358
    def type; end
  end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#367
class Prism::AndNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AndNode] a new instance of AndNode
  #
  # source://prism//lib/prism/node.rb#378
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#386
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#391
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#401
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#396
  def compact_child_nodes; end

  # def copy: (**params) -> AndNode
  #
  # source://prism//lib/prism/node.rb#406
  sig { params(params: T.untyped).returns(Prism::AndNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#391
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#419
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#429
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism//lib/prism/node.rb#369
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#424
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#375
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism//lib/prism/node.rb#372
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#453
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#463
    def type; end
  end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#472
class Prism::ArgumentsNode < ::Prism::Node
  # def initialize: (arguments: Array[Node], flags: Integer, location: Location) -> void
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # source://prism//lib/prism/node.rb#480
  sig { params(arguments: T::Array[Prism::Node], flags: Integer, location: Prism::Location).void }
  def initialize(arguments, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#487
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: Array[Node]
  #
  # source://prism//lib/prism/node.rb#474
  sig { returns(T::Array[Prism::Node]) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#492
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#502
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#497
  def compact_child_nodes; end

  # def copy: (**params) -> ArgumentsNode
  #
  # source://prism//lib/prism/node.rb#507
  sig { params(params: T.untyped).returns(Prism::ArgumentsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#492
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#519
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#529
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#524
  sig { returns(T::Boolean) }
  def keyword_splat?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#551
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#477
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#561
    def type; end
  end
end

# Flags for arguments nodes.
#
# source://prism//lib/prism/node.rb#16605
module Prism::ArgumentsNodeFlags; end

# if arguments contain keyword splat
#
# source://prism//lib/prism/node.rb#16607
Prism::ArgumentsNodeFlags::KEYWORD_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array literal. This can be a regular array using brackets or
# a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#571
class Prism::ArrayNode < ::Prism::Node
  # def initialize: (elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # source://prism//lib/prism/node.rb#582
  sig do
    params(
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(elements, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#590
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#595
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#633
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#579
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#605
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#600
  def compact_child_nodes; end

  # def copy: (**params) -> ArrayNode
  #
  # source://prism//lib/prism/node.rb#610
  sig { params(params: T.untyped).returns(Prism::ArrayNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#595
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#623
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism//lib/prism/node.rb#573
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#638
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#628
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#576
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#660
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#670
    def type; end
  end
end

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#691
class Prism::ArrayPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # source://prism//lib/prism/node.rb#711
  sig do
    params(
      constant: T.nilable(Prism::Node),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#722
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#727
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#773
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#708
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#742
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#732
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism//lib/prism/node.rb#693
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> ArrayPatternNode
  #
  # source://prism//lib/prism/node.rb#747
  sig { params(params: T.untyped).returns(Prism::ArrayPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#727
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#763
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#778
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#768
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#705
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader posts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#702
  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism//lib/prism/node.rb#696
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://prism//lib/prism/node.rb#699
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#813
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#823
    def type; end
  end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# source://prism//lib/prism/node.rb#832
class Prism::AssocNode < ::Prism::Node
  # def initialize: (key: Node, value: Node?, operator_loc: Location?, location: Location) -> void
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # source://prism//lib/prism/node.rb#843
  sig do
    params(
      key: Prism::Node,
      value: T.nilable(Prism::Node),
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(key, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#851
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#856
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#869
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#861
  def compact_child_nodes; end

  # def copy: (**params) -> AssocNode
  #
  # source://prism//lib/prism/node.rb#874
  sig { params(params: T.untyped).returns(Prism::AssocNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#856
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#887
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#897
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader key: Node
  #
  # source://prism//lib/prism/node.rb#834
  sig { returns(Prism::Node) }
  def key; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#892
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#840
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#925
  def type; end

  # attr_reader value: Node?
  #
  # source://prism//lib/prism/node.rb#837
  sig { returns(T.nilable(Prism::Node)) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#935
    def type; end
  end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# source://prism//lib/prism/node.rb#944
class Prism::AssocSplatNode < ::Prism::Node
  # def initialize: (value: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # source://prism//lib/prism/node.rb#952
  sig { params(value: T.nilable(Prism::Node), operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#959
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#964
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#976
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#969
  def compact_child_nodes; end

  # def copy: (**params) -> AssocSplatNode
  #
  # source://prism//lib/prism/node.rb#981
  sig { params(params: T.untyped).returns(Prism::AssocSplatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#964
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#993
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1003
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#998
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#949
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1029
  def type; end

  # attr_reader value: Node?
  #
  # source://prism//lib/prism/node.rb#946
  sig { returns(T.nilable(Prism::Node)) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1039
    def type; end
  end
end

Prism::BACKEND = T.let(T.unsafe(nil), Symbol)

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# source://prism//lib/prism/node.rb#1048
class Prism::BackReferenceReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#1053
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1059
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1064
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1074
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1069
  def compact_child_nodes; end

  # def copy: (**params) -> BackReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#1079
  sig { params(params: T.untyped).returns(Prism::BackReferenceReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1064
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1090
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1095
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#1050
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1115
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1125
    def type; end
  end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# source://prism//lib/prism/visitor.rb#13
class Prism::BasicVisitor
  # Calls `accept` on the given node if it is not `nil`, which in turn should
  # call back into this visitor by calling the appropriate `visit_*` method.
  #
  # source://prism//lib/prism/visitor.rb#16
  sig { params(node: T.nilable(Prism::Node)).void }
  def visit(node); end

  # Visits each node in `nodes` by calling `accept` on each one.
  #
  # source://prism//lib/prism/visitor.rb#21
  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).void }
  def visit_all(nodes); end

  # Visits the child nodes of `node` by calling `accept` on each one.
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::Node).void }
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# source://prism//lib/prism/node.rb#1136
class Prism::BeginNode < ::Prism::Node
  # def initialize: (begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # source://prism//lib/prism/node.rb#1156
  sig do
    params(
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1167
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#1217
  sig { returns(T.nilable(String)) }
  def begin_keyword; end

  # attr_reader begin_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1138
  sig { returns(T.nilable(Prism::Location)) }
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1176
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1191
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1181
  def compact_child_nodes; end

  # def copy: (**params) -> BeginNode
  #
  # source://prism//lib/prism/node.rb#1196
  sig { params(params: T.untyped).returns(Prism::BeginNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1176
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1212
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader else_clause: ElseNode?
  #
  # source://prism//lib/prism/node.rb#1147
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#1222
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1153
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # attr_reader ensure_clause: EnsureNode?
  #
  # source://prism//lib/prism/node.rb#1150
  sig { returns(T.nilable(Prism::EnsureNode)) }
  def ensure_clause; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1227
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader rescue_clause: RescueNode?
  #
  # source://prism//lib/prism/node.rb#1144
  sig { returns(T.nilable(Prism::RescueNode)) }
  def rescue_clause; end

  # source://prism//lib/prism/node.rb#1171
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#1141
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1272
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1282
    def type; end
  end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1291
class Prism::BlockArgumentNode < ::Prism::Node
  # def initialize: (expression: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # source://prism//lib/prism/node.rb#1299
  sig { params(expression: T.nilable(Prism::Node), operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(expression, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1306
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1311
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1323
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1316
  def compact_child_nodes; end

  # def copy: (**params) -> BlockArgumentNode
  #
  # source://prism//lib/prism/node.rb#1328
  sig { params(params: T.untyped).returns(Prism::BlockArgumentNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1311
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1340
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism//lib/prism/node.rb#1293
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1350
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#1345
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#1296
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1376
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1386
    def type; end
  end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
#
# source://prism//lib/prism/node.rb#1395
class Prism::BlockLocalVariableNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [BlockLocalVariableNode] a new instance of BlockLocalVariableNode
  #
  # source://prism//lib/prism/node.rb#1400
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1406
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1411
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1421
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1416
  def compact_child_nodes; end

  # def copy: (**params) -> BlockLocalVariableNode
  #
  # source://prism//lib/prism/node.rb#1426
  sig { params(params: T.untyped).returns(Prism::BlockLocalVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1411
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1437
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1442
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#1397
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1462
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1472
    def type; end
  end
end

# Represents a block of ruby code.
#
# [1, 2, 3].each { |i| puts x }
#                ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1481
class Prism::BlockNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], parameters: BlockParametersNode?, body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # source://prism//lib/prism/node.rb#1498
  sig do
    params(
      locals: T::Array[Symbol],
      parameters: T.nilable(Prism::BlockParametersNode),
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(locals, parameters, body, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1508
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#1489
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1513
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#1556
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#1495
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1526
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1518
  def compact_child_nodes; end

  # def copy: (**params) -> BlockNode
  #
  # source://prism//lib/prism/node.rb#1531
  sig { params(params: T.untyped).returns(Prism::BlockNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1513
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1546
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1561
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#1483
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#1551
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#1492
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parameters: BlockParametersNode?
  #
  # source://prism//lib/prism/node.rb#1486
  sig { returns(T.nilable(Prism::BlockParametersNode)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1595
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1605
    def type; end
  end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#1615
class Prism::BlockParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # source://prism//lib/prism/node.rb#1626
  sig do
    params(
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1634
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1639
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1649
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1644
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParameterNode
  #
  # source://prism//lib/prism/node.rb#1654
  sig { params(params: T.untyped).returns(Prism::BlockParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1639
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1667
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1677
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#1617
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1620
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#1672
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#1623
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1703
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1713
    def type; end
  end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#1726
class Prism::BlockParametersNode < ::Prism::Node
  # def initialize: (parameters: ParametersNode?, locals: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # source://prism//lib/prism/node.rb#1740
  sig do
    params(
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1749
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1754
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#1796
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1737
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1767
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1759
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParametersNode
  #
  # source://prism//lib/prism/node.rb#1772
  sig { params(params: T.untyped).returns(Prism::BlockParametersNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1754
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1786
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1801
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Node]
  #
  # source://prism//lib/prism/node.rb#1731
  sig { returns(T::Array[Prism::Node]) }
  def locals; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#1791
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1734
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism//lib/prism/node.rb#1728
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1829
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1839
    def type; end
  end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1848
class Prism::BreakNode < ::Prism::Node
  # def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # source://prism//lib/prism/node.rb#1856
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1863
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#1850
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1868
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1880
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1873
  def compact_child_nodes; end

  # def copy: (**params) -> BreakNode
  #
  # source://prism//lib/prism/node.rb#1885
  sig { params(params: T.untyped).returns(Prism::BreakNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1868
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#1897
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#1907
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#1902
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#1853
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1933
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1943
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1952
class Prism::CallAndWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallAndWriteNode] a new instance of CallAndWriteNode
  #
  # source://prism//lib/prism/node.rb#1978
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      flags: Integer,
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1991
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2037
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1957
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1996
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2009
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2001
  def compact_child_nodes; end

  # def copy: (**params) -> CallAndWriteNode
  #
  # source://prism//lib/prism/node.rb#2014
  sig { params(params: T.untyped).returns(Prism::CallAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1996
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2032
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2062
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2042
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1960
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#2057
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#1972
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#1966
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#1954
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2047
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2096
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#1975
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2052
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#1969
  sig { returns(Symbol) }
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#1963
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2106
    def type; end
  end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#2130
class Prism::CallNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Node?, flags: Integer, name: Symbol, location: Location) -> void
  #
  # @return [CallNode] a new instance of CallNode
  #
  # source://prism//lib/prism/node.rb#2159
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      flags: Integer,
      name: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2173
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#2144
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism//lib/prism/node.rb#2150
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2221
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2135
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2178
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#2236
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2147
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2192
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2183
  def compact_child_nodes; end

  # def copy: (**params) -> CallNode
  #
  # source://prism//lib/prism/node.rb#2197
  sig { params(params: T.untyped).returns(Prism::CallNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2178
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2216
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2251
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2226
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2138
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#2156
  sig { returns(Symbol) }
  def name; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#2231
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2141
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#2132
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2241
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2295
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2246
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#2153
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2305
    def type; end
  end
end

# Flags for call nodes.
#
# source://prism//lib/prism/node.rb#16611
module Prism::CallNodeFlags; end

# &. operator
#
# source://prism//lib/prism/node.rb#16613
Prism::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)

# a call that could have been a local variable
#
# source://prism//lib/prism/node.rb#16616
Prism::CallNodeFlags::VARIABLE_CALL = T.let(T.unsafe(nil), Integer)

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2314
class Prism::CallOperatorWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#2343
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      flags: Integer,
      read_name: Symbol,
      write_name: Symbol,
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2357
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2404
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2319
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2362
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2375
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2367
  def compact_child_nodes; end

  # def copy: (**params) -> CallOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#2380
  sig { params(params: T.untyped).returns(Prism::CallOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2362
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2399
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2424
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2409
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2322
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#2334
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2337
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2328
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#2316
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2414
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2459
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#2340
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2419
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2331
  sig { returns(Symbol) }
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#2325
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2469
    def type; end
  end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2478
class Prism::CallOrWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallOrWriteNode] a new instance of CallOrWriteNode
  #
  # source://prism//lib/prism/node.rb#2504
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      flags: Integer,
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2517
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2563
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2483
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2522
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2535
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2527
  def compact_child_nodes; end

  # def copy: (**params) -> CallOrWriteNode
  #
  # source://prism//lib/prism/node.rb#2540
  sig { params(params: T.untyped).returns(Prism::CallOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2522
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2558
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2588
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2568
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2486
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#2583
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2498
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2492
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#2480
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2573
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2622
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#2501
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2578
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2495
  sig { returns(Symbol) }
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#2489
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2632
    def type; end
  end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2641
class Prism::CapturePatternNode < ::Prism::Node
  # def initialize: (value: Node, target: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # source://prism//lib/prism/node.rb#2652
  sig do
    params(
      value: Prism::Node,
      target: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, target, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2660
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2665
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2675
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2670
  def compact_child_nodes; end

  # def copy: (**params) -> CapturePatternNode
  #
  # source://prism//lib/prism/node.rb#2680
  sig { params(params: T.untyped).returns(Prism::CapturePatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2665
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2693
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2703
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#2698
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2649
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://prism//lib/prism/node.rb#2646
  sig { returns(Prism::Node) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2727
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#2643
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2737
    def type; end
  end
end

# Represents the use of a case statement for pattern matching.
#
#     case true
#     in false
#     end
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2748
class Prism::CaseMatchNode < ::Prism::Node
  # def initialize: (predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [CaseMatchNode] a new instance of CaseMatchNode
  #
  # source://prism//lib/prism/node.rb#2765
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2775
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#2819
  sig { returns(String) }
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#2759
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2780
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2794
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2785
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism//lib/prism/node.rb#2753
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#2756
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> CaseMatchNode
  #
  # source://prism//lib/prism/node.rb#2799
  sig { params(params: T.untyped).returns(Prism::CaseMatchNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2780
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2814
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#2824
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#2762
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2829
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node?
  #
  # source://prism//lib/prism/node.rb#2750
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2863
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2873
    def type; end
  end
end

# Represents the use of a case statement.
#
#     case true
#     when false
#     end
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2884
class Prism::CaseNode < ::Prism::Node
  # def initialize: (predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # source://prism//lib/prism/node.rb#2901
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2911
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#2955
  sig { returns(String) }
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#2895
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2916
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2930
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2921
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism//lib/prism/node.rb#2889
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#2892
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> CaseNode
  #
  # source://prism//lib/prism/node.rb#2935
  sig { params(params: T.untyped).returns(Prism::CaseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2916
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#2950
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#2960
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#2898
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#2965
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node?
  #
  # source://prism//lib/prism/node.rb#2886
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2999
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3009
    def type; end
  end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3018
class Prism::ClassNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # source://prism//lib/prism/node.rb#3044
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3057
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#3035
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3062
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3104
  sig { returns(String) }
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3023
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3076
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3067
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism//lib/prism/node.rb#3026
  sig { returns(Prism::Node) }
  def constant_path; end

  # def copy: (**params) -> ClassNode
  #
  # source://prism//lib/prism/node.rb#3081
  sig { params(params: T.untyped).returns(Prism::ClassNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3062
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3099
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3114
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3038
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inheritance_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#3109
  sig { returns(T.nilable(String)) }
  def inheritance_operator; end

  # attr_reader inheritance_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#3029
  sig { returns(T.nilable(Prism::Location)) }
  def inheritance_operator_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3119
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#3020
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3041
  sig { returns(Symbol) }
  def name; end

  # attr_reader superclass: Node?
  #
  # source://prism//lib/prism/node.rb#3032
  sig { returns(T.nilable(Prism::Node)) }
  def superclass; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3157
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3167
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3176
class Prism::ClassVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableAndWriteNode] a new instance of ClassVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3190
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3199
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3204
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3214
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3209
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3219
  sig { params(params: T.untyped).returns(Prism::ClassVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3204
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3233
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3243
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3178
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3181
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3238
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3184
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3267
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3187
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3277
    def type; end
  end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3286
class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3303
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3313
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3318
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3328
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3323
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3333
  sig { params(params: T.untyped).returns(Prism::ClassVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3318
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3348
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3353
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3288
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3291
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#3300
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3294
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3378
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3297
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3388
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3397
class Prism::ClassVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableOrWriteNode] a new instance of ClassVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#3411
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3420
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3425
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3435
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3430
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#3440
  sig { params(params: T.untyped).returns(Prism::ClassVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3425
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3454
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3464
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3399
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3402
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3459
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3405
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3488
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3408
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3498
    def type; end
  end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# source://prism//lib/prism/node.rb#3507
class Prism::ClassVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # source://prism//lib/prism/node.rb#3512
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3518
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3523
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3533
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3528
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableReadNode
  #
  # source://prism//lib/prism/node.rb#3538
  sig { params(params: T.untyped).returns(Prism::ClassVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3523
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3549
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3554
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3509
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3574
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3584
    def type; end
  end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
#
# source://prism//lib/prism/node.rb#3593
class Prism::ClassVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ClassVariableTargetNode] a new instance of ClassVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#3598
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3604
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3609
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3619
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3614
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#3624
  sig { params(params: T.untyped).returns(Prism::ClassVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3609
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3635
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3640
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3595
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3660
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3670
    def type; end
  end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3679
class Prism::ClassVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location?, location: Location) -> void
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#3693
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3702
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3717
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3712
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#3722
  sig { params(params: T.untyped).returns(Prism::ClassVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3736
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3746
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3681
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3684
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#3741
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#3690
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3770
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3687
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3780
    def type; end
  end
end

# This represents a comment that was encountered during parsing. It is the
# base class for all comment types.
#
# source://prism//lib/prism/parse_result.rb#228
class Prism::Comment
  # Create a new comment object with the given location.
  #
  # @return [Comment] a new instance of Comment
  #
  # source://prism//lib/prism/parse_result.rb#233
  def initialize(location); end

  # Implement the hash pattern matching interface for Comment.
  #
  # source://prism//lib/prism/parse_result.rb#238
  def deconstruct_keys(keys); end

  # The location of this comment in the source.
  #
  # source://prism//lib/prism/parse_result.rb#230
  sig { returns(Prism::Location) }
  def location; end

  # This can only be true for inline comments.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#243
  sig { returns(T::Boolean) }
  def trailing?; end
end

# A compiler is a visitor that returns the value of each node as it visits.
# This is as opposed to a visitor which will only walk the tree. This can be
# useful when you are trying to compile a tree into a different format.
#
# For example, to build a representation of the tree as s-expressions, you
# could write:
#
#     class SExpressions < Prism::Compiler
#       def visit_arguments_node(node) = [:arguments, super]
#       def visit_call_node(node) = [:call, super]
#       def visit_integer_node(node) = [:integer]
#       def visit_program_node(node) = [:program, super]
#     end
#
#     Prism.parse("1 + 2").value.accept(SExpressions.new)
#     # => [:program, [[[:call, [[:integer], [:arguments, [[:integer]]]]]]]]
#
# source://prism//lib/prism/compiler.rb#26
class Prism::Compiler
  # Visit an individual node.
  #
  # source://prism//lib/prism/compiler.rb#28
  def visit(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_alias_global_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasMethodNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_alias_method_node(node); end

  # Visit a list of nodes.
  #
  # source://prism//lib/prism/compiler.rb#33
  def visit_all(nodes); end

  # Visit the child nodes of the given node.
  # Compile a AlternationPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_alternation_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AndNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_and_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArgumentsNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_array_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_array_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_assoc_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocSplatNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_assoc_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BackReferenceReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_back_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BeginNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_begin_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockArgumentNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_block_argument_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_block_local_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_block_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_block_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_block_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BreakNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_break_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_call_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_call_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_call_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_call_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CapturePatternNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_capture_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseMatchNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_case_match_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_case_node(node); end

  # Visit the child nodes of the given node.
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_child_nodes(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_class_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_path_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_constant_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_def_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefinedNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_defined_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ElseNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_else_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_embedded_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_embedded_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EnsureNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_ensure_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FalseNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_false_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FindPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_find_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FlipFlopNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_flip_flop_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FloatNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_float_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_for_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_forwarding_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_forwarding_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingSuperNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_forwarding_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_global_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_hash_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IfNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_if_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImaginaryNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_imaginary_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImplicitNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_implicit_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_in_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_index_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_index_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_index_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_instance_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IntegerNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_integer_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_interpolated_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_interpolated_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedStringNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_interpolated_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_interpolated_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_interpolated_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordHashNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_keyword_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_keyword_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LambdaNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_lambda_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_local_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchLastLineNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchPredicateNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_match_predicate_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchRequiredNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_match_required_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_match_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MissingNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_missing_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ModuleNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_module_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_multi_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_multi_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NextNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_next_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NilNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_nil_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_no_keywords_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_numbered_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_optional_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_optional_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OrNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_or_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParenthesesNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_parentheses_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_pinned_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_pinned_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PostExecutionNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_post_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PreExecutionNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_pre_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ProgramNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_program_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RangeNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_range_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RationalNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_rational_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RedoNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_redo_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RegularExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_required_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_required_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueModifierNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_rescue_modifier_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_rescue_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RestParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RetryNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_retry_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ReturnNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_return_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SelfNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_self_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SingletonClassNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_singleton_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceEncodingNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_source_encoding_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceFileNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_source_file_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceLineNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_source_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SplatNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StatementsNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StringNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SuperNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SymbolNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a TrueNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_true_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UndefNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_undef_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UnlessNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_unless_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UntilNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_until_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhenNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_when_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhileNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_while_node(node); end

  # Visit the child nodes of the given node.
  # Compile a XStringNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a YieldNode node
  #
  # source://prism//lib/prism/compiler.rb#38
  def visit_yield_node(node); end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3789
class Prism::ConstantAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantAndWriteNode] a new instance of ConstantAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3803
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3812
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3817
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3827
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3822
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3832
  sig { params(params: T.untyped).returns(Prism::ConstantAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3817
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3846
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3856
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3791
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3794
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3851
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3797
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3880
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3800
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3890
    def type; end
  end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3899
class Prism::ConstantOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3916
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3926
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3931
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3941
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3936
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3946
  sig { params(params: T.untyped).returns(Prism::ConstantOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3931
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#3961
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#3966
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3901
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3904
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#3913
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3907
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3991
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#3910
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4001
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4010
class Prism::ConstantOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantOrWriteNode] a new instance of ConstantOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4024
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4033
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4038
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4048
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4043
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4053
  sig { params(params: T.untyped).returns(Prism::ConstantOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4038
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4067
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4077
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4012
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4015
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4072
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4018
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4101
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4021
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4111
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4120
class Prism::ConstantPathAndWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathAndWriteNode] a new instance of ConstantPathAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4131
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4139
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4144
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4154
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4149
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4159
  sig { params(params: T.untyped).returns(Prism::ConstantPathAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4144
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4172
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4182
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4177
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4125
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4122
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4206
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4128
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4216
    def type; end
  end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#4225
class Prism::ConstantPathNode < ::Prism::Node
  # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4236
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4244
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism//lib/prism/node.rb#4230
  sig { returns(Prism::Node) }
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4249
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4262
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4254
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4267
  sig { params(params: T.untyped).returns(Prism::ConstantPathNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4249
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4280
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism//lib/prism/node.rb#4285
  sig { returns(String) }
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism//lib/prism/node.rb#4233
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism//lib/prism/node_ext.rb#104
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism//lib/prism/node_ext.rb#87
  def full_name_parts; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4290
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism//lib/prism/node.rb#4227
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4318
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4328
    def type; end
  end
end

# An error class raised when dynamic parts are found while computing a
# constant path's full name. For example:
# Foo::Bar::Baz -> does not raise because all parts of the constant path are
# simple constants
# var::Bar::Baz -> raises because the first part of the constant path is a
# local variable
#
# source://prism//lib/prism/node_ext.rb#83
class Prism::ConstantPathNode::DynamicPartsInConstantPathError < ::StandardError; end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4337
class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4351
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4360
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4365
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4375
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4370
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4380
  sig { params(params: T.untyped).returns(Prism::ConstantPathOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4365
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4394
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4399
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#4348
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4342
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4339
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4424
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4345
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4434
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4443
class Prism::ConstantPathOrWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathOrWriteNode] a new instance of ConstantPathOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4454
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4462
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4467
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4477
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4472
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4482
  sig { params(params: T.untyped).returns(Prism::ConstantPathOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4467
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4495
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4505
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4500
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4448
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4445
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4529
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4451
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4539
    def type; end
  end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
#
# source://prism//lib/prism/node.rb#4548
class Prism::ConstantPathTargetNode < ::Prism::Node
  # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
  #
  # @return [ConstantPathTargetNode] a new instance of ConstantPathTargetNode
  #
  # source://prism//lib/prism/node.rb#4559
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4567
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism//lib/prism/node.rb#4553
  sig { returns(Prism::Node) }
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4572
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4585
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4577
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathTargetNode
  #
  # source://prism//lib/prism/node.rb#4590
  sig { params(params: T.untyped).returns(Prism::ConstantPathTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4572
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4603
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism//lib/prism/node.rb#4608
  sig { returns(String) }
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism//lib/prism/node.rb#4556
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism//lib/prism/node_ext.rb#117
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism//lib/prism/node_ext.rb#112
  def full_name_parts; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4613
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism//lib/prism/node.rb#4550
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4641
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4651
    def type; end
  end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4666
class Prism::ConstantPathWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # source://prism//lib/prism/node.rb#4677
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4685
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4690
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4700
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4695
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathWriteNode
  #
  # source://prism//lib/prism/node.rb#4705
  sig { params(params: T.untyped).returns(Prism::ConstantPathWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4690
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4718
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4728
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4723
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4671
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4668
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4752
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4674
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4762
    def type; end
  end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# source://prism//lib/prism/node.rb#4771
class Prism::ConstantReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # source://prism//lib/prism/node.rb#4776
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4782
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4787
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4797
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4792
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantReadNode
  #
  # source://prism//lib/prism/node.rb#4802
  sig { params(params: T.untyped).returns(Prism::ConstantReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4787
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4813
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism//lib/prism/node_ext.rb#71
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism//lib/prism/node_ext.rb#66
  def full_name_parts; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4818
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4773
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4838
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4848
    def type; end
  end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
#
# source://prism//lib/prism/node.rb#4857
class Prism::ConstantTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ConstantTargetNode] a new instance of ConstantTargetNode
  #
  # source://prism//lib/prism/node.rb#4862
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4868
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4873
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4883
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4878
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantTargetNode
  #
  # source://prism//lib/prism/node.rb#4888
  sig { params(params: T.untyped).returns(Prism::ConstantTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4873
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#4899
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#4904
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4859
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4924
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4934
    def type; end
  end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#4943
class Prism::ConstantWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [ConstantWriteNode] a new instance of ConstantWriteNode
  #
  # source://prism//lib/prism/node.rb#4957
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4966
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4971
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4981
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4976
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantWriteNode
  #
  # source://prism//lib/prism/node.rb#4986
  sig { params(params: T.untyped).returns(Prism::ConstantWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4971
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5000
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5010
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4945
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4948
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#5005
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4954
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5034
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#4951
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5044
    def type; end
  end
end

# DATAComment objects correspond to comments that are after the __END__
# keyword in a source file.
#
# source://prism//lib/prism/parse_result.rb#274
class Prism::DATAComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism//lib/prism/parse_result.rb#276
  def inspect; end
end

# The DSL module provides a set of methods that can be used to create prism
# nodes in a more concise manner. For example, instead of writing:
#
#     source = Prism::Source.new("[1]")
#
#     Prism::ArrayNode.new(
#       [
#         Prism::IntegerNode.new(
#           Prism::IntegerBaseFlags::DECIMAL,
#           Prism::Location.new(source, 1, 1),
#         )
#       ],
#       Prism::Location.new(source, 0, 1),
#       Prism::Location.new(source, 2, 1)
#     )
#
# you could instead write:
#
#     source = Prism::Source.new("[1]")
#
#     ArrayNode(
#       IntegerNode(Prism::IntegerBaseFlags::DECIMAL, Location(source, 1, 1))),
#       Location(source, 0, 1),
#       Location(source, 2, 1)
#     )
#
# This is mostly helpful in the context of writing tests, but can also be used
# to generate trees programmatically.
#
# source://prism//lib/prism/dsl.rb#37
module Prism::DSL
  private

  # Create a new AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#46
  def AliasGlobalVariableNode(new_name, old_name, keyword_loc, location = T.unsafe(nil)); end

  # Create a new AliasMethodNode node
  #
  # source://prism//lib/prism/dsl.rb#51
  def AliasMethodNode(new_name, old_name, keyword_loc, location = T.unsafe(nil)); end

  # Create a new AlternationPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#56
  def AlternationPatternNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new AndNode node
  #
  # source://prism//lib/prism/dsl.rb#61
  def AndNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ArgumentsNode node
  #
  # source://prism//lib/prism/dsl.rb#66
  def ArgumentsNode(arguments, flags, location = T.unsafe(nil)); end

  # Create a new ArrayNode node
  #
  # source://prism//lib/prism/dsl.rb#71
  def ArrayNode(elements, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ArrayPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#76
  def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new AssocNode node
  #
  # source://prism//lib/prism/dsl.rb#81
  def AssocNode(key, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new AssocSplatNode node
  #
  # source://prism//lib/prism/dsl.rb#86
  def AssocSplatNode(value, operator_loc, location = T.unsafe(nil)); end

  # Create a new BackReferenceReadNode node
  #
  # source://prism//lib/prism/dsl.rb#91
  def BackReferenceReadNode(name, location = T.unsafe(nil)); end

  # Create a new BeginNode node
  #
  # source://prism//lib/prism/dsl.rb#96
  def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new BlockArgumentNode node
  #
  # source://prism//lib/prism/dsl.rb#101
  def BlockArgumentNode(expression, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockLocalVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#106
  def BlockLocalVariableNode(name, location = T.unsafe(nil)); end

  # Create a new BlockNode node
  #
  # source://prism//lib/prism/dsl.rb#111
  def BlockNode(locals, parameters, body, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BlockParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#116
  def BlockParameterNode(name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#121
  def BlockParametersNode(parameters, locals, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BreakNode node
  #
  # source://prism//lib/prism/dsl.rb#126
  def BreakNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new CallAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#131
  def CallAndWriteNode(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallNode node
  #
  # source://prism//lib/prism/dsl.rb#136
  def CallNode(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location = T.unsafe(nil)); end

  # Create a new CallOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#141
  def CallOperatorWriteNode(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#146
  def CallOrWriteNode(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CapturePatternNode node
  #
  # source://prism//lib/prism/dsl.rb#151
  def CapturePatternNode(value, target, operator_loc, location = T.unsafe(nil)); end

  # Create a new CaseMatchNode node
  #
  # source://prism//lib/prism/dsl.rb#156
  def CaseMatchNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new CaseNode node
  #
  # source://prism//lib/prism/dsl.rb#161
  def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ClassNode node
  #
  # source://prism//lib/prism/dsl.rb#166
  def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location = T.unsafe(nil)); end

  # Create a new ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#171
  def ClassVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#176
  def ClassVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#181
  def ClassVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#186
  def ClassVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new ClassVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#191
  def ClassVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new ClassVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#196
  def ClassVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new ConstantAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#201
  def ConstantAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#206
  def ConstantOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#211
  def ConstantOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#216
  def ConstantPathAndWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathNode node
  #
  # source://prism//lib/prism/dsl.rb#221
  def ConstantPathNode(parent, child, delimiter_loc, location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#226
  def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#231
  def ConstantPathOrWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#236
  def ConstantPathTargetNode(parent, child, delimiter_loc, location = T.unsafe(nil)); end

  # Create a new ConstantPathWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#241
  def ConstantPathWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantReadNode node
  #
  # source://prism//lib/prism/dsl.rb#246
  def ConstantReadNode(name, location = T.unsafe(nil)); end

  # Create a new ConstantTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#251
  def ConstantTargetNode(name, location = T.unsafe(nil)); end

  # Create a new ConstantWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#256
  def ConstantWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new DefNode node
  #
  # source://prism//lib/prism/dsl.rb#261
  def DefNode(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new DefinedNode node
  #
  # source://prism//lib/prism/dsl.rb#266
  def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new ElseNode node
  #
  # source://prism//lib/prism/dsl.rb#271
  def ElseNode(else_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/dsl.rb#276
  def EmbeddedStatementsNode(opening_loc, statements, closing_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#281
  def EmbeddedVariableNode(operator_loc, variable, location = T.unsafe(nil)); end

  # Create a new EnsureNode node
  #
  # source://prism//lib/prism/dsl.rb#286
  def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new FalseNode node
  #
  # source://prism//lib/prism/dsl.rb#291
  def FalseNode(location = T.unsafe(nil)); end

  # Create a new FindPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#296
  def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new FlipFlopNode node
  #
  # source://prism//lib/prism/dsl.rb#301
  def FlipFlopNode(left, right, operator_loc, flags, location = T.unsafe(nil)); end

  # Create a new FloatNode node
  #
  # source://prism//lib/prism/dsl.rb#306
  def FloatNode(location = T.unsafe(nil)); end

  # Create a new ForNode node
  #
  # source://prism//lib/prism/dsl.rb#311
  def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/dsl.rb#316
  def ForwardingArgumentsNode(location = T.unsafe(nil)); end

  # Create a new ForwardingParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#321
  def ForwardingParameterNode(location = T.unsafe(nil)); end

  # Create a new ForwardingSuperNode node
  #
  # source://prism//lib/prism/dsl.rb#326
  def ForwardingSuperNode(block, location = T.unsafe(nil)); end

  # Create a new GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#331
  def GlobalVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#336
  def GlobalVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#341
  def GlobalVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#346
  def GlobalVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#351
  def GlobalVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#356
  def GlobalVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new HashNode node
  #
  # source://prism//lib/prism/dsl.rb#361
  def HashNode(opening_loc, elements, closing_loc, location = T.unsafe(nil)); end

  # Create a new HashPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#366
  def HashPatternNode(constant, elements, rest, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new IfNode node
  #
  # source://prism//lib/prism/dsl.rb#371
  def IfNode(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ImaginaryNode node
  #
  # source://prism//lib/prism/dsl.rb#376
  def ImaginaryNode(numeric, location = T.unsafe(nil)); end

  # Create a new ImplicitNode node
  #
  # source://prism//lib/prism/dsl.rb#381
  def ImplicitNode(value, location = T.unsafe(nil)); end

  # Create a new InNode node
  #
  # source://prism//lib/prism/dsl.rb#386
  def InNode(pattern, statements, in_loc, then_loc, location = T.unsafe(nil)); end

  # Create a new IndexAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#391
  def IndexAndWriteNode(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#396
  def IndexOperatorWriteNode(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new IndexOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#401
  def IndexOrWriteNode(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#406
  def InstanceVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#411
  def InstanceVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#416
  def InstanceVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#421
  def InstanceVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#426
  def InstanceVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#431
  def InstanceVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new IntegerNode node
  #
  # source://prism//lib/prism/dsl.rb#436
  def IntegerNode(flags, location = T.unsafe(nil)); end

  # Create a new InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/dsl.rb#441
  def InterpolatedMatchLastLineNode(opening_loc, parts, closing_loc, flags, location = T.unsafe(nil)); end

  # Create a new InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#446
  def InterpolatedRegularExpressionNode(opening_loc, parts, closing_loc, flags, location = T.unsafe(nil)); end

  # Create a new InterpolatedStringNode node
  #
  # source://prism//lib/prism/dsl.rb#451
  def InterpolatedStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/dsl.rb#456
  def InterpolatedSymbolNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedXStringNode node
  #
  # source://prism//lib/prism/dsl.rb#461
  def InterpolatedXStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new KeywordHashNode node
  #
  # source://prism//lib/prism/dsl.rb#466
  def KeywordHashNode(elements, location = T.unsafe(nil)); end

  # Create a new KeywordRestParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#471
  def KeywordRestParameterNode(name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new LambdaNode node
  #
  # source://prism//lib/prism/dsl.rb#476
  def LambdaNode(locals, operator_loc, opening_loc, closing_loc, parameters, body, location = T.unsafe(nil)); end

  # Create a new LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#481
  def LocalVariableAndWriteNode(name_loc, operator_loc, value, name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#486
  def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, name, operator, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#491
  def LocalVariableOrWriteNode(name_loc, operator_loc, value, name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#496
  def LocalVariableReadNode(name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#501
  def LocalVariableTargetNode(name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#506
  def LocalVariableWriteNode(name, depth, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new Location object
  #
  # source://prism//lib/prism/dsl.rb#41
  def Location(source = T.unsafe(nil), start_offset = T.unsafe(nil), length = T.unsafe(nil)); end

  # Create a new MatchLastLineNode node
  #
  # source://prism//lib/prism/dsl.rb#511
  def MatchLastLineNode(opening_loc, content_loc, closing_loc, unescaped, flags, location = T.unsafe(nil)); end

  # Create a new MatchPredicateNode node
  #
  # source://prism//lib/prism/dsl.rb#516
  def MatchPredicateNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MatchRequiredNode node
  #
  # source://prism//lib/prism/dsl.rb#521
  def MatchRequiredNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MatchWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#526
  def MatchWriteNode(call, targets, location = T.unsafe(nil)); end

  # Create a new MissingNode node
  #
  # source://prism//lib/prism/dsl.rb#531
  def MissingNode(location = T.unsafe(nil)); end

  # Create a new ModuleNode node
  #
  # source://prism//lib/prism/dsl.rb#536
  def ModuleNode(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location = T.unsafe(nil)); end

  # Create a new MultiTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#541
  def MultiTargetNode(lefts, rest, rights, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new MultiWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#546
  def MultiWriteNode(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new NextNode node
  #
  # source://prism//lib/prism/dsl.rb#551
  def NextNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NilNode node
  #
  # source://prism//lib/prism/dsl.rb#556
  def NilNode(location = T.unsafe(nil)); end

  # Create a new NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#561
  def NoKeywordsParameterNode(operator_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/dsl.rb#566
  def NumberedReferenceReadNode(number, location = T.unsafe(nil)); end

  # Create a new OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#571
  def OptionalKeywordParameterNode(name, name_loc, value, location = T.unsafe(nil)); end

  # Create a new OptionalParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#576
  def OptionalParameterNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new OrNode node
  #
  # source://prism//lib/prism/dsl.rb#581
  def OrNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#586
  def ParametersNode(requireds, optionals, rest, posts, keywords, keyword_rest, block, location = T.unsafe(nil)); end

  # Create a new ParenthesesNode node
  #
  # source://prism//lib/prism/dsl.rb#591
  def ParenthesesNode(body, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PinnedExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#596
  def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new PinnedVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#601
  def PinnedVariableNode(variable, operator_loc, location = T.unsafe(nil)); end

  # Create a new PostExecutionNode node
  #
  # source://prism//lib/prism/dsl.rb#606
  def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PreExecutionNode node
  #
  # source://prism//lib/prism/dsl.rb#611
  def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ProgramNode node
  #
  # source://prism//lib/prism/dsl.rb#616
  def ProgramNode(locals, statements, location = T.unsafe(nil)); end

  # Create a new RangeNode node
  #
  # source://prism//lib/prism/dsl.rb#621
  def RangeNode(left, right, operator_loc, flags, location = T.unsafe(nil)); end

  # Create a new RationalNode node
  #
  # source://prism//lib/prism/dsl.rb#626
  def RationalNode(numeric, location = T.unsafe(nil)); end

  # Create a new RedoNode node
  #
  # source://prism//lib/prism/dsl.rb#631
  def RedoNode(location = T.unsafe(nil)); end

  # Create a new RegularExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#636
  def RegularExpressionNode(opening_loc, content_loc, closing_loc, unescaped, flags, location = T.unsafe(nil)); end

  # Create a new RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#641
  def RequiredKeywordParameterNode(name, name_loc, location = T.unsafe(nil)); end

  # Create a new RequiredParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#646
  def RequiredParameterNode(name, location = T.unsafe(nil)); end

  # Create a new RescueModifierNode node
  #
  # source://prism//lib/prism/dsl.rb#651
  def RescueModifierNode(expression, keyword_loc, rescue_expression, location = T.unsafe(nil)); end

  # Create a new RescueNode node
  #
  # source://prism//lib/prism/dsl.rb#656
  def RescueNode(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location = T.unsafe(nil)); end

  # Create a new RestParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#661
  def RestParameterNode(name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new RetryNode node
  #
  # source://prism//lib/prism/dsl.rb#666
  def RetryNode(location = T.unsafe(nil)); end

  # Create a new ReturnNode node
  #
  # source://prism//lib/prism/dsl.rb#671
  def ReturnNode(keyword_loc, arguments, location = T.unsafe(nil)); end

  # Create a new SelfNode node
  #
  # source://prism//lib/prism/dsl.rb#676
  def SelfNode(location = T.unsafe(nil)); end

  # Create a new SingletonClassNode node
  #
  # source://prism//lib/prism/dsl.rb#681
  def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new SourceEncodingNode node
  #
  # source://prism//lib/prism/dsl.rb#686
  def SourceEncodingNode(location = T.unsafe(nil)); end

  # Create a new SourceFileNode node
  #
  # source://prism//lib/prism/dsl.rb#691
  def SourceFileNode(filepath, location = T.unsafe(nil)); end

  # Create a new SourceLineNode node
  #
  # source://prism//lib/prism/dsl.rb#696
  def SourceLineNode(location = T.unsafe(nil)); end

  # Create a new SplatNode node
  #
  # source://prism//lib/prism/dsl.rb#701
  def SplatNode(operator_loc, expression, location = T.unsafe(nil)); end

  # Create a new StatementsNode node
  #
  # source://prism//lib/prism/dsl.rb#706
  def StatementsNode(body, location = T.unsafe(nil)); end

  # Create a new StringNode node
  #
  # source://prism//lib/prism/dsl.rb#711
  def StringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new SuperNode node
  #
  # source://prism//lib/prism/dsl.rb#716
  def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, location = T.unsafe(nil)); end

  # Create a new SymbolNode node
  #
  # source://prism//lib/prism/dsl.rb#721
  def SymbolNode(opening_loc, value_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new TrueNode node
  #
  # source://prism//lib/prism/dsl.rb#726
  def TrueNode(location = T.unsafe(nil)); end

  # Create a new UndefNode node
  #
  # source://prism//lib/prism/dsl.rb#731
  def UndefNode(names, keyword_loc, location = T.unsafe(nil)); end

  # Create a new UnlessNode node
  #
  # source://prism//lib/prism/dsl.rb#736
  def UnlessNode(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new UntilNode node
  #
  # source://prism//lib/prism/dsl.rb#741
  def UntilNode(keyword_loc, closing_loc, predicate, statements, flags, location = T.unsafe(nil)); end

  # Create a new WhenNode node
  #
  # source://prism//lib/prism/dsl.rb#746
  def WhenNode(keyword_loc, conditions, statements, location = T.unsafe(nil)); end

  # Create a new WhileNode node
  #
  # source://prism//lib/prism/dsl.rb#751
  def WhileNode(keyword_loc, closing_loc, predicate, statements, flags, location = T.unsafe(nil)); end

  # Create a new XStringNode node
  #
  # source://prism//lib/prism/dsl.rb#756
  def XStringNode(opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new YieldNode node
  #
  # source://prism//lib/prism/dsl.rb#761
  def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, location = T.unsafe(nil)); end
end

# This module is used for testing and debugging and is not meant to be used by
# consumers of this library.
#
# source://prism//lib/prism/debug.rb#6
module Prism::Debug
  class << self
    # :call-seq:
    #   Debug::cruby_locals(source) -> Array
    #
    # For the given source, compiles with CRuby and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism//lib/prism/debug.rb#54
    def cruby_locals(source); end

    def inspect_node(_arg0); end
    def memsize(_arg0); end
    def named_captures(_arg0); end

    # :call-seq:
    #   Debug::newlines(source) -> Array
    #
    # For the given source string, return the byte offsets of every newline in
    # the source.
    #
    # source://prism//lib/prism/debug.rb#191
    def newlines(source); end

    # :call-seq:
    #   Debug::prism_locals(source) -> Array
    #
    # For the given source, parses with prism and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism//lib/prism/debug.rb#98
    def prism_locals(source); end

    def profile_file(_arg0); end
  end
end

# Used to hold the place of a local that will be in the local table but
# cannot be accessed directly from the source code. For example, the
# iteration variable in a for loop or the positional parameter on a method
# definition that is destructured.
#
# source://prism//lib/prism/debug.rb#90
Prism::Debug::AnonymousLocal = T.let(T.unsafe(nil), Object)

# A wrapper around a RubyVM::InstructionSequence that provides a more
# convenient interface for accessing parts of the iseq.
#
# source://prism//lib/prism/debug.rb#9
class Prism::Debug::ISeq
  # @return [ISeq] a new instance of ISeq
  #
  # source://prism//lib/prism/debug.rb#12
  def initialize(parts); end

  # source://prism//lib/prism/debug.rb#28
  def each_child; end

  # source://prism//lib/prism/debug.rb#24
  def instructions; end

  # source://prism//lib/prism/debug.rb#20
  def local_table; end

  # source://prism//lib/prism/debug.rb#10
  def parts; end

  # source://prism//lib/prism/debug.rb#16
  def type; end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5054
class Prism::DefNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, receiver: Node?, parameters: ParametersNode?, body: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [DefNode] a new instance of DefNode
  #
  # source://prism//lib/prism/node.rb#5092
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(Prism::Node),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5109
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#5068
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5114
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5128
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5119
  def compact_child_nodes; end

  # def copy: (**params) -> DefNode
  #
  # source://prism//lib/prism/node.rb#5133
  sig { params(params: T.untyped).returns(Prism::DefNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5114
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5155
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5160
  sig { returns(String) }
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5074
  sig { returns(Prism::Location) }
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#5185
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5089
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # source://prism//lib/prism/node.rb#5180
  sig { returns(T.nilable(String)) }
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5086
  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5190
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#5071
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5170
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5080
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#5056
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#5059
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#5165
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5077
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism//lib/prism/node.rb#5065
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#5062
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5175
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5083
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5236
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5246
    def type; end
  end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5255
class Prism::DefinedNode < ::Prism::Node
  # def initialize: (lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location) -> void
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # source://prism//lib/prism/node.rb#5269
  sig do
    params(
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5278
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5283
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5293
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5288
  def compact_child_nodes; end

  # def copy: (**params) -> DefinedNode
  #
  # source://prism//lib/prism/node.rb#5298
  sig { params(params: T.untyped).returns(Prism::DefinedNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5283
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5312
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5332
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5327
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5266
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5317
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5257
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5322
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5263
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5356
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#5260
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5366
    def type; end
  end
end

# DesugarCompiler is a compiler that desugars Ruby code into a more primitive
# form. This is useful for consumers that want to deal with fewer node types.
#
# source://prism//lib/prism/desugar_compiler.rb#6
class Prism::DesugarCompiler < ::Prism::MutationCompiler
  # @@foo &&= bar
  #
  # becomes
  #
  # @@foo && @@foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#12
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  #
  # becomes
  #
  # @@foo = @@foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#30
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  #
  # becomes
  #
  # defined?(@@foo) ? @@foo : @@foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#21
  def visit_class_variable_or_write_node(node); end

  # Foo &&= bar
  #
  # becomes
  #
  # Foo && Foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#39
  def visit_constant_and_write_node(node); end

  # Foo += bar
  #
  # becomes
  #
  # Foo = Foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#57
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  #
  # becomes
  #
  # defined?(Foo) ? Foo : Foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#48
  def visit_constant_or_write_node(node); end

  # $foo &&= bar
  #
  # becomes
  #
  # $foo && $foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#66
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  #
  # becomes
  #
  # $foo = $foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#84
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  #
  # becomes
  #
  # defined?($foo) ? $foo : $foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#75
  def visit_global_variable_or_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#93
  def visit_instance_variable_and_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#111
  def visit_instance_variable_operator_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#102
  def visit_instance_variable_or_write_node(node); end

  # foo &&= bar
  #
  # becomes
  #
  # foo && foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#120
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  #
  # becomes
  #
  # foo = foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#138
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  #
  # becomes
  #
  # foo || foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#129
  def visit_local_variable_or_write_node(node); end

  private

  # Desugar `x &&= y` to `x && x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#145
  def desugar_and_write_node(node, read_class, write_class, *arguments); end

  # Desugar `x += y` to `x = x + y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#155
  def desugar_operator_write_node(node, read_class, write_class, *arguments); end

  # Desugar `x ||= y` to `defined?(x) ? x : x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#187
  def desugar_or_write_defined_node(node, read_class, write_class, *arguments); end

  # Desugar `x ||= y` to `x || x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#177
  def desugar_or_write_node(node, read_class, write_class, *arguments); end
end

# The dispatcher class fires events for nodes that are found while walking an
# AST to all registered listeners. It's useful for performing different types
# of analysis on the AST while only having to walk the tree once.
#
# To use the dispatcher, you would first instantiate it and register listeners
# for the events you're interested in:
#
#     class OctalListener
#       def on_integer_node_enter(node)
#         if node.octal? && !node.slice.start_with?("0o")
#           warn("Octal integers should be written with the 0o prefix")
#         end
#       end
#     end
#
#     dispatcher = Dispatcher.new
#     dispatcher.register(listener, :on_integer_node_enter)
#
# Then, you can walk any number of trees and dispatch events to the listeners:
#
#     result = Prism.parse("001 + 002 + 003")
#     dispatcher.dispatch(result.value)
#
# Optionally, you can also use `#dispatch_once` to dispatch enter and leave
# events for a single node without recursing further down the tree. This can
# be useful in circumstances where you want to reuse the listeners you already
# have registers but want to stop walking the tree at a certain point.
#
#     integer = result.value.statements.body.first.receiver.receiver
#     dispatcher.dispatch_once(integer)
#
# source://prism//lib/prism/dispatcher.rb#40
class Prism::Dispatcher < ::Prism::Visitor
  # Initialize a new dispatcher.
  #
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://prism//lib/prism/dispatcher.rb#45
  def initialize; end

  # Walks `root` dispatching events to all registered listeners.
  #
  # def dispatch: (Node) -> void
  #
  # source://prism//lib/prism/visitor.rb#16
  def dispatch(node); end

  # Dispatches a single event for `node` to all registered listeners.
  #
  # def dispatch_once: (Node) -> void
  #
  # source://prism//lib/prism/dispatcher.rb#64
  def dispatch_once(node); end

  # attr_reader listeners: Hash[Symbol, Array[Listener]]
  #
  # source://prism//lib/prism/dispatcher.rb#42
  def listeners; end

  # Register a listener for one or more events.
  #
  # def register: (Listener, *Symbol) -> void
  #
  # source://prism//lib/prism/dispatcher.rb#52
  def register(listener, *events); end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#70
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#78
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#86
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#94
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#102
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#110
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#118
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#126
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#134
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#142
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#150
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#158
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#166
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#174
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#182
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#190
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#198
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#206
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#214
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#222
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#230
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#238
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#246
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#254
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#262
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#270
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#278
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#286
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#294
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#302
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#310
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#318
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#326
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#334
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#342
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#350
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#358
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#366
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#374
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#382
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#390
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#398
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#406
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#414
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#422
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#430
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#438
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#446
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#454
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#462
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#470
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#478
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#486
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#494
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#502
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#510
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#518
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#526
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#534
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#542
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#550
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#558
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#566
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#574
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#582
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#590
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#598
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#606
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for InNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#614
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#622
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#630
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#638
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#646
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#654
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#662
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#670
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#678
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#686
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#694
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#702
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#710
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#718
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#726
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#734
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#742
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#750
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#758
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#766
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#774
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#782
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#790
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#798
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#806
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#814
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#822
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#830
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#838
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#846
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#854
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#862
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#870
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#878
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#886
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#894
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#902
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#910
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#918
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#926
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#934
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#942
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#950
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#958
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#966
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#974
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#982
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#990
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#998
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1006
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1014
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1022
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1030
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1038
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1046
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1054
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1062
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1070
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1078
  def visit_self_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1086
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1094
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1102
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1110
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1118
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1126
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1134
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1142
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1150
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1158
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1166
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1174
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1182
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1190
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1198
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1206
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1214
  def visit_yield_node(node); end
end

# source://prism//lib/prism/dispatcher.rb#1220
class Prism::Dispatcher::DispatchOnce < ::Prism::Visitor
  # @return [DispatchOnce] a new instance of DispatchOnce
  #
  # source://prism//lib/prism/dispatcher.rb#1223
  def initialize(listeners); end

  # Returns the value of attribute listeners.
  #
  # source://prism//lib/prism/dispatcher.rb#1221
  def listeners; end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1228
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1234
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1240
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1246
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1252
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1258
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1264
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1270
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1276
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1282
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1288
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1294
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1300
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1306
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1312
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1318
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1324
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1330
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1336
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1342
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1348
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1354
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1360
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1366
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1372
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1378
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1384
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1390
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1396
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1402
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1408
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1414
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1420
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1426
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1432
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1438
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1444
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1450
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1456
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1462
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1468
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1474
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1480
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1486
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1492
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1498
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1504
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1510
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1516
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1522
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1528
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1534
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1540
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1546
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1552
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1558
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1564
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1570
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1576
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1582
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1588
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1594
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1600
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1606
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1612
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1618
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1624
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1630
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for InNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1636
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1642
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1648
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1654
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1660
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1666
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1672
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1678
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1684
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1690
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1696
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1702
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1708
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1714
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1720
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1726
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1732
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1738
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1744
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1750
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1756
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1762
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1768
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1774
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1780
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1786
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1792
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1798
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1804
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1810
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1816
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1822
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1828
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1834
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1840
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1846
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1852
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1858
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1864
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1870
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1876
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1882
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1888
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1894
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1900
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1906
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1912
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1918
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1924
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1930
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1936
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1942
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1948
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1954
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1960
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1966
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1972
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1978
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1984
  def visit_self_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1990
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1996
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2002
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2008
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2014
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2020
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2026
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2032
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2038
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2044
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2050
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2056
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2062
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2068
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2074
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2080
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2086
  def visit_yield_node(node); end
end

# This visitor provides the ability to call Node#to_dot, which converts a
# subtree into a graphviz dot graph.
#
# source://prism//lib/prism/dot_visitor.rb#13
class Prism::DotVisitor < ::Prism::Visitor
  # Initialize a new dot visitor.
  #
  # @return [DotVisitor] a new instance of DotVisitor
  #
  # source://prism//lib/prism/dot_visitor.rb#105
  def initialize; end

  # The digraph that is being built.
  #
  # source://prism//lib/prism/dot_visitor.rb#102
  def digraph; end

  # Convert this visitor into a graphviz dot graph string.
  #
  # source://prism//lib/prism/dot_visitor.rb#110
  def to_dot; end

  # Visit a AliasGlobalVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#115
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#140
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#165
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#190
  def visit_and_node(node); end

  # Visit a ArgumentsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#215
  def visit_arguments_node(node); end

  # Visit a ArrayNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#241
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#274
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#328
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#357
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#380
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#397
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#445
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#468
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#485
  def visit_block_node(node); end

  # Visit a BlockParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#520
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#545
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#584
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#607
  def visit_call_and_write_node(node); end

  # Visit a CallNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#653
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#711
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#760
  def visit_call_or_write_node(node); end

  # Visit a CapturePatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#806
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#831
  def visit_case_match_node(node); end

  # Visit a CaseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#872
  def visit_case_node(node); end

  # Visit a ClassNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#913
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#960
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#987
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1017
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1044
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1061
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1078
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1107
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1134
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1164
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1191
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1216
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1243
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1271
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1296
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1323
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1348
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1365
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1382
  def visit_constant_write_node(node); end

  # Visit a DefNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1409
  def visit_def_node(node); end

  # Visit a DefinedNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1478
  def visit_defined_node(node); end

  # Visit a ElseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1509
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1537
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1563
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1584
  def visit_ensure_node(node); end

  # Visit a FalseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1610
  def visit_false_node(node); end

  # Visit a FindPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1624
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1671
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1703
  def visit_float_node(node); end

  # Visit a ForNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1717
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1759
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1773
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1787
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1807
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1834
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1864
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1891
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1908
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1925
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1952
  def visit_hash_node(node); end

  # Visit a HashPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1981
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2026
  def visit_if_node(node); end

  # Visit a ImaginaryNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2071
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2089
  def visit_implicit_node(node); end

  # Visit a InNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2107
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2139
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2192
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2248
  def visit_index_or_write_node(node); end

  # Visit a InstanceVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2301
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2328
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2358
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2385
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2402
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2419
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2446
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2463
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2495
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2527
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2560
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2593
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2622
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2645
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2670
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2708
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2738
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2771
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2801
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2821
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2841
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2871
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2900
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2925
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2950
  def visit_match_write_node(node); end

  # Visit a MissingNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2977
  def visit_missing_node(node); end

  # Visit a ModuleNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2991
  def visit_module_node(node); end

  # Visit a MultiTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3027
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3075
  def visit_multi_write_node(node); end

  # Visit a NextNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3130
  def visit_next_node(node); end

  # Visit a NilNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3153
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3167
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedReferenceReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3187
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3204
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3228
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3255
  def visit_or_node(node); end

  # Visit a ParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3280
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3348
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3374
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3401
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3422
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3451
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3480
  def visit_program_node(node); end

  # Visit a RangeNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3501
  def visit_range_node(node); end

  # Visit a RationalNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3533
  def visit_rational_node(node); end

  # Visit a RedoNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3551
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3565
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3594
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3614
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3631
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3656
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3705
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3730
  def visit_retry_node(node); end

  # Visit a ReturnNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3744
  def visit_return_node(node); end

  # Visit a SelfNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3767
  def visit_self_node(node); end

  # Visit a SingletonClassNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3781
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3817
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3831
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3848
  def visit_source_line_node(node); end

  # Visit a SplatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3862
  def visit_splat_node(node); end

  # Visit a StatementsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3885
  def visit_statements_node(node); end

  # Visit a StringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3908
  def visit_string_node(node); end

  # Visit a SuperNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3941
  def visit_super_node(node); end

  # Visit a SymbolNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3980
  def visit_symbol_node(node); end

  # Visit a TrueNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4012
  def visit_true_node(node); end

  # Visit a UndefNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4026
  def visit_undef_node(node); end

  # Visit a UnlessNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4052
  def visit_unless_node(node); end

  # Visit a UntilNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4095
  def visit_until_node(node); end

  # Visit a WhenNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4130
  def visit_when_node(node); end

  # Visit a WhileNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4162
  def visit_while_node(node); end

  # Visit a XStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4197
  def visit_x_string_node(node); end

  # Visit a YieldNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4223
  def visit_yield_node(node); end

  private

  # Inspect a node that has arguments_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4269
  def arguments_node_flags_inspect(node); end

  # Inspect a node that has call_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4277
  def call_node_flags_inspect(node); end

  # Inspect a node that has integer_base_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4286
  def integer_base_flags_inspect(node); end

  # Inspect a location to display the start and end line and column numbers.
  #
  # source://prism//lib/prism/dot_visitor.rb#4263
  def location_inspect(location); end

  # Inspect a node that has loop_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4297
  def loop_flags_inspect(node); end

  # Generate a unique node ID for a node throughout the digraph.
  #
  # source://prism//lib/prism/dot_visitor.rb#4258
  def node_id(node); end

  # Inspect a node that has range_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4305
  def range_flags_inspect(node); end

  # Inspect a node that has regular_expression_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4313
  def regular_expression_flags_inspect(node); end

  # Inspect a node that has string_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4328
  def string_flags_inspect(node); end
end

# source://prism//lib/prism/dot_visitor.rb#58
class Prism::DotVisitor::Digraph
  # @return [Digraph] a new instance of Digraph
  #
  # source://prism//lib/prism/dot_visitor.rb#61
  def initialize; end

  # source://prism//lib/prism/dot_visitor.rb#75
  def edge(value); end

  # Returns the value of attribute edges.
  #
  # source://prism//lib/prism/dot_visitor.rb#59
  def edges; end

  # source://prism//lib/prism/dot_visitor.rb#67
  def node(value); end

  # Returns the value of attribute nodes.
  #
  # source://prism//lib/prism/dot_visitor.rb#59
  def nodes; end

  # source://prism//lib/prism/dot_visitor.rb#79
  def to_dot; end

  # source://prism//lib/prism/dot_visitor.rb#71
  def waypoint(value); end

  # Returns the value of attribute waypoints.
  #
  # source://prism//lib/prism/dot_visitor.rb#59
  def waypoints; end
end

# source://prism//lib/prism/dot_visitor.rb#14
class Prism::DotVisitor::Field
  # @return [Field] a new instance of Field
  #
  # source://prism//lib/prism/dot_visitor.rb#17
  def initialize(name, value, port); end

  # Returns the value of attribute name.
  #
  # source://prism//lib/prism/dot_visitor.rb#15
  def name; end

  # Returns the value of attribute port.
  #
  # source://prism//lib/prism/dot_visitor.rb#15
  def port; end

  # source://prism//lib/prism/dot_visitor.rb#23
  def to_dot; end

  # Returns the value of attribute value.
  #
  # source://prism//lib/prism/dot_visitor.rb#15
  def value; end
end

# source://prism//lib/prism/dot_visitor.rb#32
class Prism::DotVisitor::Table
  # @return [Table] a new instance of Table
  #
  # source://prism//lib/prism/dot_visitor.rb#35
  def initialize(name); end

  # source://prism//lib/prism/dot_visitor.rb#40
  def field(name, value = T.unsafe(nil), port: T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # source://prism//lib/prism/dot_visitor.rb#33
  def fields; end

  # Returns the value of attribute name.
  #
  # source://prism//lib/prism/dot_visitor.rb#33
  def name; end

  # source://prism//lib/prism/dot_visitor.rb#44
  def to_dot; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5375
class Prism::ElseNode < ::Prism::Node
  # def initialize: (else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # source://prism//lib/prism/node.rb#5386
  sig do
    params(
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5394
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5399
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5411
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5404
  def compact_child_nodes; end

  # def copy: (**params) -> ElseNode
  #
  # source://prism//lib/prism/node.rb#5416
  sig { params(params: T.untyped).returns(Prism::ElseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5399
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5429
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5434
  sig { returns(String) }
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5377
  sig { returns(Prism::Location) }
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#5439
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5383
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5444
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#5380
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5471
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5481
    def type; end
  end
end

# EmbDocComment objects correspond to comments that are surrounded by =begin
# and =end.
#
# source://prism//lib/prism/parse_result.rb#265
class Prism::EmbDocComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism//lib/prism/parse_result.rb#267
  def inspect; end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# source://prism//lib/prism/node.rb#5490
class Prism::EmbeddedStatementsNode < ::Prism::Node
  # def initialize: (opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location) -> void
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # source://prism//lib/prism/node.rb#5501
  sig do
    params(
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, statements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5509
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5514
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#5554
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#5498
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5526
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5519
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedStatementsNode
  #
  # source://prism//lib/prism/node.rb#5531
  sig { params(params: T.untyped).returns(Prism::EmbeddedStatementsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5514
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5544
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5559
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#5549
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#5492
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#5495
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5586
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5596
    def type; end
  end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# source://prism//lib/prism/node.rb#5605
class Prism::EmbeddedVariableNode < ::Prism::Node
  # def initialize: (operator_loc: Location, variable: Node, location: Location) -> void
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # source://prism//lib/prism/node.rb#5613
  sig { params(operator_loc: Prism::Location, variable: Prism::Node, location: Prism::Location).void }
  def initialize(operator_loc, variable, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5620
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5625
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5635
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5630
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedVariableNode
  #
  # source://prism//lib/prism/node.rb#5640
  sig { params(params: T.untyped).returns(Prism::EmbeddedVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5625
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5652
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5662
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#5657
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#5607
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5684
  def type; end

  # attr_reader variable: Node
  #
  # source://prism//lib/prism/node.rb#5610
  sig { returns(Prism::Node) }
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5694
    def type; end
  end
end

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# source://prism//lib/prism/node.rb#5707
class Prism::EnsureNode < ::Prism::Node
  # def initialize: (ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # source://prism//lib/prism/node.rb#5718
  sig do
    params(
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5726
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5731
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5743
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5736
  def compact_child_nodes; end

  # def copy: (**params) -> EnsureNode
  #
  # source://prism//lib/prism/node.rb#5748
  sig { params(params: T.untyped).returns(Prism::EnsureNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5731
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5761
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5771
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5715
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5766
  sig { returns(String) }
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5709
  sig { returns(Prism::Location) }
  def ensure_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5776
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#5712
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5803
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5813
    def type; end
  end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# source://prism//lib/prism/node.rb#5822
class Prism::FalseNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # source://prism//lib/prism/node.rb#5824
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5829
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5834
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5844
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5839
  def compact_child_nodes; end

  # def copy: (**params) -> FalseNode
  #
  # source://prism//lib/prism/node.rb#5849
  sig { params(params: T.untyped).returns(Prism::FalseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5834
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5859
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5864
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5883
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5893
    def type; end
  end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#            ^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#            ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5908
class Prism::FindPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # source://prism//lib/prism/node.rb#5928
  sig do
    params(
      constant: T.nilable(Prism::Node),
      left: Prism::Node,
      requireds: T::Array[Prism::Node],
      right: Prism::Node,
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5939
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5944
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#5990
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5925
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5959
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5949
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism//lib/prism/node.rb#5910
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> FindPatternNode
  #
  # source://prism//lib/prism/node.rb#5964
  sig { params(params: T.untyped).returns(Prism::FindPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5944
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#5980
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#5995
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism//lib/prism/node.rb#5913
  sig { returns(Prism::Node) }
  def left; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#5985
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5922
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism//lib/prism/node.rb#5916
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader right: Node
  #
  # source://prism//lib/prism/node.rb#5919
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6027
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6037
    def type; end
  end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6046
class Prism::FlipFlopNode < ::Prism::Node
  # def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [FlipFlopNode] a new instance of FlipFlopNode
  #
  # source://prism//lib/prism/node.rb#6060
  sig do
    params(
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(left, right, operator_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6069
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6074
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6087
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6079
  def compact_child_nodes; end

  # def copy: (**params) -> FlipFlopNode
  #
  # source://prism//lib/prism/node.rb#6092
  sig { params(params: T.untyped).returns(Prism::FlipFlopNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6074
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6106
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#6116
  sig { returns(T::Boolean) }
  def exclude_end?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6121
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node?
  #
  # source://prism//lib/prism/node.rb#6048
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#6111
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6054
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://prism//lib/prism/node.rb#6051
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6155
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#6057
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6165
    def type; end
  end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# source://prism//lib/prism/node.rb#6174
class Prism::FloatNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # source://prism//lib/prism/node.rb#6176
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6181
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6186
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6196
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6191
  def compact_child_nodes; end

  # def copy: (**params) -> FloatNode
  #
  # source://prism//lib/prism/node.rb#6201
  sig { params(params: T.untyped).returns(Prism::FloatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6186
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6211
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6216
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6235
  def type; end

  # Returns the value of the node as a Ruby Float.
  #
  # source://prism//lib/prism/node_ext.rb#21
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6245
    def type; end
  end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6254
class Prism::ForNode < ::Prism::Node
  # def initialize: (index: Node, collection: Node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [ForNode] a new instance of ForNode
  #
  # source://prism//lib/prism/node.rb#6277
  sig do
    params(
      index: Prism::Node,
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6289
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6294
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # attr_reader collection: Node
  #
  # source://prism//lib/prism/node.rb#6259
  sig { returns(Prism::Node) }
  def collection; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6308
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6299
  def compact_child_nodes; end

  # def copy: (**params) -> ForNode
  #
  # source://prism//lib/prism/node.rb#6313
  sig { params(params: T.untyped).returns(Prism::ForNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6294
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6330
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#6345
  sig { returns(T.nilable(String)) }
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#6271
  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6350
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6274
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def for_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6335
  sig { returns(String) }
  def for_keyword; end

  # attr_reader for_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6265
  sig { returns(Prism::Location) }
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6340
  sig { returns(String) }
  def in_keyword; end

  # attr_reader in_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6268
  sig { returns(Prism::Location) }
  def in_keyword_loc; end

  # attr_reader index: Node
  #
  # source://prism//lib/prism/node.rb#6256
  sig { returns(Prism::Node) }
  def index; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6355
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#6262
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6388
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6398
    def type; end
  end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#           ^^^
#     end
#
# source://prism//lib/prism/node.rb#6409
class Prism::ForwardingArgumentsNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # source://prism//lib/prism/node.rb#6411
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6416
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6421
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6431
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6426
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingArgumentsNode
  #
  # source://prism//lib/prism/node.rb#6436
  sig { params(params: T.untyped).returns(Prism::ForwardingArgumentsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6421
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6446
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6451
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6470
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6480
    def type; end
  end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# source://prism//lib/prism/node.rb#6490
class Prism::ForwardingParameterNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # source://prism//lib/prism/node.rb#6492
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6497
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6502
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6512
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6507
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingParameterNode
  #
  # source://prism//lib/prism/node.rb#6517
  sig { params(params: T.untyped).returns(Prism::ForwardingParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6502
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6527
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6532
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6551
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6561
    def type; end
  end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
#
# source://prism//lib/prism/node.rb#6570
class Prism::ForwardingSuperNode < ::Prism::Node
  # def initialize: (block: BlockNode?, location: Location) -> void
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # source://prism//lib/prism/node.rb#6575
  sig { params(block: T.nilable(Prism::BlockNode), location: Prism::Location).void }
  def initialize(block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6581
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader block: BlockNode?
  #
  # source://prism//lib/prism/node.rb#6572
  sig { returns(T.nilable(Prism::BlockNode)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6586
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6598
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6591
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingSuperNode
  #
  # source://prism//lib/prism/node.rb#6603
  sig { params(params: T.untyped).returns(Prism::ForwardingSuperNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6586
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6614
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6619
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6644
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6654
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6663
class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableAndWriteNode] a new instance of GlobalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#6677
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6686
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6691
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6701
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6696
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#6706
  sig { params(params: T.untyped).returns(Prism::GlobalVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6691
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6720
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6730
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#6665
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#6668
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#6725
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6671
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6754
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#6674
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6764
    def type; end
  end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6773
class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#6790
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6800
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6805
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6815
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6810
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#6820
  sig { params(params: T.untyped).returns(Prism::GlobalVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6805
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6835
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6840
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#6775
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#6778
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#6787
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6781
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6865
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#6784
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6875
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6884
class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableOrWriteNode] a new instance of GlobalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#6898
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6907
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6912
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6922
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6917
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#6927
  sig { params(params: T.untyped).returns(Prism::GlobalVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6912
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#6941
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#6951
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#6886
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#6889
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#6946
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6892
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6975
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#6895
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6985
    def type; end
  end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# source://prism//lib/prism/node.rb#6994
class Prism::GlobalVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#6999
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7005
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7010
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7020
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7015
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#7025
  sig { params(params: T.untyped).returns(Prism::GlobalVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7010
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7036
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7041
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#6996
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7061
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7071
    def type; end
  end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
#
# source://prism//lib/prism/node.rb#7080
class Prism::GlobalVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableTargetNode] a new instance of GlobalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#7085
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7091
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7106
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7101
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#7111
  sig { params(params: T.untyped).returns(Prism::GlobalVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7122
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7127
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7082
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7147
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7157
    def type; end
  end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#7166
class Prism::GlobalVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#7180
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7189
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7204
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7199
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#7209
  sig { params(params: T.untyped).returns(Prism::GlobalVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7223
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7233
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7168
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#7171
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#7228
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#7177
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7257
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#7174
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7267
    def type; end
  end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7276
class Prism::HashNode < ::Prism::Node
  # def initialize: (opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [HashNode] a new instance of HashNode
  #
  # source://prism//lib/prism/node.rb#7287
  sig do
    params(
      opening_loc: Prism::Location,
      elements: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, elements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7295
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7300
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#7338
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#7284
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7310
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7305
  def compact_child_nodes; end

  # def copy: (**params) -> HashNode
  #
  # source://prism//lib/prism/node.rb#7315
  sig { params(params: T.untyped).returns(Prism::HashNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7300
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7328
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism//lib/prism/node.rb#7281
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7343
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#7333
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#7278
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7365
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7375
    def type; end
  end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7387
class Prism::HashPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, elements: Array[Node], rest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # source://prism//lib/prism/node.rb#7404
  sig do
    params(
      constant: T.nilable(Prism::Node),
      elements: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, elements, rest, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7414
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7419
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#7463
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7401
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7433
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7424
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism//lib/prism/node.rb#7389
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> HashPatternNode
  #
  # source://prism//lib/prism/node.rb#7438
  sig { params(params: T.untyped).returns(Prism::HashPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7419
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7453
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism//lib/prism/node.rb#7392
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7468
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#7458
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7398
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader rest: Node?
  #
  # source://prism//lib/prism/node.rb#7395
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7502
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7512
    def type; end
  end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7524
class Prism::IfNode < ::Prism::Node
  # def initialize: (if_keyword_loc: Location?, predicate: Node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [IfNode] a new instance of IfNode
  #
  # source://prism//lib/prism/node.rb#7544
  sig do
    params(
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::Node),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7555
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7564
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7578
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7569
  def compact_child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://prism//lib/prism/node.rb#7538
  sig { returns(T.nilable(Prism::Node)) }
  def consequent; end

  # def copy: (**params) -> IfNode
  #
  # source://prism//lib/prism/node.rb#7583
  sig { params(params: T.untyped).returns(Prism::IfNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7564
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7599
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#7614
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7541
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def if_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#7604
  sig { returns(T.nilable(String)) }
  def if_keyword; end

  # attr_reader if_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7526
  sig { returns(T.nilable(Prism::Location)) }
  def if_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7619
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node
  #
  # source://prism//lib/prism/node.rb#7529
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism//lib/prism/node.rb#7559
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#7535
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#7609
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7532
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7655
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7665
    def type; end
  end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# source://prism//lib/prism/node.rb#7674
class Prism::ImaginaryNode < ::Prism::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # source://prism//lib/prism/node.rb#7679
  sig { params(numeric: Prism::Node, location: Prism::Location).void }
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7685
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7690
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7700
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7695
  def compact_child_nodes; end

  # def copy: (**params) -> ImaginaryNode
  #
  # source://prism//lib/prism/node.rb#7705
  sig { params(params: T.untyped).returns(Prism::ImaginaryNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7690
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7716
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7721
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism//lib/prism/node.rb#7676
  sig { returns(Prism::Node) }
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7742
  def type; end

  # Returns the value of the node as a Ruby Complex.
  #
  # source://prism//lib/prism/node_ext.rb#28
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7752
    def type; end
  end
end

# Represents a node that is implicitly being added to the tree but doesn't
# correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
# source://prism//lib/prism/node.rb#7765
class Prism::ImplicitNode < ::Prism::Node
  # def initialize: (value: Node, location: Location) -> void
  #
  # @return [ImplicitNode] a new instance of ImplicitNode
  #
  # source://prism//lib/prism/node.rb#7770
  sig { params(value: Prism::Node, location: Prism::Location).void }
  def initialize(value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7776
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7781
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7791
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7786
  def compact_child_nodes; end

  # def copy: (**params) -> ImplicitNode
  #
  # source://prism//lib/prism/node.rb#7796
  sig { params(params: T.untyped).returns(Prism::ImplicitNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7781
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7807
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7812
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7833
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#7767
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7843
    def type; end
  end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7852
class Prism::InNode < ::Prism::Node
  # def initialize: (pattern: Node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location) -> void
  #
  # @return [InNode] a new instance of InNode
  #
  # source://prism//lib/prism/node.rb#7866
  sig do
    params(
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(pattern, statements, in_loc, then_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7875
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7880
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7893
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7885
  def compact_child_nodes; end

  # def copy: (**params) -> InNode
  #
  # source://prism//lib/prism/node.rb#7898
  sig { params(params: T.untyped).returns(Prism::InNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7880
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#7912
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def in: () -> String
  #
  # source://prism//lib/prism/node.rb#7917
  sig { returns(String) }
  def in; end

  # attr_reader in_loc: Location
  #
  # source://prism//lib/prism/node.rb#7860
  sig { returns(Prism::Location) }
  def in_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#7927
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader pattern: Node
  #
  # source://prism//lib/prism/node.rb#7854
  sig { returns(Prism::Node) }
  def pattern; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#7857
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then: () -> String?
  #
  # source://prism//lib/prism/node.rb#7922
  sig { returns(T.nilable(String)) }
  def then; end

  # attr_reader then_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7863
  sig { returns(T.nilable(Prism::Location)) }
  def then_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7956
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7966
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call to the `[]` method.
#
#     foo.bar[baz] &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7975
class Prism::IndexAndWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [IndexAndWriteNode] a new instance of IndexAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8004
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      flags: Integer,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8018
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#7986
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism//lib/prism/node.rb#7992
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#8067
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7980
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8023
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#8077
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#7989
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8038
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8028
  def compact_child_nodes; end

  # def copy: (**params) -> IndexAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8043
  sig { params(params: T.untyped).returns(Prism::IndexAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8023
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8062
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8097
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#8072
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#7983
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#8092
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#7998
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#7977
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8082
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8142
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8001
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8087
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#7995
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8152
    def type; end
  end
end

# Represents the use of an assignment operator on a call to `[]`.
#
#     foo.bar[baz] += value
#     ^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8161
class Prism::IndexOperatorWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [IndexOperatorWriteNode] a new instance of IndexOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#8193
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      flags: Integer,
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8208
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#8172
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism//lib/prism/node.rb#8178
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#8258
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8166
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8213
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#8268
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#8175
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8228
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8218
  def compact_child_nodes; end

  # def copy: (**params) -> IndexOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#8233
  sig { params(params: T.untyped).returns(Prism::IndexOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8213
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8253
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8283
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#8263
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#8169
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#8184
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8187
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#8163
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8273
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8329
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8190
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8278
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#8181
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8339
    def type; end
  end
end

# Represents the use of the `||=` operator on a call to `[]`.
#
#     foo.bar[baz] ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8348
class Prism::IndexOrWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [IndexOrWriteNode] a new instance of IndexOrWriteNode
  #
  # source://prism//lib/prism/node.rb#8377
  sig do
    params(
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      flags: Integer,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, flags, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8391
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#8359
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism//lib/prism/node.rb#8365
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#8440
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8353
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8396
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#8450
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#8362
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8411
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8401
  def compact_child_nodes; end

  # def copy: (**params) -> IndexOrWriteNode
  #
  # source://prism//lib/prism/node.rb#8416
  sig { params(params: T.untyped).returns(Prism::IndexOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8396
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8435
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8470
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#8445
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#8356
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#8465
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8371
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism//lib/prism/node.rb#8350
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8455
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8515
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8374
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#8460
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#8368
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8525
    def type; end
  end
end

# InlineComment objects are the most common. They correspond to comments in
# the source file like this one that start with #.
#
# source://prism//lib/prism/parse_result.rb#250
class Prism::InlineComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism//lib/prism/parse_result.rb#258
  def inspect; end

  # Returns true if this comment happens on the same line as other code and
  # false if the comment is by itself.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#253
  sig { override.returns(T::Boolean) }
  def trailing?; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8534
class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableAndWriteNode] a new instance of InstanceVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8548
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8557
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8562
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8572
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8567
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8577
  sig { params(params: T.untyped).returns(Prism::InstanceVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8562
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8591
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8601
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#8536
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#8539
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#8596
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8542
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8625
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8545
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8635
    def type; end
  end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8644
class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#8661
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8671
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8676
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8686
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8681
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#8691
  sig { params(params: T.untyped).returns(Prism::InstanceVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8676
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8706
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8711
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#8646
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#8649
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#8658
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8652
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8736
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8655
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8746
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8755
class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableOrWriteNode] a new instance of InstanceVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#8769
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8778
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8783
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8793
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8788
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#8798
  sig { params(params: T.untyped).returns(Prism::InstanceVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8783
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8812
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8822
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#8757
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#8760
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#8817
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8763
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8846
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#8766
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8856
    def type; end
  end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# source://prism//lib/prism/node.rb#8865
class Prism::InstanceVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # source://prism//lib/prism/node.rb#8870
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8876
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8881
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8891
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8886
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableReadNode
  #
  # source://prism//lib/prism/node.rb#8896
  sig { params(params: T.untyped).returns(Prism::InstanceVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8881
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8907
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8912
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#8867
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8932
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8942
    def type; end
  end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
#
# source://prism//lib/prism/node.rb#8951
class Prism::InstanceVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableTargetNode] a new instance of InstanceVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#8956
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8962
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8967
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8977
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8972
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#8982
  sig { params(params: T.untyped).returns(Prism::InstanceVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8967
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#8993
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#8998
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#8953
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9018
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9028
    def type; end
  end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#9037
class Prism::InstanceVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#9051
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9060
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9065
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9075
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9070
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#9080
  sig { params(params: T.untyped).returns(Prism::InstanceVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9065
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9094
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9104
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#9039
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#9042
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#9099
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9048
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9128
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#9045
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9138
    def type; end
  end
end

# Flags for integer nodes that correspond to the base of the integer.
#
# source://prism//lib/prism/node.rb#16620
module Prism::IntegerBaseFlags; end

# 0b prefix
#
# source://prism//lib/prism/node.rb#16622
Prism::IntegerBaseFlags::BINARY = T.let(T.unsafe(nil), Integer)

# 0d or no prefix
#
# source://prism//lib/prism/node.rb#16628
Prism::IntegerBaseFlags::DECIMAL = T.let(T.unsafe(nil), Integer)

# 0x prefix
#
# source://prism//lib/prism/node.rb#16631
Prism::IntegerBaseFlags::HEXADECIMAL = T.let(T.unsafe(nil), Integer)

# 0o or 0 prefix
#
# source://prism//lib/prism/node.rb#16625
Prism::IntegerBaseFlags::OCTAL = T.let(T.unsafe(nil), Integer)

# Represents an integer number literal.
#
#     1
#     ^
#
# source://prism//lib/prism/node.rb#9147
class Prism::IntegerNode < ::Prism::Node
  # def initialize: (flags: Integer, location: Location) -> void
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # source://prism//lib/prism/node.rb#9152
  sig { params(flags: Integer, location: Prism::Location).void }
  def initialize(flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9158
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9194
  sig { returns(T::Boolean) }
  def binary?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9163
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9173
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9168
  def compact_child_nodes; end

  # def copy: (**params) -> IntegerNode
  #
  # source://prism//lib/prism/node.rb#9178
  sig { params(params: T.untyped).returns(Prism::IntegerNode) }
  def copy(**params); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9204
  sig { returns(T::Boolean) }
  def decimal?; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9163
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9189
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9209
  sig { returns(T::Boolean) }
  def hexadecimal?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9214
  def inspect(inspector = T.unsafe(nil)); end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9199
  sig { returns(T::Boolean) }
  def octal?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9235
  def type; end

  # Returns the value of the node as a Ruby Integer.
  #
  # source://prism//lib/prism/node_ext.rb#35
  def value; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#9149
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9245
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation that
# is being used in the predicate of a conditional to implicitly match
# against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9256
class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [InterpolatedMatchLastLineNode] a new instance of InterpolatedMatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#9270
  sig do
    params(
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9279
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9358
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9289
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9328
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9264
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9299
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9294
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedMatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#9304
  sig { params(params: T.untyped).returns(Prism::InterpolatedMatchLastLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9289
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9318
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9353
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9338
  sig { returns(T::Boolean) }
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9333
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9373
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9343
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9348
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9323
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9258
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9261
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism//lib/prism/node.rb#9283
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9397
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9368
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9363
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#9267
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9407
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9416
class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#9430
  sig do
    params(
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9439
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9518
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9449
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9488
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9424
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9459
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9454
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedRegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#9464
  sig { params(params: T.untyped).returns(Prism::InterpolatedRegularExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9449
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9478
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9513
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9498
  sig { returns(T::Boolean) }
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9493
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9533
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9503
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9508
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9483
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9418
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9421
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism//lib/prism/node.rb#9443
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9557
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9528
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9523
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#9427
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9567
    def type; end
  end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9576
class Prism::InterpolatedStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # source://prism//lib/prism/node.rb#9587
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9595
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9605
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#9643
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9584
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9615
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9610
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedStringNode
  #
  # source://prism//lib/prism/node.rb#9620
  sig { params(params: T.untyped).returns(Prism::InterpolatedStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9605
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9633
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9648
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#9638
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9578
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9581
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism//lib/prism/node.rb#9599
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9670
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9680
    def type; end
  end
end

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9689
class Prism::InterpolatedSymbolNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # source://prism//lib/prism/node.rb#9700
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9708
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9718
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#9756
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9697
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9728
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9723
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedSymbolNode
  #
  # source://prism//lib/prism/node.rb#9733
  sig { params(params: T.untyped).returns(Prism::InterpolatedSymbolNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9718
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9746
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9761
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#9751
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9691
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9694
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism//lib/prism/node.rb#9712
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9783
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9793
    def type; end
  end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9802
class Prism::InterpolatedXStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # source://prism//lib/prism/node.rb#9813
  sig do
    params(
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9821
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9831
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9869
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9810
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9841
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9836
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedXStringNode
  #
  # source://prism//lib/prism/node.rb#9846
  sig { params(params: T.untyped).returns(Prism::InterpolatedXStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9831
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9859
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9874
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9864
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9804
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9807
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism//lib/prism/node.rb#9825
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9896
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9906
    def type; end
  end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# source://prism//lib/prism/node.rb#9915
class Prism::KeywordHashNode < ::Prism::Node
  # def initialize: (elements: Array[Node], location: Location) -> void
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # source://prism//lib/prism/node.rb#9920
  sig { params(elements: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(elements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9926
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9931
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9941
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9936
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordHashNode
  #
  # source://prism//lib/prism/node.rb#9946
  sig { params(params: T.untyped).returns(Prism::KeywordHashNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9931
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#9957
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism//lib/prism/node.rb#9917
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#9962
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9982
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9992
    def type; end
  end
end

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# source://prism//lib/prism/node.rb#10002
class Prism::KeywordRestParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # source://prism//lib/prism/node.rb#10013
  sig do
    params(
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10021
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10026
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10036
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10031
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordRestParameterNode
  #
  # source://prism//lib/prism/node.rb#10041
  sig { params(params: T.untyped).returns(Prism::KeywordRestParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10026
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10054
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10064
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#10004
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#10007
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10059
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10010
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10090
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10100
    def type; end
  end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10109
class Prism::LambdaNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode?, body: Node?, location: Location) -> void
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # source://prism//lib/prism/node.rb#10129
  sig do
    params(
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(Prism::BlockParametersNode),
      body: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10140
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#10126
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10145
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#10194
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#10120
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10158
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10150
  def compact_child_nodes; end

  # def copy: (**params) -> LambdaNode
  #
  # source://prism//lib/prism/node.rb#10163
  sig { params(params: T.untyped).returns(Prism::LambdaNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10145
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10179
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10199
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#10111
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#10189
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#10117
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10184
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10114
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader parameters: BlockParametersNode?
  #
  # source://prism//lib/prism/node.rb#10123
  sig { returns(T.nilable(Prism::BlockParametersNode)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10234
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10244
    def type; end
  end
end

# This class is responsible for lexing the source using prism and then
# converting those tokens to be compatible with Ripper. In the vast majority
# of cases, this is a one-to-one mapping of the token type. Everything else
# generally lines up. However, there are a few cases that require special
# handling.
#
# source://prism//lib/prism/lex_compat.rb#11
class Prism::LexCompat
  # @return [LexCompat] a new instance of LexCompat
  #
  # source://prism//lib/prism/lex_compat.rb#599
  def initialize(source, **options); end

  # Returns the value of attribute options.
  #
  # source://prism//lib/prism/lex_compat.rb#597
  def options; end

  # source://prism//lib/prism/lex_compat.rb#604
  def result; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/lex_compat.rb#597
  def source; end
end

# Ripper doesn't include the rest of the token in the event, so we need to
# trim it down to just the content on the first line when comparing.
#
# source://prism//lib/prism/lex_compat.rb#210
class Prism::LexCompat::EndContentToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#211
  def ==(other); end
end

# A heredoc in this case is a list of tokens that belong to the body of the
# heredoc that should be appended onto the list of tokens when the heredoc
# closes.
#
# source://prism//lib/prism/lex_compat.rb#271
module Prism::LexCompat::Heredoc
  class << self
    # Here we will split between the two types of heredocs and return the
    # object that will store their tokens.
    #
    # source://prism//lib/prism/lex_compat.rb#583
    def build(opening); end
  end
end

# Dash heredocs are a little more complicated. They are a list of tokens
# that need to be split on "\\\n" to mimic Ripper's behavior. We also need
# to keep track of the state that the heredoc was opened in.
#
# source://prism//lib/prism/lex_compat.rb#295
class Prism::LexCompat::Heredoc::DashHeredoc
  # @return [DashHeredoc] a new instance of DashHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#298
  def initialize(split); end

  # source://prism//lib/prism/lex_compat.rb#303
  def <<(token); end

  # source://prism//lib/prism/lex_compat.rb#296
  def split; end

  # source://prism//lib/prism/lex_compat.rb#307
  def to_a; end

  # source://prism//lib/prism/lex_compat.rb#296
  def tokens; end
end

# Heredocs that are dedenting heredocs are a little more complicated.
# Ripper outputs on_ignored_sp tokens for the whitespace that is being
# removed from the output. prism only modifies the node itself and keeps
# the token the same. This simplifies prism, but makes comparing against
# Ripper much harder because there is a length mismatch.
#
# Fortunately, we already have to pull out the heredoc tokens in order to
# insert them into the stream in the correct order. As such, we can do
# some extra manipulation on the tokens to make them match Ripper's
# output by mirroring the dedent logic that Ripper uses.
#
# source://prism//lib/prism/lex_compat.rb#354
class Prism::LexCompat::Heredoc::DedentingHeredoc
  # @return [DedentingHeredoc] a new instance of DedentingHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#359
  def initialize; end

  # As tokens are coming in, we track the minimum amount of common leading
  # whitespace on plain string content tokens. This allows us to later
  # remove that amount of whitespace from the beginning of each line.
  #
  # source://prism//lib/prism/lex_compat.rb#370
  def <<(token); end

  # Returns the value of attribute dedent.
  #
  # source://prism//lib/prism/lex_compat.rb#357
  def dedent; end

  # Returns the value of attribute dedent_next.
  #
  # source://prism//lib/prism/lex_compat.rb#357
  def dedent_next; end

  # Returns the value of attribute embexpr_balance.
  #
  # source://prism//lib/prism/lex_compat.rb#357
  def embexpr_balance; end

  # source://prism//lib/prism/lex_compat.rb#407
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://prism//lib/prism/lex_compat.rb#357
  def tokens; end
end

# source://prism//lib/prism/lex_compat.rb#355
Prism::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# Heredocs that are no dash or tilde heredocs are just a list of tokens.
# We need to keep them around so that we can insert them in the correct
# order back into the token stream and set the state of the last token to
# the state that the heredoc was opened in.
#
# source://prism//lib/prism/lex_compat.rb#276
class Prism::LexCompat::Heredoc::PlainHeredoc
  # @return [PlainHeredoc] a new instance of PlainHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#279
  def initialize; end

  # source://prism//lib/prism/lex_compat.rb#283
  def <<(token); end

  # source://prism//lib/prism/lex_compat.rb#287
  def to_a; end

  # source://prism//lib/prism/lex_compat.rb#277
  def tokens; end
end

# Ident tokens for the most part are exactly the same, except sometimes we
# know an ident is a local when ripper doesn't (when they are introduced
# through named captures in regular expressions). In that case we don't
# compare the state.
#
# source://prism//lib/prism/lex_compat.rb#228
class Prism::LexCompat::IdentToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#229
  def ==(other); end
end

# Tokens where state should be ignored
# used for :on_comment, :on_heredoc_end, :on_embexpr_end
#
# source://prism//lib/prism/lex_compat.rb#218
class Prism::LexCompat::IgnoreStateToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#219
  def ==(other); end
end

# Ignored newlines can occasionally have a LABEL state attached to them, so
# we compare the state differently here.
#
# source://prism//lib/prism/lex_compat.rb#239
class Prism::LexCompat::IgnoredNewlineToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#240
  def ==(other); end
end

# If we have an identifier that follows a method name like:
#
#     def foo bar
#
# then Ripper will mark bar as END|LABEL if there is a local in a parent
# scope named bar because it hasn't pushed the local table yet. We do this
# more accurately, so we need to allow comparing against both END and
# END|LABEL.
#
# source://prism//lib/prism/lex_compat.rb#259
class Prism::LexCompat::ParamToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#260
  def ==(other); end
end

# This is a mapping of prism token types to Ripper token types. This is a
# many-to-one mapping because we split up our token types, whereas Ripper
# tends to group them.
#
# source://prism//lib/prism/lex_compat.rb#15
Prism::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

# When we produce tokens, we produce the same arrays that Ripper does.
# However, we add a couple of convenience methods onto them to make them a
# little easier to work with. We delegate all other methods to the array.
#
# source://prism//lib/prism/lex_compat.rb#186
class Prism::LexCompat::Token < ::SimpleDelegator
  # The type of the token.
  #
  # source://prism//lib/prism/lex_compat.rb#193
  def event; end

  # The location of the token in the source.
  #
  # source://prism//lib/prism/lex_compat.rb#188
  def location; end

  # The state of the lexer when this token was produced.
  #
  # source://prism//lib/prism/lex_compat.rb#203
  def state; end

  # The slice of the source that this token represents.
  #
  # source://prism//lib/prism/lex_compat.rb#198
  def value; end
end

# This is a class that wraps the Ripper lexer to produce almost exactly the
# same tokens.
#
# source://prism//lib/prism/lex_compat.rb#842
class Prism::LexRipper
  # @return [LexRipper] a new instance of LexRipper
  #
  # source://prism//lib/prism/lex_compat.rb#845
  def initialize(source); end

  # source://prism//lib/prism/lex_compat.rb#849
  def result; end

  # source://prism//lib/prism/lex_compat.rb#843
  def source; end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10253
class Prism::LocalVariableAndWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableAndWriteNode] a new instance of LocalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#10270
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10280
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10285
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10295
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10290
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#10300
  sig { params(params: T.untyped).returns(Prism::LocalVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10285
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10315
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10267
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10325
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10264
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#10255
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10320
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10258
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10350
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#10261
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10360
    def type; end
  end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10369
class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#10389
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      operator: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10400
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10405
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10415
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10410
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#10420
  sig { params(params: T.untyped).returns(Prism::LocalVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10405
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10436
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10386
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10441
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10380
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#10371
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#10383
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10374
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10467
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#10377
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10477
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10486
class Prism::LocalVariableOrWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableOrWriteNode] a new instance of LocalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#10503
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10513
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10518
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10528
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10523
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#10533
  sig { params(params: T.untyped).returns(Prism::LocalVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10518
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10548
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10500
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10558
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10497
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#10488
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10553
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10491
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10583
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#10494
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10593
    def type; end
  end
end

# Represents reading a local variable. Note that this requires that a local
# variable of the same name has already been written to in the same scope,
# otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# source://prism//lib/prism/node.rb#10604
class Prism::LocalVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#10612
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).void }
  def initialize(name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10619
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10624
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10634
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10629
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#10639
  sig { params(params: T.untyped).returns(Prism::LocalVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10624
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10651
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10609
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10656
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10606
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10677
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10687
    def type; end
  end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
#
# source://prism//lib/prism/node.rb#10696
class Prism::LocalVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableTargetNode] a new instance of LocalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#10704
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).void }
  def initialize(name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10711
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10716
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10726
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10721
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#10731
  sig { params(params: T.untyped).returns(Prism::LocalVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10716
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10743
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10701
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10748
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10698
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10769
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10779
    def type; end
  end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#10788
class Prism::LocalVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#10805
  sig do
    params(
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, depth, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10815
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10820
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10830
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10825
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#10835
  sig { params(params: T.untyped).returns(Prism::LocalVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10820
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10850
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#10793
  sig { returns(Integer) }
  def depth; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#10860
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10790
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#10796
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10855
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10802
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10885
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#10799
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10895
    def type; end
  end
end

# This represents a location in the source.
#
# source://prism//lib/prism/parse_result.rb#91
class Prism::Location
  # Create a new location object with the given source, start byte offset, and
  # byte length.
  #
  # @return [Location] a new instance of Location
  #
  # source://prism//lib/prism/parse_result.rb#108
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).void }
  def initialize(source, start_offset, length); end

  # Returns true if the given other location is equal to this location.
  #
  # source://prism//lib/prism/parse_result.rb#202
  def ==(other); end

  # The list of comments attached to this location
  #
  # source://prism//lib/prism/parse_result.rb#104
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # Create a new location object with the given options.
  #
  # source://prism//lib/prism/parse_result.rb#116
  sig { params(options: T.untyped).returns(Prism::Location) }
  def copy(**options); end

  # Implement the hash pattern matching interface for Location.
  #
  # source://prism//lib/prism/parse_result.rb#192
  def deconstruct_keys(keys); end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#187
  def end_character_column; end

  # The character offset from the beginning of the source where this location
  # ends.
  #
  # source://prism//lib/prism/parse_result.rb#147
  def end_character_offset; end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # source://prism//lib/prism/parse_result.rb#181
  sig { returns(Integer) }
  def end_column; end

  # The line number where this location ends.
  #
  # source://prism//lib/prism/parse_result.rb#163
  sig { returns(Integer) }
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # source://prism//lib/prism/parse_result.rb#141
  sig { returns(Integer) }
  def end_offset; end

  # Returns a string representation of this location.
  #
  # source://prism//lib/prism/parse_result.rb#125
  def inspect; end

  # Returns a new location that stretches from this location to the given
  # other location. Raises an error if this location is not before the other
  # location or if they don't share the same source.
  #
  # source://prism//lib/prism/parse_result.rb#211
  def join(other); end

  # The length of this location in bytes.
  #
  # source://prism//lib/prism/parse_result.rb#101
  def length; end

  # Implement the pretty print interface for Location.
  #
  # source://prism//lib/prism/parse_result.rb#197
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # source://prism//lib/prism/parse_result.rb#130
  sig { returns(String) }
  def slice; end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#175
  def start_character_column; end

  # The character offset from the beginning of the source where this location
  # starts.
  #
  # source://prism//lib/prism/parse_result.rb#136
  def start_character_offset; end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#169
  sig { returns(Integer) }
  def start_column; end

  # The line number where this location starts.
  #
  # source://prism//lib/prism/parse_result.rb#152
  sig { returns(Integer) }
  def start_line; end

  # The content of the line where this location starts before this location.
  #
  # source://prism//lib/prism/parse_result.rb#157
  def start_line_slice; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # source://prism//lib/prism/parse_result.rb#98
  sig { returns(Integer) }
  def start_offset; end

  protected

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/parse_result.rb#94
  def source; end

  class << self
    # Returns a null location that does not correspond to a source and points to
    # the beginning of the file. Useful for when you want a location object but
    # do not care where it points.
    #
    # source://prism//lib/prism/parse_result.rb#221
    def null; end
  end
end

# Flags for while and until loop nodes.
#
# source://prism//lib/prism/node.rb#16635
module Prism::LoopFlags; end

# a loop after a begin statement, so the body is executed first before the condition
#
# source://prism//lib/prism/node.rb#16637
Prism::LoopFlags::BEGIN_MODIFIER = T.let(T.unsafe(nil), Integer)

# This represents a magic comment that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#282
class Prism::MagicComment
  # Create a new magic comment object with the given key and value locations.
  #
  # @return [MagicComment] a new instance of MagicComment
  #
  # source://prism//lib/prism/parse_result.rb#290
  def initialize(key_loc, value_loc); end

  # Implement the hash pattern matching interface for MagicComment.
  #
  # source://prism//lib/prism/parse_result.rb#306
  def deconstruct_keys(keys); end

  # Returns a string representation of this magic comment.
  #
  # source://prism//lib/prism/parse_result.rb#311
  def inspect; end

  # Returns the key of the magic comment by slicing it from the source code.
  #
  # source://prism//lib/prism/parse_result.rb#296
  def key; end

  # A Location object representing the location of the key in the source.
  #
  # source://prism//lib/prism/parse_result.rb#284
  def key_loc; end

  # Returns the value of the magic comment by slicing it from the source code.
  #
  # source://prism//lib/prism/parse_result.rb#301
  def value; end

  # A Location object representing the location of the value in the source.
  #
  # source://prism//lib/prism/parse_result.rb#287
  def value_loc; end
end

# Represents a regular expression literal used in the predicate of a
# conditional to implicitly match against the last line read by an IO
# object.
#
#     if /foo/i then end
#        ^^^^^^
#
# source://prism//lib/prism/node.rb#10906
class Prism::MatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
  #
  # @return [MatchLastLineNode] a new instance of MatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#10923
  sig do
    params(
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10933
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11013
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10938
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#10983
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#10914
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10948
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10943
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#10978
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#10911
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> MatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#10953
  sig { params(params: T.untyped).returns(Prism::MatchLastLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10938
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#10968
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11008
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10993
  sig { returns(T::Boolean) }
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10988
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11028
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10998
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11003
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#10973
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#10908
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11053
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#10917
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11023
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11018
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#10920
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11063
    def type; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11072
class Prism::MatchPredicateNode < ::Prism::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # source://prism//lib/prism/node.rb#11083
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11091
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11106
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11101
  def compact_child_nodes; end

  # def copy: (**params) -> MatchPredicateNode
  #
  # source://prism//lib/prism/node.rb#11111
  sig { params(params: T.untyped).returns(Prism::MatchPredicateNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11124
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11134
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11129
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11080
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism//lib/prism/node.rb#11077
  sig { returns(Prism::Node) }
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11158
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#11074
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11168
    def type; end
  end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11177
class Prism::MatchRequiredNode < ::Prism::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # source://prism//lib/prism/node.rb#11188
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11196
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11201
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11211
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11206
  def compact_child_nodes; end

  # def copy: (**params) -> MatchRequiredNode
  #
  # source://prism//lib/prism/node.rb#11216
  sig { params(params: T.untyped).returns(Prism::MatchRequiredNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11201
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11229
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11239
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11234
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11185
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism//lib/prism/node.rb#11182
  sig { returns(Prism::Node) }
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11263
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#11179
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11273
    def type; end
  end
end

# Represents writing local variables using a regular expression match with
# named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11283
class Prism::MatchWriteNode < ::Prism::Node
  # def initialize: (call: CallNode, targets: Array[Node], location: Location) -> void
  #
  # @return [MatchWriteNode] a new instance of MatchWriteNode
  #
  # source://prism//lib/prism/node.rb#11291
  sig { params(call: Prism::CallNode, targets: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(call, targets, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11298
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader call: CallNode
  #
  # source://prism//lib/prism/node.rb#11285
  sig { returns(Prism::CallNode) }
  def call; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11303
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11313
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11308
  def compact_child_nodes; end

  # def copy: (**params) -> MatchWriteNode
  #
  # source://prism//lib/prism/node.rb#11318
  sig { params(params: T.untyped).returns(Prism::MatchWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11303
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11330
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11335
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader targets: Array[Node]
  #
  # source://prism//lib/prism/node.rb#11288
  sig { returns(T::Array[Prism::Node]) }
  def targets; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11357
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11367
    def type; end
  end
end

# Represents a node that is missing from the source and results in a syntax
# error.
#
# source://prism//lib/prism/node.rb#11374
class Prism::MissingNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # source://prism//lib/prism/node.rb#11376
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11381
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11386
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11396
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11391
  def compact_child_nodes; end

  # def copy: (**params) -> MissingNode
  #
  # source://prism//lib/prism/node.rb#11401
  sig { params(params: T.untyped).returns(Prism::MissingNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11386
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11411
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11416
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11435
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11445
    def type; end
  end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11454
class Prism::ModuleNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # source://prism//lib/prism/node.rb#11474
  sig do
    params(
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11485
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#11465
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11490
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11503
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11495
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism//lib/prism/node.rb#11462
  sig { returns(Prism::Node) }
  def constant_path; end

  # def copy: (**params) -> ModuleNode
  #
  # source://prism//lib/prism/node.rb#11508
  sig { params(params: T.untyped).returns(Prism::ModuleNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11490
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11524
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#11534
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#11468
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11539
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#11456
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def module_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#11529
  sig { returns(String) }
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#11459
  sig { returns(Prism::Location) }
  def module_keyword_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#11471
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11570
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11580
    def type; end
  end
end

# Represents a multi-target expression.
#
#     a, (b, c) = 1, 2, 3
#        ^^^^^^
#
# source://prism//lib/prism/node.rb#11589
class Prism::MultiTargetNode < ::Prism::Node
  # def initialize: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [MultiTargetNode] a new instance of MultiTargetNode
  #
  # source://prism//lib/prism/node.rb#11606
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11616
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11621
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11635
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11626
  def compact_child_nodes; end

  # def copy: (**params) -> MultiTargetNode
  #
  # source://prism//lib/prism/node.rb#11640
  sig { params(params: T.untyped).returns(Prism::MultiTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11621
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11655
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11670
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#11591
  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#11660
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11600
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # attr_reader rest: Node?
  #
  # source://prism//lib/prism/node.rb#11594
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # attr_reader rights: Array[Node]
  #
  # source://prism//lib/prism/node.rb#11597
  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#11665
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11603
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11699
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11709
    def type; end
  end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11718
class Prism::MultiWriteNode < ::Prism::Node
  # def initialize: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # source://prism//lib/prism/node.rb#11741
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11753
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11758
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11773
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11763
  def compact_child_nodes; end

  # def copy: (**params) -> MultiWriteNode
  #
  # source://prism//lib/prism/node.rb#11778
  sig { params(params: T.untyped).returns(Prism::MultiWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11758
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11795
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11815
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#11720
  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#11800
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11729
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11810
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11735
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader rest: Node?
  #
  # source://prism//lib/prism/node.rb#11723
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # attr_reader rights: Array[Node]
  #
  # source://prism//lib/prism/node.rb#11726
  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#11805
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11732
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11847
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#11738
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11857
    def type; end
  end
end

# This visitor walks through the tree and copies each node as it is being
# visited. This is useful for consumers that want to mutate the tree, as you
# can change subtrees in place without effecting the rest of the tree.
#
# source://prism//lib/prism/mutation_compiler.rb#12
class Prism::MutationCompiler < ::Prism::Compiler
  # Copy a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#14
  def visit_alias_global_variable_node(node); end

  # Copy a AliasMethodNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#19
  def visit_alias_method_node(node); end

  # Copy a AlternationPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#24
  def visit_alternation_pattern_node(node); end

  # Copy a AndNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#29
  def visit_and_node(node); end

  # Copy a ArgumentsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#34
  def visit_arguments_node(node); end

  # Copy a ArrayNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#39
  def visit_array_node(node); end

  # Copy a ArrayPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#44
  def visit_array_pattern_node(node); end

  # Copy a AssocNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#49
  def visit_assoc_node(node); end

  # Copy a AssocSplatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#54
  def visit_assoc_splat_node(node); end

  # Copy a BackReferenceReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#59
  def visit_back_reference_read_node(node); end

  # Copy a BeginNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#64
  def visit_begin_node(node); end

  # Copy a BlockArgumentNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#69
  def visit_block_argument_node(node); end

  # Copy a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#74
  def visit_block_local_variable_node(node); end

  # Copy a BlockNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#79
  def visit_block_node(node); end

  # Copy a BlockParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#84
  def visit_block_parameter_node(node); end

  # Copy a BlockParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#89
  def visit_block_parameters_node(node); end

  # Copy a BreakNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#94
  def visit_break_node(node); end

  # Copy a CallAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#99
  def visit_call_and_write_node(node); end

  # Copy a CallNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#104
  def visit_call_node(node); end

  # Copy a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#109
  def visit_call_operator_write_node(node); end

  # Copy a CallOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#114
  def visit_call_or_write_node(node); end

  # Copy a CapturePatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#119
  def visit_capture_pattern_node(node); end

  # Copy a CaseMatchNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#124
  def visit_case_match_node(node); end

  # Copy a CaseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#129
  def visit_case_node(node); end

  # Copy a ClassNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#134
  def visit_class_node(node); end

  # Copy a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#139
  def visit_class_variable_and_write_node(node); end

  # Copy a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#144
  def visit_class_variable_operator_write_node(node); end

  # Copy a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#149
  def visit_class_variable_or_write_node(node); end

  # Copy a ClassVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#154
  def visit_class_variable_read_node(node); end

  # Copy a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#159
  def visit_class_variable_target_node(node); end

  # Copy a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#164
  def visit_class_variable_write_node(node); end

  # Copy a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#169
  def visit_constant_and_write_node(node); end

  # Copy a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#174
  def visit_constant_operator_write_node(node); end

  # Copy a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#179
  def visit_constant_or_write_node(node); end

  # Copy a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#184
  def visit_constant_path_and_write_node(node); end

  # Copy a ConstantPathNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#189
  def visit_constant_path_node(node); end

  # Copy a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#194
  def visit_constant_path_operator_write_node(node); end

  # Copy a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#199
  def visit_constant_path_or_write_node(node); end

  # Copy a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#204
  def visit_constant_path_target_node(node); end

  # Copy a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#209
  def visit_constant_path_write_node(node); end

  # Copy a ConstantReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#214
  def visit_constant_read_node(node); end

  # Copy a ConstantTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#219
  def visit_constant_target_node(node); end

  # Copy a ConstantWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#224
  def visit_constant_write_node(node); end

  # Copy a DefNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#229
  def visit_def_node(node); end

  # Copy a DefinedNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#234
  def visit_defined_node(node); end

  # Copy a ElseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#239
  def visit_else_node(node); end

  # Copy a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#244
  def visit_embedded_statements_node(node); end

  # Copy a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#249
  def visit_embedded_variable_node(node); end

  # Copy a EnsureNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#254
  def visit_ensure_node(node); end

  # Copy a FalseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#259
  def visit_false_node(node); end

  # Copy a FindPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#264
  def visit_find_pattern_node(node); end

  # Copy a FlipFlopNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#269
  def visit_flip_flop_node(node); end

  # Copy a FloatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#274
  def visit_float_node(node); end

  # Copy a ForNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#279
  def visit_for_node(node); end

  # Copy a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#284
  def visit_forwarding_arguments_node(node); end

  # Copy a ForwardingParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#289
  def visit_forwarding_parameter_node(node); end

  # Copy a ForwardingSuperNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#294
  def visit_forwarding_super_node(node); end

  # Copy a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#299
  def visit_global_variable_and_write_node(node); end

  # Copy a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#304
  def visit_global_variable_operator_write_node(node); end

  # Copy a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#309
  def visit_global_variable_or_write_node(node); end

  # Copy a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#314
  def visit_global_variable_read_node(node); end

  # Copy a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#319
  def visit_global_variable_target_node(node); end

  # Copy a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#324
  def visit_global_variable_write_node(node); end

  # Copy a HashNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#329
  def visit_hash_node(node); end

  # Copy a HashPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#334
  def visit_hash_pattern_node(node); end

  # Copy a IfNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#339
  def visit_if_node(node); end

  # Copy a ImaginaryNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#344
  def visit_imaginary_node(node); end

  # Copy a ImplicitNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#349
  def visit_implicit_node(node); end

  # Copy a InNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#354
  def visit_in_node(node); end

  # Copy a IndexAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#359
  def visit_index_and_write_node(node); end

  # Copy a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#364
  def visit_index_operator_write_node(node); end

  # Copy a IndexOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#369
  def visit_index_or_write_node(node); end

  # Copy a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#374
  def visit_instance_variable_and_write_node(node); end

  # Copy a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#379
  def visit_instance_variable_operator_write_node(node); end

  # Copy a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#384
  def visit_instance_variable_or_write_node(node); end

  # Copy a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#389
  def visit_instance_variable_read_node(node); end

  # Copy a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#394
  def visit_instance_variable_target_node(node); end

  # Copy a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#399
  def visit_instance_variable_write_node(node); end

  # Copy a IntegerNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#404
  def visit_integer_node(node); end

  # Copy a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#409
  def visit_interpolated_match_last_line_node(node); end

  # Copy a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#414
  def visit_interpolated_regular_expression_node(node); end

  # Copy a InterpolatedStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#419
  def visit_interpolated_string_node(node); end

  # Copy a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#424
  def visit_interpolated_symbol_node(node); end

  # Copy a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#429
  def visit_interpolated_x_string_node(node); end

  # Copy a KeywordHashNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#434
  def visit_keyword_hash_node(node); end

  # Copy a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#439
  def visit_keyword_rest_parameter_node(node); end

  # Copy a LambdaNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#444
  def visit_lambda_node(node); end

  # Copy a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#449
  def visit_local_variable_and_write_node(node); end

  # Copy a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#454
  def visit_local_variable_operator_write_node(node); end

  # Copy a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#459
  def visit_local_variable_or_write_node(node); end

  # Copy a LocalVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#464
  def visit_local_variable_read_node(node); end

  # Copy a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#469
  def visit_local_variable_target_node(node); end

  # Copy a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#474
  def visit_local_variable_write_node(node); end

  # Copy a MatchLastLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#479
  def visit_match_last_line_node(node); end

  # Copy a MatchPredicateNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#484
  def visit_match_predicate_node(node); end

  # Copy a MatchRequiredNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#489
  def visit_match_required_node(node); end

  # Copy a MatchWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#494
  def visit_match_write_node(node); end

  # Copy a MissingNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#499
  def visit_missing_node(node); end

  # Copy a ModuleNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#504
  def visit_module_node(node); end

  # Copy a MultiTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#509
  def visit_multi_target_node(node); end

  # Copy a MultiWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#514
  def visit_multi_write_node(node); end

  # Copy a NextNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#519
  def visit_next_node(node); end

  # Copy a NilNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#524
  def visit_nil_node(node); end

  # Copy a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#529
  def visit_no_keywords_parameter_node(node); end

  # Copy a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#534
  def visit_numbered_reference_read_node(node); end

  # Copy a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#539
  def visit_optional_keyword_parameter_node(node); end

  # Copy a OptionalParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#544
  def visit_optional_parameter_node(node); end

  # Copy a OrNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#549
  def visit_or_node(node); end

  # Copy a ParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#554
  def visit_parameters_node(node); end

  # Copy a ParenthesesNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#559
  def visit_parentheses_node(node); end

  # Copy a PinnedExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#564
  def visit_pinned_expression_node(node); end

  # Copy a PinnedVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#569
  def visit_pinned_variable_node(node); end

  # Copy a PostExecutionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#574
  def visit_post_execution_node(node); end

  # Copy a PreExecutionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#579
  def visit_pre_execution_node(node); end

  # Copy a ProgramNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#584
  def visit_program_node(node); end

  # Copy a RangeNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#589
  def visit_range_node(node); end

  # Copy a RationalNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#594
  def visit_rational_node(node); end

  # Copy a RedoNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#599
  def visit_redo_node(node); end

  # Copy a RegularExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#604
  def visit_regular_expression_node(node); end

  # Copy a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#609
  def visit_required_keyword_parameter_node(node); end

  # Copy a RequiredParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#614
  def visit_required_parameter_node(node); end

  # Copy a RescueModifierNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#619
  def visit_rescue_modifier_node(node); end

  # Copy a RescueNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#624
  def visit_rescue_node(node); end

  # Copy a RestParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#629
  def visit_rest_parameter_node(node); end

  # Copy a RetryNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#634
  def visit_retry_node(node); end

  # Copy a ReturnNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#639
  def visit_return_node(node); end

  # Copy a SelfNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#644
  def visit_self_node(node); end

  # Copy a SingletonClassNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#649
  def visit_singleton_class_node(node); end

  # Copy a SourceEncodingNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#654
  def visit_source_encoding_node(node); end

  # Copy a SourceFileNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#659
  def visit_source_file_node(node); end

  # Copy a SourceLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#664
  def visit_source_line_node(node); end

  # Copy a SplatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#669
  def visit_splat_node(node); end

  # Copy a StatementsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#674
  def visit_statements_node(node); end

  # Copy a StringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#679
  def visit_string_node(node); end

  # Copy a SuperNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#684
  def visit_super_node(node); end

  # Copy a SymbolNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#689
  def visit_symbol_node(node); end

  # Copy a TrueNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#694
  def visit_true_node(node); end

  # Copy a UndefNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#699
  def visit_undef_node(node); end

  # Copy a UnlessNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#704
  def visit_unless_node(node); end

  # Copy a UntilNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#709
  def visit_until_node(node); end

  # Copy a WhenNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#714
  def visit_when_node(node); end

  # Copy a WhileNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#719
  def visit_while_node(node); end

  # Copy a XStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#724
  def visit_x_string_node(node); end

  # Copy a YieldNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#729
  def visit_yield_node(node); end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# source://prism//lib/prism/node.rb#11866
class Prism::NextNode < ::Prism::Node
  # def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
  #
  # @return [NextNode] a new instance of NextNode
  #
  # source://prism//lib/prism/node.rb#11874
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11881
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#11868
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11886
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11898
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11891
  def compact_child_nodes; end

  # def copy: (**params) -> NextNode
  #
  # source://prism//lib/prism/node.rb#11903
  sig { params(params: T.untyped).returns(Prism::NextNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11886
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#11915
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#11925
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#11920
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#11871
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11951
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11961
    def type; end
  end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# source://prism//lib/prism/node.rb#11970
class Prism::NilNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [NilNode] a new instance of NilNode
  #
  # source://prism//lib/prism/node.rb#11972
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11977
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11982
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11992
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11987
  def compact_child_nodes; end

  # def copy: (**params) -> NilNode
  #
  # source://prism//lib/prism/node.rb#11997
  sig { params(params: T.untyped).returns(Prism::NilNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11982
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12007
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12012
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12031
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12041
    def type; end
  end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# source://prism//lib/prism/node.rb#12051
class Prism::NoKeywordsParameterNode < ::Prism::Node
  # def initialize: (operator_loc: Location, keyword_loc: Location, location: Location) -> void
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # source://prism//lib/prism/node.rb#12059
  sig { params(operator_loc: Prism::Location, keyword_loc: Prism::Location, location: Prism::Location).void }
  def initialize(operator_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12066
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12071
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12081
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12076
  def compact_child_nodes; end

  # def copy: (**params) -> NoKeywordsParameterNode
  #
  # source://prism//lib/prism/node.rb#12086
  sig { params(params: T.untyped).returns(Prism::NoKeywordsParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12071
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12098
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12113
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#12108
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#12056
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12103
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12053
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12134
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12144
    def type; end
  end
end

# This represents a node in the tree. It is the parent class of all of the
# various node types.
#
# source://prism//lib/prism/node.rb#11
class Prism::Node
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # A Location instance that represents the location of this node in the
  # source.
  #
  # source://prism//lib/prism/node.rb#14
  sig { returns(Prism::Location) }
  def location; end

  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16
  def newline?; end

  # Similar to inspect, but respects the current level of indentation given by
  # the pretty print object.
  #
  # source://prism//lib/prism/node.rb#35
  def pretty_print(q); end

  # source://prism//lib/prism/node.rb#20
  def set_newline_flag(newline_marked); end

  # Slice the location of the node from the source.
  #
  # source://prism//lib/prism/node.rb#29
  sig { returns(String) }
  def slice; end

  # Convert this node into a graphviz dot graph string.
  #
  # source://prism//lib/prism/node.rb#43
  def to_dot; end
end

# This object is responsible for generating the output for the inspect method
# implementations of child nodes.
#
# source://prism//lib/prism/node_inspector.rb#6
class Prism::NodeInspector
  # @return [NodeInspector] a new instance of NodeInspector
  #
  # source://prism//lib/prism/node_inspector.rb#9
  def initialize(prefix = T.unsafe(nil)); end

  # Appends a line to the output with the current prefix.
  #
  # source://prism//lib/prism/node_inspector.rb#15
  sig { params(line: String).void }
  def <<(line); end

  # Returns a new inspector that can be used to inspect a child node.
  #
  # source://prism//lib/prism/node_inspector.rb#59
  sig { params(append: String).returns(Prism::NodeInspector) }
  def child_inspector(append); end

  # Generates a string that represents a child node.
  #
  # source://prism//lib/prism/node_inspector.rb#54
  sig { params(node: Prism::Node, append: String).returns(String) }
  def child_node(node, append); end

  # This generates a string that is used as the header of the inspect output
  # for any given node.
  #
  # source://prism//lib/prism/node_inspector.rb#21
  # This generates a string that is used as the header of the inspect output
  sig { params(node: Prism::Node).returns(String) }
  def header(node); end

  # Generates a string that represents a list of nodes. It handles properly
  # using the box drawing characters to make the output look nice.
  #
  # source://prism//lib/prism/node_inspector.rb#31
  # Generates a string that represents a list of nodes. It handles properly
  sig { params(prefix: String, nodes: T::Array[Prism::Node]).returns(String) }
  def list(prefix, nodes); end

  # Generates a string that represents a location field on a node.
  #
  # source://prism//lib/prism/node_inspector.rb#45
  sig { params(value: Prism::Location).returns(String) }
  def location(value); end

  # source://prism//lib/prism/node_inspector.rb#7
  sig { returns(String) }
  def output; end

  # source://prism//lib/prism/node_inspector.rb#7
  sig { returns(String) }
  def prefix; end

  # Returns the output as a string.
  #
  # source://prism//lib/prism/node_inspector.rb#64
  sig { returns(String) }
  def to_str; end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# source://prism//lib/prism/node.rb#12153
class Prism::NumberedReferenceReadNode < ::Prism::Node
  # def initialize: (number: Integer, location: Location) -> void
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#12158
  sig { params(number: Integer, location: Prism::Location).void }
  def initialize(number, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12164
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12169
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12179
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12174
  def compact_child_nodes; end

  # def copy: (**params) -> NumberedReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#12184
  sig { params(params: T.untyped).returns(Prism::NumberedReferenceReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12169
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12195
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12200
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader number: Integer
  #
  # source://prism//lib/prism/node.rb#12155
  sig { returns(Integer) }
  def number; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12220
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12230
    def type; end
  end
end

# Represents an optional keyword parameter to a method, block, or lambda definition.
#
#     def a(b: 1)
#           ^^^^
#     end
#
# source://prism//lib/prism/node.rb#12240
class Prism::OptionalKeywordParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, location: Location) -> void
  #
  # @return [OptionalKeywordParameterNode] a new instance of OptionalKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#12251
  sig { params(name: Symbol, name_loc: Prism::Location, value: Prism::Node, location: Prism::Location).void }
  def initialize(name, name_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12259
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12264
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12274
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12269
  def compact_child_nodes; end

  # def copy: (**params) -> OptionalKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#12279
  sig { params(params: T.untyped).returns(Prism::OptionalKeywordParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12264
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12292
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12297
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#12242
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#12245
  sig { returns(Prism::Location) }
  def name_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12320
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#12248
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12330
    def type; end
  end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# source://prism//lib/prism/node.rb#12340
class Prism::OptionalParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # source://prism//lib/prism/node.rb#12354
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12363
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12368
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12378
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12373
  def compact_child_nodes; end

  # def copy: (**params) -> OptionalParameterNode
  #
  # source://prism//lib/prism/node.rb#12383
  sig { params(params: T.untyped).returns(Prism::OptionalParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12368
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12397
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12407
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#12342
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#12345
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12402
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12348
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12431
  def type; end

  # attr_reader value: Node
  #
  # source://prism//lib/prism/node.rb#12351
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12441
    def type; end
  end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12450
class Prism::OrNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [OrNode] a new instance of OrNode
  #
  # source://prism//lib/prism/node.rb#12461
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12469
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12474
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12484
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12479
  def compact_child_nodes; end

  # def copy: (**params) -> OrNode
  #
  # source://prism//lib/prism/node.rb#12489
  sig { params(params: T.untyped).returns(Prism::OrNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12474
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12502
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12512
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism//lib/prism/node.rb#12452
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12507
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12458
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism//lib/prism/node.rb#12455
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12536
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12546
    def type; end
  end
end

# A parser for the pack template language.
#
# source://prism//lib/prism/pack.rb#5
module Prism::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

# source://prism//lib/prism/pack.rb#55
Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# A directive in the pack template language.
#
# source://prism//lib/prism/pack.rb#59
class Prism::Pack::Directive
  # Initialize a new directive with the given values.
  #
  # @return [Directive] a new instance of Directive
  #
  # source://prism//lib/prism/pack.rb#88
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # Provide a human-readable description of the directive.
  #
  # source://prism//lib/prism/pack.rb#130
  def describe; end

  # The type of endianness of the directive.
  #
  # source://prism//lib/prism/pack.rb#76
  def endian; end

  # The length of this directive (used for integers).
  #
  # source://prism//lib/prism/pack.rb#85
  def length; end

  # The length type of this directive (used for integers).
  #
  # source://prism//lib/prism/pack.rb#82
  def length_type; end

  # The type of signedness of the directive.
  #
  # source://prism//lib/prism/pack.rb#73
  def signed; end

  # The size of the directive.
  #
  # source://prism//lib/prism/pack.rb#79
  def size; end

  # A byteslice of the source string that this directive represents.
  #
  # source://prism//lib/prism/pack.rb#67
  def source; end

  # The type of the directive.
  #
  # source://prism//lib/prism/pack.rb#70
  def type; end

  # A symbol representing whether or not we are packing or unpacking.
  #
  # source://prism//lib/prism/pack.rb#64
  def variant; end

  # A symbol representing the version of Ruby.
  #
  # source://prism//lib/prism/pack.rb#61
  def version; end
end

# The descriptions of the various types of endianness.
#
# source://prism//lib/prism/pack.rb#101
Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of signedness.
#
# source://prism//lib/prism/pack.rb#110
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of sizes.
#
# source://prism//lib/prism/pack.rb#117
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# The result of parsing a pack template.
#
# source://prism//lib/prism/pack.rb#195
class Prism::Pack::Format
  # Create a new Format with the given directives and encoding.
  #
  # @return [Format] a new instance of Format
  #
  # source://prism//lib/prism/pack.rb#203
  def initialize(directives, encoding); end

  # Provide a human-readable description of the format.
  #
  # source://prism//lib/prism/pack.rb#209
  def describe; end

  # A list of the directives in the template.
  #
  # source://prism//lib/prism/pack.rb#197
  def directives; end

  # The encoding of the template.
  #
  # source://prism//lib/prism/pack.rb#200
  def encoding; end
end

# source://prism//lib/prism/pack.rb#55
Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#55
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#12556
class Prism::ParametersNode < ::Prism::Node
  # def initialize: (requireds: Array[Node], optionals: Array[Node], rest: RestParameterNode?, posts: Array[Node], keywords: Array[Node], keyword_rest: Node?, block: BlockParameterNode?, location: Location) -> void
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # source://prism//lib/prism/node.rb#12579
  sig do
    params(
      requireds: T::Array[Prism::Node],
      optionals: T::Array[Prism::Node],
      rest: T.nilable(Prism::RestParameterNode),
      posts: T::Array[Prism::Node],
      keywords: T::Array[Prism::Node],
      keyword_rest: T.nilable(Prism::Node),
      block: T.nilable(Prism::BlockParameterNode),
      location: Prism::Location
    ).void
  end
  def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12591
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader block: BlockParameterNode?
  #
  # source://prism//lib/prism/node.rb#12576
  sig { returns(T.nilable(Prism::BlockParameterNode)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12596
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12614
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12601
  def compact_child_nodes; end

  # def copy: (**params) -> ParametersNode
  #
  # source://prism//lib/prism/node.rb#12619
  sig { params(params: T.untyped).returns(Prism::ParametersNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12596
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12636
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12641
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader keyword_rest: Node?
  #
  # source://prism//lib/prism/node.rb#12573
  sig { returns(T.nilable(Prism::Node)) }
  def keyword_rest; end

  # attr_reader keywords: Array[Node]
  #
  # source://prism//lib/prism/node.rb#12570
  sig { returns(T::Array[Prism::Node]) }
  def keywords; end

  # attr_reader optionals: Array[Node]
  #
  # source://prism//lib/prism/node.rb#12561
  sig { returns(T::Array[Prism::Node]) }
  def optionals; end

  # attr_reader posts: Array[Node]
  #
  # source://prism//lib/prism/node.rb#12567
  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism//lib/prism/node.rb#12558
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader rest: RestParameterNode?
  #
  # source://prism//lib/prism/node.rb#12564
  sig { returns(T.nilable(Prism::RestParameterNode)) }
  def rest; end

  # Mirrors the Method#parameters method.
  #
  # source://prism//lib/prism/node_ext.rb#124
  def signature; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12682
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12692
    def type; end
  end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12701
class Prism::ParenthesesNode < ::Prism::Node
  # def initialize: (body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # source://prism//lib/prism/node.rb#12712
  sig do
    params(
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(body, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12720
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#12703
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12729
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#12769
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#12709
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12741
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12734
  def compact_child_nodes; end

  # def copy: (**params) -> ParenthesesNode
  #
  # source://prism//lib/prism/node.rb#12746
  sig { params(params: T.untyped).returns(Prism::ParenthesesNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12729
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12759
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12774
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#12764
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#12706
  sig { returns(Prism::Location) }
  def opening_loc; end

  # source://prism//lib/prism/node.rb#12724
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12801
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12811
    def type; end
  end
end

# This represents an error that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#317
class Prism::ParseError
  # Create a new error object with the given message and location.
  #
  # @return [ParseError] a new instance of ParseError
  #
  # source://prism//lib/prism/parse_result.rb#325
  def initialize(message, location); end

  # Implement the hash pattern matching interface for ParseError.
  #
  # source://prism//lib/prism/parse_result.rb#331
  def deconstruct_keys(keys); end

  # Returns a string representation of this error.
  #
  # source://prism//lib/prism/parse_result.rb#336
  def inspect; end

  # A Location object representing the location of this error in the source.
  #
  # source://prism//lib/prism/parse_result.rb#322
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this error.
  #
  # source://prism//lib/prism/parse_result.rb#319
  sig { returns(String) }
  def message; end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the AST, any comments that were encounters, and any errors that were
# encountered.
#
# source://prism//lib/prism/parse_result.rb#369
class Prism::ParseResult
  # Create a new parse result object with the given values.
  #
  # @return [ParseResult] a new instance of ParseResult
  #
  # source://prism//lib/prism/parse_result.rb#391
  def initialize(value, comments, magic_comments, errors, warnings, source); end

  # Attach the list of comments to their respective locations in the tree.
  #
  # source://prism//lib/prism/parse_result/comments.rb#173
  def attach_comments!; end

  # The list of comments that were encountered during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#376
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # Implement the hash pattern matching interface for ParseResult.
  #
  # source://prism//lib/prism/parse_result.rb#401
  def deconstruct_keys(keys); end

  # The list of errors that were generated during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#382
  sig { returns(T::Array[Prism::ParseError]) }
  def errors; end

  # Returns true if there were errors during parsing and false if there were
  # not.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#413
  def failure?; end

  # The list of magic comments that were encountered during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#379
  def magic_comments; end

  # Walk the tree and mark nodes that are on a new line.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#60
  def mark_newlines!; end

  # A Source instance that represents the source code that was parsed.
  #
  # source://prism//lib/prism/parse_result.rb#388
  sig { returns(Prism::Source) }
  def source; end

  # Returns true if there were no errors during parsing and false if there
  # were.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#407
  def success?; end

  # The value that was generated by parsing. Normally this holds the AST, but
  # it can sometimes how a list of tokens or other results passed back from
  # the parser.
  #
  # source://prism//lib/prism/parse_result.rb#373
  sig { returns(Prism::ProgramNode) }
  def value; end

  # The list of warnings that were generated during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#385
  sig { returns(T::Array[Prism::ParseWarning]) }
  def warnings; end
end

# When we've parsed the source, we have both the syntax tree and the list of
# comments that we found in the source. This class is responsible for
# walking the tree and finding the nearest location to attach each comment.
#
# It does this by first finding the nearest locations to each comment.
# Locations can either come from nodes directly or from location fields on
# nodes. For example, a `ClassNode` has an overall location encompassing the
# entire class, but it also has a location for the `class` keyword.
#
# Once the nearest locations are found, it determines which one to attach
# to. If it's a trailing comment (a comment on the same line as other source
# code), it will favor attaching to the nearest location that occurs before
# the comment. Otherwise it will favor attaching to the nearest location
# that is after the comment.
#
# source://prism//lib/prism/parse_result/comments.rb#19
class Prism::ParseResult::Comments
  # Create a new Comments object that will attach comments to the given
  # parse result.
  #
  # @return [Comments] a new instance of Comments
  #
  # source://prism//lib/prism/parse_result/comments.rb#78
  def initialize(parse_result); end

  # Attach the comments to their respective locations in the tree by
  # mutating the parse result.
  #
  # source://prism//lib/prism/parse_result/comments.rb#84
  def attach!; end

  # The parse result that we are attaching comments to.
  #
  # source://prism//lib/prism/parse_result/comments.rb#74
  def parse_result; end

  private

  # Responsible for finding the nearest targets to the given comment within
  # the context of the given encapsulating node.
  #
  # source://prism//lib/prism/parse_result/comments.rb#103
  def nearest_targets(node, comment); end
end

# A target for attaching comments that is based on a location field on a
# node. For example, the `end` token of a ClassNode.
#
# source://prism//lib/prism/parse_result/comments.rb#49
class Prism::ParseResult::Comments::LocationTarget
  # @return [LocationTarget] a new instance of LocationTarget
  #
  # source://prism//lib/prism/parse_result/comments.rb#52
  def initialize(location); end

  # source://prism//lib/prism/parse_result/comments.rb#68
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result/comments.rb#64
  def encloses?(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#60
  def end_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#50
  def location; end

  # source://prism//lib/prism/parse_result/comments.rb#56
  def start_offset; end
end

# A target for attaching comments that is based on a specific node's
# location.
#
# source://prism//lib/prism/parse_result/comments.rb#22
class Prism::ParseResult::Comments::NodeTarget
  # @return [NodeTarget] a new instance of NodeTarget
  #
  # source://prism//lib/prism/parse_result/comments.rb#25
  def initialize(node); end

  # source://prism//lib/prism/parse_result/comments.rb#42
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result/comments.rb#37
  def encloses?(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#33
  def end_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#23
  def node; end

  # source://prism//lib/prism/parse_result/comments.rb#29
  def start_offset; end
end

# The :line tracepoint event gets fired whenever the Ruby VM encounters an
# expression on a new line. The types of expressions that can trigger this
# event are:
#
# * if statements
# * unless statements
# * nodes that are children of statements lists
#
# In order to keep track of the newlines, we have a list of offsets that
# come back from the parser. We assign these offsets to the first nodes that
# we find in the tree that are on those lines.
#
# Note that the logic in this file should be kept in sync with the Java
# MarkNewlinesVisitor, since that visitor is responsible for marking the
# newlines for JRuby/TruffleRuby.
#
# source://prism//lib/prism/parse_result/newlines.rb#20
class Prism::ParseResult::Newlines < ::Prism::Visitor
  # Create a new Newlines visitor with the given newline offsets.
  #
  # @return [Newlines] a new instance of Newlines
  #
  # source://prism//lib/prism/parse_result/newlines.rb#22
  def initialize(newline_marked); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#27
  def visit_block_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#41
  def visit_if_node(node); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#27
  def visit_lambda_node(node); end

  # Permit statements lists to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#49
  def visit_statements_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#41
  def visit_unless_node(node); end
end

# This represents a warning that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#342
class Prism::ParseWarning
  # Create a new warning object with the given message and location.
  #
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # source://prism//lib/prism/parse_result.rb#350
  def initialize(message, location); end

  # Implement the hash pattern matching interface for ParseWarning.
  #
  # source://prism//lib/prism/parse_result.rb#356
  def deconstruct_keys(keys); end

  # Returns a string representation of this warning.
  #
  # source://prism//lib/prism/parse_result.rb#361
  def inspect; end

  # A Location object representing the location of this warning in the source.
  #
  # source://prism//lib/prism/parse_result.rb#347
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this warning.
  #
  # source://prism//lib/prism/parse_result.rb#344
  sig { returns(String) }
  def message; end
end

# A pattern is an object that wraps a Ruby pattern matching expression. The
# expression would normally be passed to an `in` clause within a `case`
# expression or a rightward assignment expression. For example, in the
# following snippet:
#
#     case node
#     in ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]
#     end
#
# the pattern is the <tt>ConstantPathNode[...]</tt> expression.
#
# The pattern gets compiled into an object that responds to #call by running
# the #compile method. This method itself will run back through Prism to
# parse the expression into a tree, then walk the tree to generate the
# necessary callable objects. For example, if you wanted to compile the
# expression above into a callable, you would:
#
#     callable = Prism::Pattern.new("ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]").compile
#     callable.call(node)
#
# The callable object returned by #compile is guaranteed to respond to #call
# with a single argument, which is the node to match against. It also is
# guaranteed to respond to #===, which means it itself can be used in a `case`
# expression, as in:
#
#     case node
#     when callable
#     end
#
# If the query given to the initializer cannot be compiled into a valid
# matcher (either because of a syntax error or because it is using syntax we
# do not yet support) then a Prism::Pattern::CompilationError will be
# raised.
#
# source://prism//lib/prism/pattern.rb#37
class Prism::Pattern
  # Create a new pattern with the given query. The query should be a string
  # containing a Ruby pattern matching expression.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://prism//lib/prism/pattern.rb#63
  def initialize(query); end

  # Compile the query into a callable object that can be used to match against
  # nodes.
  #
  # source://prism//lib/prism/pattern.rb#70
  def compile; end

  # The query that this pattern was initialized with.
  #
  # source://prism//lib/prism/pattern.rb#59
  def query; end

  # Scan the given node and all of its children for nodes that match the
  # pattern. If a block is given, it will be called with each node that
  # matches the pattern. If no block is given, an enumerator will be returned
  # that will yield each node that matches the pattern.
  #
  # source://prism//lib/prism/pattern.rb#79
  def scan(root); end

  private

  # Shortcut for combining two procs into one that returns true if both return
  # true.
  #
  # source://prism//lib/prism/pattern.rb#95
  def combine_and(left, right); end

  # Shortcut for combining two procs into one that returns true if either
  # returns true.
  #
  # source://prism//lib/prism/pattern.rb#101
  def combine_or(left, right); end

  # in foo | bar
  #
  # source://prism//lib/prism/pattern.rb#136
  def compile_alternation_pattern_node(node); end

  # in [foo, bar, baz]
  #
  # source://prism//lib/prism/pattern.rb#111
  def compile_array_pattern_node(node); end

  # in Prism::ConstantReadNode
  #
  # source://prism//lib/prism/pattern.rb#141
  def compile_constant_path_node(node); end

  # in ConstantReadNode
  # in String
  #
  # source://prism//lib/prism/pattern.rb#153
  def compile_constant_read_node(node); end

  # Raise an error because the given node is not supported.
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/pattern.rb#106
  def compile_error(node); end

  # in InstanceVariableReadNode[name: Symbol]
  # in { name: Symbol }
  #
  # source://prism//lib/prism/pattern.rb#171
  def compile_hash_pattern_node(node); end

  # in nil
  #
  # source://prism//lib/prism/pattern.rb#196
  def compile_nil_node(node); end

  # Compile any kind of node. Dispatch out to the individual compilation
  # methods based on the type of node.
  #
  # source://prism//lib/prism/pattern.rb#225
  def compile_node(node); end

  # in /foo/
  #
  # source://prism//lib/prism/pattern.rb#201
  def compile_regular_expression_node(node); end

  # in ""
  # in "foo"
  #
  # source://prism//lib/prism/pattern.rb#209
  def compile_string_node(node); end

  # in :+
  # in :foo
  #
  # source://prism//lib/prism/pattern.rb#217
  def compile_symbol_node(node); end
end

# Raised when the query given to a pattern is either invalid Ruby syntax or
# is using syntax that we don't yet support.
#
# source://prism//lib/prism/pattern.rb#40
class Prism::Pattern::CompilationError < ::StandardError
  # Create a new CompilationError with the given representation of the node
  # that caused the error.
  #
  # @return [CompilationError] a new instance of CompilationError
  #
  # source://prism//lib/prism/pattern.rb#43
  def initialize(repr); end
end

# Represents the use of the `^` operator for pinning an expression in a
# pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# source://prism//lib/prism/node.rb#12821
class Prism::PinnedExpressionNode < ::Prism::Node
  # def initialize: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> void
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # source://prism//lib/prism/node.rb#12835
  sig do
    params(
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12844
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12849
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12859
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12854
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedExpressionNode
  #
  # source://prism//lib/prism/node.rb#12864
  sig { params(params: T.untyped).returns(Prism::PinnedExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12849
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12878
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism//lib/prism/node.rb#12823
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12898
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String
  #
  # source://prism//lib/prism/node.rb#12888
  sig { returns(String) }
  def lparen; end

  # attr_reader lparen_loc: Location
  #
  # source://prism//lib/prism/node.rb#12829
  sig { returns(Prism::Location) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12883
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12826
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def rparen: () -> String
  #
  # source://prism//lib/prism/node.rb#12893
  sig { returns(String) }
  def rparen; end

  # attr_reader rparen_loc: Location
  #
  # source://prism//lib/prism/node.rb#12832
  sig { returns(Prism::Location) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12922
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12932
    def type; end
  end
end

# Represents the use of the `^` operator for pinning a variable in a pattern
# matching expression.
#
#     foo in ^bar
#            ^^^^
#
# source://prism//lib/prism/node.rb#12942
class Prism::PinnedVariableNode < ::Prism::Node
  # def initialize: (variable: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # source://prism//lib/prism/node.rb#12950
  sig { params(variable: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(variable, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12957
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12962
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12972
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12967
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedVariableNode
  #
  # source://prism//lib/prism/node.rb#12977
  sig { params(params: T.untyped).returns(Prism::PinnedVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12962
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#12989
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#12999
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12994
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12947
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13021
  def type; end

  # attr_reader variable: Node
  #
  # source://prism//lib/prism/node.rb#12944
  sig { returns(Prism::Node) }
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13031
    def type; end
  end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#13040
class Prism::PostExecutionNode < ::Prism::Node
  # def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # source://prism//lib/prism/node.rb#13054
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13063
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13068
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#13114
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#13051
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13080
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13073
  def compact_child_nodes; end

  # def copy: (**params) -> PostExecutionNode
  #
  # source://prism//lib/prism/node.rb#13085
  sig { params(params: T.untyped).returns(Prism::PostExecutionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13068
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13099
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13119
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13104
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13045
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#13109
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#13048
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#13042
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13147
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13157
    def type; end
  end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#13166
class Prism::PreExecutionNode < ::Prism::Node
  # def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # source://prism//lib/prism/node.rb#13180
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13189
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#13240
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#13177
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13206
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13199
  def compact_child_nodes; end

  # def copy: (**params) -> PreExecutionNode
  #
  # source://prism//lib/prism/node.rb#13211
  sig { params(params: T.untyped).returns(Prism::PreExecutionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13225
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13245
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13230
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13171
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#13235
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#13174
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#13168
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13273
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13283
    def type; end
  end
end

# The top level node of any parse tree.
#
# source://prism//lib/prism/node.rb#13289
class Prism::ProgramNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], statements: StatementsNode, location: Location) -> void
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # source://prism//lib/prism/node.rb#13297
  sig { params(locals: T::Array[Symbol], statements: Prism::StatementsNode, location: Prism::Location).void }
  def initialize(locals, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13304
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13309
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13319
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13314
  def compact_child_nodes; end

  # def copy: (**params) -> ProgramNode
  #
  # source://prism//lib/prism/node.rb#13324
  sig { params(params: T.untyped).returns(Prism::ProgramNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13309
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13336
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13341
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#13291
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # attr_reader statements: StatementsNode
  #
  # source://prism//lib/prism/node.rb#13294
  sig { returns(Prism::StatementsNode) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13363
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13373
    def type; end
  end
end

# Flags for range and flip-flop nodes.
#
# source://prism//lib/prism/node.rb#16641
module Prism::RangeFlags; end

# ... operator
#
# source://prism//lib/prism/node.rb#16643
Prism::RangeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#13385
class Prism::RangeNode < ::Prism::Node
  # def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # source://prism//lib/prism/node.rb#13399
  sig do
    params(
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(left, right, operator_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13408
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13413
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13426
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13418
  def compact_child_nodes; end

  # def copy: (**params) -> RangeNode
  #
  # source://prism//lib/prism/node.rb#13431
  sig { params(params: T.untyped).returns(Prism::RangeNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13413
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13445
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13455
  sig { returns(T::Boolean) }
  def exclude_end?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13460
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node?
  #
  # source://prism//lib/prism/node.rb#13387
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#13450
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#13393
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://prism//lib/prism/node.rb#13390
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13494
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#13396
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13504
    def type; end
  end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# source://prism//lib/prism/node.rb#13513
class Prism::RationalNode < ::Prism::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # source://prism//lib/prism/node.rb#13518
  sig { params(numeric: Prism::Node, location: Prism::Location).void }
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13524
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13529
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13539
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13534
  def compact_child_nodes; end

  # def copy: (**params) -> RationalNode
  #
  # source://prism//lib/prism/node.rb#13544
  sig { params(params: T.untyped).returns(Prism::RationalNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13529
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13555
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13560
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism//lib/prism/node.rb#13515
  sig { returns(Prism::Node) }
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13581
  def type; end

  # Returns the value of the node as a Ruby Rational.
  #
  # source://prism//lib/prism/node_ext.rb#54
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13591
    def type; end
  end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# source://prism//lib/prism/node.rb#13600
class Prism::RedoNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # source://prism//lib/prism/node.rb#13602
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13607
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13612
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13622
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13617
  def compact_child_nodes; end

  # def copy: (**params) -> RedoNode
  #
  # source://prism//lib/prism/node.rb#13627
  sig { params(params: T.untyped).returns(Prism::RedoNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13612
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13637
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13642
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13661
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13671
    def type; end
  end
end

# Flags for regular expression and match last line nodes.
#
# source://prism//lib/prism/node.rb#16647
module Prism::RegularExpressionFlags; end

# n - forces the ASCII-8BIT encoding
#
# source://prism//lib/prism/node.rb#16664
Prism::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)

# e - forces the EUC-JP encoding
#
# source://prism//lib/prism/node.rb#16661
Prism::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)

# x - ignores whitespace and allows comments in regular expressions
#
# source://prism//lib/prism/node.rb#16652
Prism::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)

# i - ignores the case of characters when matching
#
# source://prism//lib/prism/node.rb#16649
Prism::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)

# m - allows $ to match the end of lines within strings
#
# source://prism//lib/prism/node.rb#16655
Prism::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)

# o - only interpolates values into the regular expression once
#
# source://prism//lib/prism/node.rb#16658
Prism::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)

# u - forces the UTF-8 encoding
#
# source://prism//lib/prism/node.rb#16670
Prism::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)

# s - forces the Windows-31J encoding
#
# source://prism//lib/prism/node.rb#16667
Prism::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# source://prism//lib/prism/node.rb#13680
class Prism::RegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#13697
  sig do
    params(
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13707
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13787
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13712
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#13757
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#13688
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13722
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13717
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#13752
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#13685
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> RegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#13727
  sig { params(params: T.untyped).returns(Prism::RegularExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13712
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13742
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13782
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13767
  sig { returns(T::Boolean) }
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13762
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13802
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13772
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13777
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#13747
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#13682
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13827
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#13691
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13797
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13792
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#13694
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13837
    def type; end
  end
end

# source://prism//lib/prism/node_ext.rb#6
module Prism::RegularExpressionOptions
  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # source://prism//lib/prism/node_ext.rb#9
  def options; end
end

# Represents a required keyword parameter to a method, block, or lambda definition.
#
#     def a(b: )
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#13847
class Prism::RequiredKeywordParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, location: Location) -> void
  #
  # @return [RequiredKeywordParameterNode] a new instance of RequiredKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#13855
  sig { params(name: Symbol, name_loc: Prism::Location, location: Prism::Location).void }
  def initialize(name, name_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13862
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13867
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13877
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13872
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#13882
  sig { params(params: T.untyped).returns(Prism::RequiredKeywordParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13867
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13894
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13899
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#13849
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#13852
  sig { returns(Prism::Location) }
  def name_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13920
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13930
    def type; end
  end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# source://prism//lib/prism/node.rb#13940
class Prism::RequiredParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # source://prism//lib/prism/node.rb#13945
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13951
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13956
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13966
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13961
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredParameterNode
  #
  # source://prism//lib/prism/node.rb#13971
  sig { params(params: T.untyped).returns(Prism::RequiredParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13956
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#13982
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#13987
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#13942
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14007
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14017
    def type; end
  end
end

# Represents an expression modified with a rescue.
#
#     foo rescue nil
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14026
class Prism::RescueModifierNode < ::Prism::Node
  # def initialize: (expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location) -> void
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # source://prism//lib/prism/node.rb#14037
  sig do
    params(
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(expression, keyword_loc, rescue_expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14045
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14054
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14064
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14059
  def compact_child_nodes; end

  # def copy: (**params) -> RescueModifierNode
  #
  # source://prism//lib/prism/node.rb#14069
  sig { params(params: T.untyped).returns(Prism::RescueModifierNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14054
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14082
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism//lib/prism/node.rb#14028
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14092
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14087
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14031
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader rescue_expression: Node
  #
  # source://prism//lib/prism/node.rb#14034
  sig { returns(Prism::Node) }
  def rescue_expression; end

  # source://prism//lib/prism/node.rb#14049
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14116
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14126
    def type; end
  end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#       foo
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field.
# `ex` is in the `exception` field.
#
# source://prism//lib/prism/node.rb#14141
class Prism::RescueNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, reference: Node?, statements: StatementsNode?, consequent: RescueNode?, location: Location) -> void
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # source://prism//lib/prism/node.rb#14161
  sig do
    params(
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(Prism::Node),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::RescueNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14172
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14177
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14192
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14182
  def compact_child_nodes; end

  # attr_reader consequent: RescueNode?
  #
  # source://prism//lib/prism/node.rb#14158
  sig { returns(T.nilable(Prism::RescueNode)) }
  def consequent; end

  # def copy: (**params) -> RescueNode
  #
  # source://prism//lib/prism/node.rb#14197
  sig { params(params: T.untyped).returns(Prism::RescueNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14177
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14213
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader exceptions: Array[Node]
  #
  # source://prism//lib/prism/node.rb#14146
  sig { returns(T::Array[Prism::Node]) }
  def exceptions; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14228
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14218
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14143
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#14223
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#14149
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader reference: Node?
  #
  # source://prism//lib/prism/node.rb#14152
  sig { returns(T.nilable(Prism::Node)) }
  def reference; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#14155
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14268
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14278
    def type; end
  end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#14288
class Prism::RestParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # source://prism//lib/prism/node.rb#14299
  sig do
    params(
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14307
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14312
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14322
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14317
  def compact_child_nodes; end

  # def copy: (**params) -> RestParameterNode
  #
  # source://prism//lib/prism/node.rb#14327
  sig { params(params: T.untyped).returns(Prism::RestParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14312
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14340
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14350
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#14290
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#14293
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14345
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#14296
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14376
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14386
    def type; end
  end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# source://prism//lib/prism/node.rb#14395
class Prism::RetryNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # source://prism//lib/prism/node.rb#14397
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14402
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14407
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14417
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14412
  def compact_child_nodes; end

  # def copy: (**params) -> RetryNode
  #
  # source://prism//lib/prism/node.rb#14422
  sig { params(params: T.untyped).returns(Prism::RetryNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14407
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14432
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14437
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14456
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14466
    def type; end
  end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#14475
class Prism::ReturnNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, arguments: ArgumentsNode?, location: Location) -> void
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # source://prism//lib/prism/node.rb#14483
  sig do
    params(
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, arguments, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14490
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#14480
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14495
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14507
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14500
  def compact_child_nodes; end

  # def copy: (**params) -> ReturnNode
  #
  # source://prism//lib/prism/node.rb#14512
  sig { params(params: T.untyped).returns(Prism::ReturnNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14495
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14524
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14534
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14529
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14477
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14560
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14570
    def type; end
  end
end

# This class is meant to provide a compatibility layer between prism and
# Ripper. It functions by parsing the entire tree first and then walking it
# and executing each of the Ripper callbacks as it goes.
#
# This class is going to necessarily be slower than the native Ripper API. It
# is meant as a stopgap until developers migrate to using prism. It is also
# meant as a test harness for the prism parser.
#
# source://prism//lib/prism/ripper_compat.rb#13
class Prism::RipperCompat
  # Create a new RipperCompat object with the given source.
  #
  # @return [RipperCompat] a new instance of RipperCompat
  #
  # source://prism//lib/prism/ripper_compat.rb#67
  def initialize(source); end

  # The current column number of the parser.
  #
  # source://prism//lib/prism/ripper_compat.rb#64
  def column; end

  # True if the parser encountered an error during parsing.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/ripper_compat.rb#79
  def error?; end

  # The current line number of the parser.
  #
  # source://prism//lib/prism/ripper_compat.rb#61
  def lineno; end

  # Parse the source and return the result.
  #
  # source://prism//lib/prism/ripper_compat.rb#84
  def parse; end

  # The source that is being parsed.
  #
  # source://prism//lib/prism/ripper_compat.rb#58
  def source; end

  # This method is responsible for dispatching to the correct visitor method
  # based on the type of the node.
  #
  # source://prism//lib/prism/ripper_compat.rb#94
  def visit(node); end

  # Visit a CallNode node.
  #
  # source://prism//lib/prism/ripper_compat.rb#99
  def visit_call_node(node); end

  # Visit an IntegerNode node.
  #
  # source://prism//lib/prism/ripper_compat.rb#114
  def visit_integer_node(node); end

  # Visit a ProgramNode node.
  #
  # source://prism//lib/prism/ripper_compat.rb#142
  def visit_program_node(node); end

  # Visit a StatementsNode node.
  #
  # source://prism//lib/prism/ripper_compat.rb#120
  def visit_statements_node(node); end

  # Visit a token found during parsing.
  #
  # source://prism//lib/prism/ripper_compat.rb#128
  def visit_token(node); end

  private

  # source://prism//lib/prism/ripper_compat.rb#180
  def _dispatch0; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def _dispatch1(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def _dispatch2(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def _dispatch3(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#184
  def _dispatch4(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#185
  def _dispatch5(_, _, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#186
  def _dispatch7(_, _, _, _, _, _, _); end

  # This method is responsible for updating lineno and column information
  # to reflect the current node.
  #
  # This method could be drastically improved with some caching on the start
  # of every line, but for now it's good enough.
  #
  # source://prism//lib/prism/ripper_compat.rb#168
  def bounds(location); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_BEGIN(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_CHAR(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_END(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on___end__(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_alias(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_alias_error(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_aref(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_aref_field(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_arg_ambiguous(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_arg_paren(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_args_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_args_add_block(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_args_add_star(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_args_forward; end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_args_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_array(_); end

  # source://prism//lib/prism/ripper_compat.rb#184
  def on_aryptn(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_assign(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_assign_error(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_assoc_new(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_assoc_splat(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_assoclist_from_args(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_backref(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_backtick(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_bare_assoc_hash(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_begin(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_binary(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_block_var(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_blockarg(_); end

  # source://prism//lib/prism/ripper_compat.rb#184
  def on_bodystmt(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_brace_block(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_break(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_call(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_case(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_class(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_class_name_error(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_comma(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_command(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#184
  def on_command_call(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_comment(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_const(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_const_path_field(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_const_path_ref(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_const_ref(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_cvar(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_def(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_defined(_); end

  # source://prism//lib/prism/ripper_compat.rb#185
  def on_defs(_, _, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_do_block(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_dot2(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_dot3(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_dyna_symbol(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_else(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_elsif(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embdoc(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embdoc_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embdoc_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embexpr_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embexpr_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_embvar(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_ensure(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_excessed_comma; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_fcall(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_field(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_float(_); end

  # source://prism//lib/prism/ripper_compat.rb#184
  def on_fndptn(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_for(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_gvar(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_hash(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_heredoc_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_heredoc_dedent(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_heredoc_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_hshptn(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_ident(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_if(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_if_mod(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_ifop(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_ignored_nl(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_ignored_sp(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_imaginary(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_in(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_int(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_ivar(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_kw(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_kwrest_param(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_label(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_label_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_lambda(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_lbrace(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_lbracket(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_lparen(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_magic_comment(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_massign(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_method_add_arg(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_method_add_block(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_mlhs_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_mlhs_add_post(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_mlhs_add_star(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_mlhs_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_mlhs_paren(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_module(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_mrhs_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_mrhs_add_star(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_mrhs_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_mrhs_new_from_args(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_next(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_nl(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_nokw_param(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_op(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_opassign(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_operator_ambiguous(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_param_error(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#186
  def on_params(_, _, _, _, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_paren(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_parse_error(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_period(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_program(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_qsymbols_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_qsymbols_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_qsymbols_new; end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_qwords_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_qwords_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_qwords_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_rational(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_rbrace(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_rbracket(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_redo; end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_regexp_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_regexp_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_regexp_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_regexp_literal(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_regexp_new; end

  # source://prism//lib/prism/ripper_compat.rb#184
  def on_rescue(_, _, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_rescue_mod(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_rest_param(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_retry; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_return(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_return0; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_rparen(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_sclass(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_semicolon(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_sp(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_stmts_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_stmts_new; end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_string_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_string_concat(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_string_content; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_string_dvar(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_string_embexpr(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_string_literal(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_super(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_symbeg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_symbol(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_symbol_literal(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_symbols_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_symbols_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_symbols_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_tlambda(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_tlambeg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_top_const_field(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_top_const_ref(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_tstring_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_tstring_content(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_tstring_end(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_unary(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_undef(_); end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_unless(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_unless_mod(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_until(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_until_mod(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_var_alias(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_var_field(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_var_ref(_); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_vcall(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_void_stmt; end

  # source://prism//lib/prism/ripper_compat.rb#183
  def on_when(_, _, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_while(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_while_mod(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_word_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_word_new; end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_words_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_words_beg(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_words_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_words_sep(_); end

  # source://prism//lib/prism/ripper_compat.rb#182
  def on_xstring_add(_, _); end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_xstring_literal(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_xstring_new; end

  # source://prism//lib/prism/ripper_compat.rb#181
  def on_yield(_); end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_yield0; end

  # source://prism//lib/prism/ripper_compat.rb#180
  def on_zsuper; end

  # Lazily initialize the parse result.
  #
  # source://prism//lib/prism/ripper_compat.rb#176
  def result; end

  class << self
    # This is a convenience method that runs the SexpBuilderPP subclass parser.
    #
    # source://prism//lib/prism/ripper_compat.rb#157
    def sexp(source); end

    # This is a convenience method that runs the SexpBuilder subclass parser.
    #
    # source://prism//lib/prism/ripper_compat.rb#152
    def sexp_raw(source); end
  end
end

# This class mirrors the ::Ripper::SexpBuilder subclass of ::Ripper that
# returns the arrays of [type, *children].
#
# source://prism//lib/prism/ripper_compat.rb#16
class Prism::RipperCompat::SexpBuilder < ::Prism::RipperCompat
  private

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_BEGIN(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_CHAR(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_END(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on___end__(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_alias(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_alias_error(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_aref(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_aref_field(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_arg_ambiguous(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_arg_paren(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_args_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_args_add_block(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_args_add_star(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_args_forward(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_args_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_array(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_aryptn(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_assign(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_assign_error(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_assoc_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_assoc_splat(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_assoclist_from_args(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_backref(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_backtick(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_bare_assoc_hash(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_begin(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_binary(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_block_var(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_blockarg(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_bodystmt(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_brace_block(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_break(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_call(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_case(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_class(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_class_name_error(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_comma(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_command(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_command_call(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_comment(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_const(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_const_path_field(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_const_path_ref(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_const_ref(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_cvar(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_def(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_defined(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_defs(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_do_block(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_dot2(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_dot3(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_dyna_symbol(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_else(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_elsif(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embdoc(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embdoc_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embdoc_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embexpr_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embexpr_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_embvar(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_ensure(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_excessed_comma(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_fcall(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_field(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_float(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_fndptn(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_for(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_gvar(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_hash(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_heredoc_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_heredoc_dedent(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_heredoc_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_hshptn(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_ident(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_if(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_if_mod(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_ifop(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_ignored_nl(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_ignored_sp(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_imaginary(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_in(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_int(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_ivar(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_kw(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_kwrest_param(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_label(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_label_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_lambda(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_lbrace(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_lbracket(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_lparen(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_magic_comment(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_massign(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_method_add_arg(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_method_add_block(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mlhs_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mlhs_add_post(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mlhs_add_star(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mlhs_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mlhs_paren(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_module(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mrhs_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mrhs_add_star(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mrhs_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_mrhs_new_from_args(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_next(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_nl(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_nokw_param(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_op(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_opassign(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_operator_ambiguous(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_param_error(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_params(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_paren(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_parse_error(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_period(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_program(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_qsymbols_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_qsymbols_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_qsymbols_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_qwords_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_qwords_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_qwords_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_rational(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_rbrace(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_rbracket(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_redo(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_regexp_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_regexp_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_regexp_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_regexp_literal(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_regexp_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_rescue(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_rescue_mod(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_rest_param(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_retry(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_return(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_return0(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_rparen(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_sclass(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_semicolon(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_sp(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_stmts_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_stmts_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_concat(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_content(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_dvar(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_embexpr(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_string_literal(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_super(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_symbeg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_symbol(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_symbol_literal(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_symbols_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_symbols_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_symbols_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_tlambda(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_tlambeg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_top_const_field(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_top_const_ref(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_tstring_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_tstring_content(value); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_tstring_end(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_unary(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_undef(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_unless(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_unless_mod(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_until(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_until_mod(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_var_alias(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_var_field(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_var_ref(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_vcall(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_void_stmt(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_when(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_while(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_while_mod(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_word_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_word_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_words_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_words_beg(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_words_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#26
  def on_words_sep(value); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_xstring_add(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_xstring_literal(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_xstring_new(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_yield(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_yield0(*args); end

  # source://prism//lib/prism/ripper_compat.rb#20
  def on_zsuper(*args); end
end

# This class mirrors the ::Ripper::SexpBuilderPP subclass of ::Ripper that
# returns the same values as ::Ripper::SexpBuilder except with a couple of
# niceties that flatten linked lists into arrays.
#
# source://prism//lib/prism/ripper_compat.rb#35
class Prism::RipperCompat::SexpBuilderPP < ::Prism::RipperCompat::SexpBuilder
  private

  # source://prism//lib/prism/ripper_compat.rb#38
  def _dispatch_event_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def _dispatch_event_push(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_args_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_args_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_mlhs_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_mlhs_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_mrhs_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_mrhs_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_qsymbols_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_qsymbols_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_qwords_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_qwords_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_regexp_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_regexp_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_stmts_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_stmts_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_string_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_symbols_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_symbols_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_word_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_word_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_words_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_words_new; end

  # source://prism//lib/prism/ripper_compat.rb#42
  def on_xstring_add(list, item); end

  # source://prism//lib/prism/ripper_compat.rb#38
  def on_xstring_new; end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# source://prism//lib/prism/node.rb#14579
class Prism::SelfNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # source://prism//lib/prism/node.rb#14581
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14586
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14591
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14601
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14596
  def compact_child_nodes; end

  # def copy: (**params) -> SelfNode
  #
  # source://prism//lib/prism/node.rb#14606
  sig { params(params: T.untyped).returns(Prism::SelfNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14591
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14616
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14621
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14640
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14650
    def type; end
  end
end

# A module responsible for deserializing parse results.
#
# source://prism//lib/prism/serialize.rb#23
module Prism::Serialize
  class << self
    # Deserialize the AST represented by the given string into a parse result.
    #
    # source://prism//lib/prism/serialize.rb#37
    def load(input, serialized); end

    # Deserialize the tokens represented by the given string into a parse
    # result.
    #
    # source://prism//lib/prism/serialize.rb#49
    def load_tokens(source, serialized); end
  end
end

# source://prism//lib/prism/serialize.rb#53
class Prism::Serialize::Loader
  # @return [Loader] a new instance of Loader
  #
  # source://prism//lib/prism/serialize.rb#58
  def initialize(source, serialized); end

  # Returns the value of attribute constant_pool.
  #
  # source://prism//lib/prism/serialize.rb#55
  def constant_pool; end

  # Returns the value of attribute constant_pool_offset.
  #
  # source://prism//lib/prism/serialize.rb#55
  def constant_pool_offset; end

  # Returns the value of attribute encoding.
  #
  # source://prism//lib/prism/serialize.rb#54
  def encoding; end

  # Returns the value of attribute input.
  #
  # source://prism//lib/prism/serialize.rb#54
  def input; end

  # Returns the value of attribute io.
  #
  # source://prism//lib/prism/serialize.rb#54
  def io; end

  # source://prism//lib/prism/serialize.rb#92
  def load_comments; end

  # source://prism//lib/prism/serialize.rb#82
  def load_encoding; end

  # source://prism//lib/prism/serialize.rb#73
  def load_header; end

  # source://prism//lib/prism/serialize.rb#102
  def load_metadata; end

  # source://prism//lib/prism/serialize.rb#134
  def load_nodes; end

  # source://prism//lib/prism/serialize.rb#147
  def load_result; end

  # source://prism//lib/prism/serialize.rb#88
  def load_start_line; end

  # source://prism//lib/prism/serialize.rb#110
  def load_tokens; end

  # source://prism//lib/prism/serialize.rb#123
  def load_tokens_result; end

  # Returns the value of attribute serialized.
  #
  # source://prism//lib/prism/serialize.rb#54
  def serialized; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/serialize.rb#55
  def source; end

  # Returns the value of attribute start_line.
  #
  # source://prism//lib/prism/serialize.rb#56
  def start_line; end

  private

  # source://prism//lib/prism/serialize.rb#205
  def load_constant(index); end

  # source://prism//lib/prism/serialize.rb#181
  def load_embedded_string; end

  # source://prism//lib/prism/serialize.rb#197
  def load_location; end

  # source://prism//lib/prism/serialize.rb#236
  def load_node; end

  # source://prism//lib/prism/serialize.rb#230
  def load_optional_constant; end

  # source://prism//lib/prism/serialize.rb#201
  def load_optional_location; end

  # source://prism//lib/prism/serialize.rb#174
  def load_optional_node; end

  # source://prism//lib/prism/serialize.rb#226
  def load_required_constant; end

  # source://prism//lib/prism/serialize.rb#170
  def load_serialized_length; end

  # source://prism//lib/prism/serialize.rb#185
  def load_string; end

  # variable-length integer using https://en.wikipedia.org/wiki/LEB128
  # This is also what protobuf uses: https://protobuf.dev/programming-guides/encoding/#varints
  #
  # source://prism//lib/prism/serialize.rb#156
  def load_varint; end
end

# The major version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#26
Prism::Serialize::MAJOR_VERSION = T.let(T.unsafe(nil), Integer)

# The minor version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#30
Prism::Serialize::MINOR_VERSION = T.let(T.unsafe(nil), Integer)

# The patch version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#34
Prism::Serialize::PATCH_VERSION = T.let(T.unsafe(nil), Integer)

# The token types that can be indexed by their enum values.
#
# source://prism//lib/prism/serialize.rb#1124
Prism::Serialize::TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14659
class Prism::SingletonClassNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # source://prism//lib/prism/node.rb#14679
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14690
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism//lib/prism/node.rb#14673
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14695
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14734
  sig { returns(String) }
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14664
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14708
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14700
  def compact_child_nodes; end

  # def copy: (**params) -> SingletonClassNode
  #
  # source://prism//lib/prism/node.rb#14713
  sig { params(params: T.untyped).returns(Prism::SingletonClassNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14695
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14729
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14744
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14676
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # attr_reader expression: Node
  #
  # source://prism//lib/prism/node.rb#14670
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14749
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#14661
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14739
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#14667
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14780
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14790
    def type; end
  end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# source://prism//lib/prism/parse_result.rb#7
class Prism::Source
  # Create a new source object with the given source code and newline byte
  # offsets. If no newline byte offsets are given, they will be computed from
  # the source code.
  #
  # @return [Source] a new instance of Source
  #
  # source://prism//lib/prism/parse_result.rb#20
  def initialize(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end

  # Return the column number in characters for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#55
  def character_column(byte_offset); end

  # Return the character offset for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#50
  def character_offset(byte_offset); end

  # Return the column number for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#45
  def column(byte_offset); end

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#34
  def line(byte_offset); end

  sig { params(value: Integer).returns(Integer) }
  def line_offset(value); end

  # Return the byte offset of the start of the line corresponding to the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#40
  def line_start(byte_offset); end

  # The list of newline byte offsets in the source code.
  #
  # source://prism//lib/prism/parse_result.rb#15
  sig { returns(T::Array[Integer]) }
  def offsets; end

  # Perform a byteslice on the source code using the given byte offset and
  # byte length.
  #
  # source://prism//lib/prism/parse_result.rb#28
  def slice(byte_offset, length); end

  # The source code that this source object represents.
  #
  # source://prism//lib/prism/parse_result.rb#9
  sig { returns(String) }
  def source; end

  # The line number where this source starts.
  #
  # source://prism//lib/prism/parse_result.rb#12
  def start_line; end

  # The line number where this source starts.
  #
  # source://prism//lib/prism/parse_result.rb#12
  def start_line=(_arg0); end

  private

  # Find all of the newlines in the source code and return their byte offsets
  # from the start of the string an array.
  #
  # source://prism//lib/prism/parse_result.rb#83
  def compute_offsets(code); end

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#63
  def find_line(byte_offset); end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14799
class Prism::SourceEncodingNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # source://prism//lib/prism/node.rb#14801
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14806
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14811
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14821
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14816
  def compact_child_nodes; end

  # def copy: (**params) -> SourceEncodingNode
  #
  # source://prism//lib/prism/node.rb#14826
  sig { params(params: T.untyped).returns(Prism::SourceEncodingNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14811
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14836
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14841
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14860
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14870
    def type; end
  end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#14879
class Prism::SourceFileNode < ::Prism::Node
  # def initialize: (filepath: String, location: Location) -> void
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # source://prism//lib/prism/node.rb#14884
  sig { params(filepath: String, location: Prism::Location).void }
  def initialize(filepath, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14890
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14895
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14905
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14900
  def compact_child_nodes; end

  # def copy: (**params) -> SourceFileNode
  #
  # source://prism//lib/prism/node.rb#14910
  sig { params(params: T.untyped).returns(Prism::SourceFileNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14895
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#14921
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader filepath: String
  #
  # source://prism//lib/prism/node.rb#14881
  sig { returns(String) }
  def filepath; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#14926
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14946
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14956
    def type; end
  end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#14965
class Prism::SourceLineNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # source://prism//lib/prism/node.rb#14967
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14972
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14977
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14987
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14982
  def compact_child_nodes; end

  # def copy: (**params) -> SourceLineNode
  #
  # source://prism//lib/prism/node.rb#14992
  sig { params(params: T.untyped).returns(Prism::SourceLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14977
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15002
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15007
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15026
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15036
    def type; end
  end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# source://prism//lib/prism/node.rb#15045
class Prism::SplatNode < ::Prism::Node
  # def initialize: (operator_loc: Location, expression: Node?, location: Location) -> void
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # source://prism//lib/prism/node.rb#15053
  sig { params(operator_loc: Prism::Location, expression: T.nilable(Prism::Node), location: Prism::Location).void }
  def initialize(operator_loc, expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15060
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15065
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15077
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15070
  def compact_child_nodes; end

  # def copy: (**params) -> SplatNode
  #
  # source://prism//lib/prism/node.rb#15082
  sig { params(params: T.untyped).returns(Prism::SplatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15065
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15094
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism//lib/prism/node.rb#15050
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15104
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#15099
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#15047
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15130
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15140
    def type; end
  end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15149
class Prism::StatementsNode < ::Prism::Node
  # def initialize: (body: Array[Node], location: Location) -> void
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # source://prism//lib/prism/node.rb#15154
  sig { params(body: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(body, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15160
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader body: Array[Node]
  #
  # source://prism//lib/prism/node.rb#15151
  sig { returns(T::Array[Prism::Node]) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15165
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15175
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15170
  def compact_child_nodes; end

  # def copy: (**params) -> StatementsNode
  #
  # source://prism//lib/prism/node.rb#15180
  sig { params(params: T.untyped).returns(Prism::StatementsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15165
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15191
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15196
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15216
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15226
    def type; end
  end
end

# Flags for string nodes.
#
# source://prism//lib/prism/node.rb#16674
module Prism::StringFlags; end

# frozen by virtue of a `frozen_string_literal` comment
#
# source://prism//lib/prism/node.rb#16676
Prism::StringFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# Represents a string literal, a string contained within a `%w` list, or
# plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# source://prism//lib/prism/node.rb#15242
class Prism::StringNode < ::Prism::Node
  # def initialize: (flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [StringNode] a new instance of StringNode
  #
  # source://prism//lib/prism/node.rb#15259
  sig do
    params(
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15269
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15274
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#15324
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15253
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15284
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15279
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#15319
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#15250
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> StringNode
  #
  # source://prism//lib/prism/node.rb#15289
  sig { params(params: T.untyped).returns(Prism::StringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15274
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15304
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15309
  sig { returns(T::Boolean) }
  def frozen?; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15329
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#15314
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15247
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15354
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#15256
  sig { returns(String) }
  def unescaped; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#15244
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15364
    def type; end
  end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15376
class Prism::SuperNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Node?, location: Location) -> void
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://prism//lib/prism/node.rb#15393
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15403
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#15384
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism//lib/prism/node.rb#15390
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15408
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15421
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15413
  def compact_child_nodes; end

  # def copy: (**params) -> SuperNode
  #
  # source://prism//lib/prism/node.rb#15426
  sig { params(params: T.untyped).returns(Prism::SuperNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15408
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15441
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15461
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#15446
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15378
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#15451
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15381
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#15456
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15387
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15495
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15505
    def type; end
  end
end

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# source://prism//lib/prism/node.rb#15517
class Prism::SymbolNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # source://prism//lib/prism/node.rb#15531
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, value_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15540
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15545
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#15589
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15525
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15555
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15550
  def compact_child_nodes; end

  # def copy: (**params) -> SymbolNode
  #
  # source://prism//lib/prism/node.rb#15560
  sig { params(params: T.untyped).returns(Prism::SymbolNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15545
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15574
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15594
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#15579
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15519
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15617
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#15528
  sig { returns(String) }
  def unescaped; end

  # def value: () -> String?
  #
  # source://prism//lib/prism/node.rb#15584
  sig { returns(T.nilable(String)) }
  def value; end

  # attr_reader value_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15522
  sig { returns(T.nilable(Prism::Location)) }
  def value_loc; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15627
    def type; end
  end
end

# This represents a token from the Ruby source.
#
# source://prism//lib/prism/parse_result.rb#419
class Prism::Token
  # Create a new token object with the given type, value, and location.
  #
  # @return [Token] a new instance of Token
  #
  # source://prism//lib/prism/parse_result.rb#430
  sig { params(type: T.untyped, value: String, location: Prism::Location).void }
  def initialize(type, value, location); end

  # Returns true if the given other token is equal to this token.
  #
  # source://prism//lib/prism/parse_result.rb#457
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # Implement the hash pattern matching interface for Token.
  #
  # source://prism//lib/prism/parse_result.rb#437
  sig { params(keys: T.untyped).returns(T.untyped) }
  def deconstruct_keys(keys); end

  # A Location object representing the location of this token in the source.
  #
  # source://prism//lib/prism/parse_result.rb#427
  sig { returns(Prism::Location) }
  def location; end

  # Implement the pretty print interface for Token.
  #
  # source://prism//lib/prism/parse_result.rb#442
  sig { params(q: T.untyped).returns(T.untyped) }
  def pretty_print(q); end

  # The type of token that this token is.
  #
  # source://prism//lib/prism/parse_result.rb#421
  sig { returns(T.untyped) }
  def type; end

  # A byteslice of the source that this token represents.
  #
  # source://prism//lib/prism/parse_result.rb#424
  sig { returns(String) }
  def value; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# source://prism//lib/prism/node.rb#15636
class Prism::TrueNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # source://prism//lib/prism/node.rb#15638
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15643
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15648
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15658
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15653
  def compact_child_nodes; end

  # def copy: (**params) -> TrueNode
  #
  # source://prism//lib/prism/node.rb#15663
  sig { params(params: T.untyped).returns(Prism::TrueNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15648
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15673
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15678
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15697
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15707
    def type; end
  end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15716
class Prism::UndefNode < ::Prism::Node
  # def initialize: (names: Array[Node], keyword_loc: Location, location: Location) -> void
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # source://prism//lib/prism/node.rb#15724
  sig { params(names: T::Array[Prism::Node], keyword_loc: Prism::Location, location: Prism::Location).void }
  def initialize(names, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15731
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15736
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15746
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15741
  def compact_child_nodes; end

  # def copy: (**params) -> UndefNode
  #
  # source://prism//lib/prism/node.rb#15751
  sig { params(params: T.untyped).returns(Prism::UndefNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15736
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15763
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15773
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#15768
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15721
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader names: Array[Node]
  #
  # source://prism//lib/prism/node.rb#15718
  sig { returns(T::Array[Prism::Node]) }
  def names; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15794
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15804
    def type; end
  end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15816
class Prism::UnlessNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, predicate: Node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # source://prism//lib/prism/node.rb#15836
  sig do
    params(
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15847
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15856
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15870
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15861
  def compact_child_nodes; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#15830
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> UnlessNode
  #
  # source://prism//lib/prism/node.rb#15875
  sig { params(params: T.untyped).returns(Prism::UnlessNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15856
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#15891
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#15906
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15833
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#15911
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#15896
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15818
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism//lib/prism/node.rb#15821
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism//lib/prism/node.rb#15851
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#15827
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#15901
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15824
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15947
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15957
    def type; end
  end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15969
class Prism::UntilNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # source://prism//lib/prism/node.rb#15986
  sig do
    params(
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15996
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16053
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16005
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#16048
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#15974
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16018
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16010
  def compact_child_nodes; end

  # def copy: (**params) -> UntilNode
  #
  # source://prism//lib/prism/node.rb#16023
  sig { params(params: T.untyped).returns(Prism::UntilNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16005
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#16038
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#16058
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16043
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15971
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism//lib/prism/node.rb#15977
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism//lib/prism/node.rb#16000
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#15980
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16089
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#15983
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16099
    def type; end
  end
end

# The version constant is set by reading the result of calling pm_version.
Prism::VERSION = T.let(T.unsafe(nil), String)

# A visitor is a class that provides a default implementation for every accept
# method defined on the nodes. This means it can walk a tree without the
# caller needing to define any special handling. This allows you to handle a
# subset of the tree, while still walking the whole tree.
#
# For example, to find all of the method calls that call the `foo` method, you
# could write:
#
#     class FooCalls < Prism::Visitor
#       def visit_call_node(node)
#         if node.name == "foo"
#           # Do something with the node
#         end
#
#         # Call super so that the visitor continues walking the tree
#         super
#       end
#     end
#
# source://prism//lib/prism/visitor.rb#50
class Prism::Visitor < ::Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AliasGlobalVariableNode).void }
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AlternationPatternNode).void }
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AndNode).void }
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ArgumentsNode).void }
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ArrayNode).void }
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ArrayPatternNode).void }
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AssocNode).void }
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::AssocSplatNode).void }
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BackReferenceReadNode).void }
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BeginNode).void }
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BlockLocalVariableNode).void }
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BlockNode).void }
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BlockParameterNode).void }
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BlockParametersNode).void }
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::BreakNode).void }
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CallNode).void }
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  # Visit a CapturePatternNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CapturePatternNode).void }
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CaseMatchNode).void }
  def visit_case_match_node(node); end

  # Visit a CaseNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::CaseNode).void }
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassNode).void }
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableAndWriteNode).void }
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableOperatorWriteNode).void }
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableOrWriteNode).void }
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableReadNode).void }
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableTargetNode).void }
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ClassVariableWriteNode).void }
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathAndWriteNode).void }
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathOperatorWriteNode).void }
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathOrWriteNode).void }
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathTargetNode).void }
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantTargetNode).void }
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::DefNode).void }
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::DefinedNode).void }
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ElseNode).void }
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::EmbeddedStatementsNode).void }
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::EmbeddedVariableNode).void }
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::EnsureNode).void }
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::FalseNode).void }
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::FindPatternNode).void }
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::FlipFlopNode).void }
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::FloatNode).void }
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ForNode).void }
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ForwardingArgumentsNode).void }
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ForwardingParameterNode).void }
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ForwardingSuperNode).void }
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableAndWriteNode).void }
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableOperatorWriteNode).void }
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableOrWriteNode).void }
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableReadNode).void }
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableTargetNode).void }
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::GlobalVariableWriteNode).void }
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::HashNode).void }
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::HashPatternNode).void }
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::IfNode).void }
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ImaginaryNode).void }
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ImplicitNode).void }
  def visit_implicit_node(node); end

  # Visit a InNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InNode).void }
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::IndexAndWriteNode).void }
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::IndexOperatorWriteNode).void }
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::IndexOrWriteNode).void }
  def visit_index_or_write_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableAndWriteNode).void }
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableOperatorWriteNode).void }
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableOrWriteNode).void }
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableReadNode).void }
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableTargetNode).void }
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InstanceVariableWriteNode).void }
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::IntegerNode).void }
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InterpolatedMatchLastLineNode).void }
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InterpolatedRegularExpressionNode).void }
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InterpolatedStringNode).void }
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InterpolatedSymbolNode).void }
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::InterpolatedXStringNode).void }
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::KeywordHashNode).void }
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::KeywordRestParameterNode).void }
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LambdaNode).void }
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableReadNode).void }
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableTargetNode).void }
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MatchLastLineNode).void }
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MatchPredicateNode).void }
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MatchRequiredNode).void }
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MatchWriteNode).void }
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MissingNode).void }
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ModuleNode).void }
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MultiTargetNode).void }
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::NextNode).void }
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::NilNode).void }
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::NoKeywordsParameterNode).void }
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::NumberedReferenceReadNode).void }
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::OptionalKeywordParameterNode).void }
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::OptionalParameterNode).void }
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::OrNode).void }
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ParametersNode).void }
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ParenthesesNode).void }
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::PinnedExpressionNode).void }
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::PinnedVariableNode).void }
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::PostExecutionNode).void }
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::PreExecutionNode).void }
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ProgramNode).void }
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RangeNode).void }
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RationalNode).void }
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RedoNode).void }
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RegularExpressionNode).void }
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RequiredKeywordParameterNode).void }
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RequiredParameterNode).void }
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RescueModifierNode).void }
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RescueNode).void }
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RestParameterNode).void }
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::RetryNode).void }
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::ReturnNode).void }
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SelfNode).void }
  def visit_self_node(node); end

  # Visit a SingletonClassNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SourceEncodingNode).void }
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SourceFileNode).void }
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SourceLineNode).void }
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SplatNode).void }
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::StatementsNode).void }
  def visit_statements_node(node); end

  # Visit a StringNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::StringNode).void }
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SuperNode).void }
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::SymbolNode).void }
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::TrueNode).void }
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::UndefNode).void }
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::UnlessNode).void }
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::UntilNode).void }
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::WhenNode).void }
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::WhileNode).void }
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::XStringNode).void }
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # source://prism//lib/prism/visitor.rb#26
  sig { params(node: Prism::YieldNode).void }
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#16110
class Prism::WhenNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, conditions: Array[Node], statements: StatementsNode?, location: Location) -> void
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # source://prism//lib/prism/node.rb#16121
  sig do
    params(
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, conditions, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16129
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16134
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16147
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16139
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism//lib/prism/node.rb#16115
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # def copy: (**params) -> WhenNode
  #
  # source://prism//lib/prism/node.rb#16152
  sig { params(params: T.untyped).returns(Prism::WhenNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16134
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#16165
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#16175
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16170
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16112
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#16118
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16202
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16212
    def type; end
  end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#16224
class Prism::WhileNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # source://prism//lib/prism/node.rb#16241
  sig do
    params(
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      flags: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16251
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16308
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16260
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#16303
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#16229
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16273
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16265
  def compact_child_nodes; end

  # def copy: (**params) -> WhileNode
  #
  # source://prism//lib/prism/node.rb#16278
  sig { params(params: T.untyped).returns(Prism::WhileNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16260
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#16293
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#16313
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16298
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16226
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism//lib/prism/node.rb#16232
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism//lib/prism/node.rb#16255
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#16235
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16344
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism//lib/prism/node.rb#16238
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16354
    def type; end
  end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# source://prism//lib/prism/node.rb#16363
class Prism::XStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location) -> void
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # source://prism//lib/prism/node.rb#16377
  sig do
    params(
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16386
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16391
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#16435
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#16371
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16401
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16396
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#16430
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#16368
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> XStringNode
  #
  # source://prism//lib/prism/node.rb#16406
  sig { params(params: T.untyped).returns(Prism::XStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16391
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#16420
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#16440
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#16425
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#16365
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16463
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#16374
  sig { returns(String) }
  def unescaped; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16473
    def type; end
  end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#16482
class Prism::YieldNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # source://prism//lib/prism/node.rb#16496
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16505
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#16490
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16510
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16522
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16515
  def compact_child_nodes; end

  # def copy: (**params) -> YieldNode
  #
  # source://prism//lib/prism/node.rb#16527
  sig { params(params: T.untyped).returns(Prism::YieldNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16510
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism//lib/prism/node.rb#16541
  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  # def inspect(inspector: NodeInspector) -> String
  #
  # source://prism//lib/prism/node.rb#16561
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16546
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16484
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#16551
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#16487
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#16556
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#16493
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16589
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16599
    def type; end
  end
end
