# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tapioca` gem.
# Please instead update this file by running `bin/tapioca gem tapioca`.


class Bundler::Dependency < ::Gem::Dependency
  include ::Tapioca::BundlerExt::AutoRequireHook
end

# source://tapioca//lib/tapioca/helpers/git_attributes.rb#4
class GitAttributes
  class << self
    # : (Pathname path) -> void
    #
    # source://tapioca//lib/tapioca/helpers/git_attributes.rb#9
    sig { params(path: ::Pathname).void }
    def create_generated_attribute_file(path); end

    # : (Pathname path) -> void
    #
    # source://tapioca//lib/tapioca/helpers/git_attributes.rb#16
    sig { params(path: ::Pathname).void }
    def create_vendored_attribute_file(path); end

    private

    # : (Pathname path, String content) -> void
    #
    # source://tapioca//lib/tapioca/helpers/git_attributes.rb#25
    sig { params(path: ::Pathname, content: ::String).void }
    def create_gitattributes_file(path, content); end
  end
end

# We need to do the alias-method-chain dance since Bootsnap does the same,
# and prepended modules and alias-method-chain don't play well together.
#
# So, why does Bootsnap do alias-method-chain and not prepend? Glad you asked!
# That's because RubyGems does alias-method-chain for Kernel#require and such,
# so, if Bootsnap were to do prepend, it might end up breaking RubyGems.
#
# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#64
class Module
  # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#97
  def append_features(constant); end

  # source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#67
  def autoload(const_name, path); end

  # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#107
  def extend_object(obj); end

  # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#87
  def prepend_features(constant); end
end

# source://tapioca//lib/tapioca/rbi_ext/model.rb#4
module RBI; end

# source://tapioca//lib/tapioca/rbi_ext/model.rb#5
class RBI::Tree < ::RBI::NodeWithComments
  # source://rbi/0.3.3/lib/rbi/model.rb#119
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # source://rbi/0.3.3/lib/rbi/model.rb#126
  def <<(node); end

  # source://rbi/0.3.3/lib/rbi/rewriters/add_sig_templates.rb#63
  def add_sig_templates!(with_todo_comment: T.unsafe(nil)); end

  # source://rbi/0.3.3/lib/rbi/rewriters/annotate.rb#46
  def annotate!(annotation, annotate_scopes: T.unsafe(nil), annotate_properties: T.unsafe(nil)); end

  # : (String name, ?superclass_name: String?) ?{ (RBI::Scope scope) -> void } -> Scope
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#32
  sig do
    params(
      name: ::String,
      superclass_name: T.nilable(::String),
      block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)
    ).returns(::RBI::Scope)
  end
  def create_class(name, superclass_name: T.unsafe(nil), &block); end

  # : (String name, value: String) -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#39
  sig { params(name: ::String, value: ::String).void }
  def create_constant(name, value:); end

  # : (String name) -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#49
  sig { params(name: ::String).void }
  def create_extend(name); end

  # : (String name) -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#44
  sig { params(name: ::String).void }
  def create_include(name); end

  # : (String name, ?parameters: Array[TypedParam], ?return_type: String?, ?class_method: bool, ?visibility: RBI::Visibility, ?comments: Array[RBI::Comment]) ?{ (RBI::Method node) -> void } -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#65
  sig do
    params(
      name: ::String,
      parameters: T::Array[::RBI::TypedParam],
      return_type: T.nilable(::String),
      class_method: T::Boolean,
      visibility: ::RBI::Visibility,
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Method).void)
    ).void
  end
  def create_method(name, parameters: T.unsafe(nil), return_type: T.unsafe(nil), class_method: T.unsafe(nil), visibility: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (String name) -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#54
  sig { params(name: ::String).void }
  def create_mixes_in_class_methods(name); end

  # : (String name) ?{ (Scope scope) -> void } -> Scope
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#25
  sig { params(name: ::String, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_module(name, &block); end

  # : (::Module constant) ?{ (Scope scope) -> void } -> Scope
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#9
  sig { params(constant: ::Module, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_path(constant, &block); end

  # : (String name, type: String, ?variance: Symbol, ?fixed: String?, ?upper: String?, ?lower: String?) -> void
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#59
  sig do
    params(
      name: ::String,
      type: ::String,
      variance: ::Symbol,
      fixed: T.nilable(::String),
      upper: T.nilable(::String),
      lower: T.nilable(::String)
    ).void
  end
  def create_type_variable(name, type:, variance: T.unsafe(nil), fixed: T.unsafe(nil), upper: T.unsafe(nil), lower: T.unsafe(nil)); end

  # source://rbi/0.3.3/lib/rbi/rewriters/deannotate.rb#38
  def deannotate!(annotation); end

  # source://rbi/0.3.3/lib/rbi/model.rb#132
  def empty?; end

  # source://rbi/0.3.3/lib/rbi/rewriters/filter_versions.rb#113
  def filter_versions!(version); end

  # source://rbi/0.3.3/lib/rbi/rewriters/flatten_singleton_methods.rb#58
  def flatten_singleton_methods!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/flatten_visibilities.rb#57
  def flatten_visibilities!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/group_nodes.rb#78
  def group_nodes!; end

  # source://rbi/0.3.3/lib/rbi/index.rb#64
  def index; end

  # source://rbi/0.3.3/lib/rbi/rewriters/merge_trees.rb#314
  def merge(other, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  # source://rbi/0.3.3/lib/rbi/rewriters/nest_non_public_members.rb#43
  def nest_non_public_members!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/nest_singleton_methods.rb#33
  def nest_singleton_methods!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/nest_top_level_members.rb#60
  def nest_top_level_members!; end

  # source://rbi/0.3.3/lib/rbi/model.rb#116
  def nodes; end

  # source://rbi/0.3.3/lib/rbi/rewriters/attr_to_methods.rb#50
  def replace_attributes_with_methods!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/sort_nodes.rb#118
  def sort_nodes!; end

  # source://rbi/0.3.3/lib/rbi/rewriters/translate_rbs_sigs.rb#82
  def translate_rbs_sigs!; end

  private

  # : (RBI::Node node) -> RBI::Node
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#98
  sig { params(node: ::RBI::Node).returns(::RBI::Node) }
  def create_node(node); end

  # : -> Hash[String, RBI::Node]
  #
  # source://tapioca//lib/tapioca/rbi_ext/model.rb#93
  sig { returns(T::Hash[::String, ::RBI::Node]) }
  def nodes_cache; end
end

# source://tapioca//lib/tapioca/rbi_ext/model.rb#108
class RBI::TypedParam < ::T::Struct
  const :param, ::RBI::Param
  const :type, ::String

  class << self
    # source://sorbet-runtime/0.5.12152/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#5
module T::Generic
  include ::Kernel

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#13
  def [](*types); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#47
  def has_attached_class!(variance = T.unsafe(nil), &bounds_proc); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#21
  def type_member(variance = T.unsafe(nil), &bounds_proc); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#34
  def type_template(variance = T.unsafe(nil), &bounds_proc); end
end

# This module intercepts calls to generic type instantiations and type variable definitions.
# Tapioca stores the data from those calls in a `GenericTypeRegistry` which can then be used
# to look up the original call details when we are trying to do code generation.
#
# We are interested in the data of the `[]`, `type_member` and `type_template` calls which
# are all needed to generate good generic information at runtime.
#
# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#12
module T::Generic::TypeStoragePatch
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#13
  def [](*types); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#47
  def has_attached_class!(variance = T.unsafe(nil), &bounds_proc); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#21
  def type_member(variance = T.unsafe(nil), &bounds_proc); end

  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#34
  def type_template(variance = T.unsafe(nil), &bounds_proc); end
end

# source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#54
module T::Helpers
  # source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#56
  def requires_ancestor(&block); end
end

class T::InexactStruct
  include ::T::Props
  include ::T::Props::Plugin
  include ::T::Props::Optional
  include ::T::Props::PrettyPrintable
  include ::T::Props::Serializable
  include ::T::Props::WeakConstructor
  include ::T::Props::Constructor
  extend ::T::Props::ClassMethods
  extend ::T::Props::Plugin::ClassMethods
  extend ::T::Props::Serializable::ClassMethods
end

# source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#28
module T::Private::Methods
  class << self
    # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#30
    def finalize_proc(decl); end
  end
end

class T::Private::Methods::Declaration < ::Struct
  def bind; end
  def bind=(_); end
  def checked; end
  def checked=(_); end
  def finalized; end
  def finalized=(_); end
  def mod; end
  def mod=(_); end
  def mode; end
  def mode=(_); end
  def on_failure; end
  def on_failure=(_); end
  def override_allow_incompatible; end
  def override_allow_incompatible=(_); end
  def params; end
  def params=(_); end
  def raw; end
  def raw=(_); end
  def returns; end
  def returns=(_); end
  def type_parameters; end
  def type_parameters=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class T::Private::Methods::DeclarationBlock < ::Struct
  def blk; end
  def blk=(_); end
  def final; end
  def final=(_); end
  def loc; end
  def loc=(_); end
  def mod; end
  def mod=(_); end
  def raw; end
  def raw=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#29
module T::Private::Methods::ProcBindPatch
  # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#30
  def finalize_proc(decl); end
end

module T::Private::Retry; end
module T::Private::Retry::RETRY; end

class T::Types::Proc < ::T::Types::Base
  # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#7
  def initialize(arg_types, returns, bind = T.unsafe(nil)); end

  # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#15
  def name; end
end

# source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#6
module T::Types::ProcBindPatch
  # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#7
  def initialize(arg_types, returns, bind = T.unsafe(nil)); end

  # source://tapioca//lib/tapioca/sorbet_ext/proc_bind_patch.rb#15
  def name; end
end

# source://tapioca//lib/tapioca/sorbet_ext/name_patch.rb#6
class T::Types::Simple < ::T::Types::Base
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#70
  def name; end
end

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#65
module T::Types::Simple::GenericPatch
  # This method intercepts calls to the `name` method for simple types, so that
  # it can ask the name to the type if the type is generic, since, by this point,
  # we've created a clone of that type with the `name` method returning the
  # appropriate name for that specific concrete type.
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#70
  def name; end
end

# source://tapioca//lib/tapioca/sorbet_ext/name_patch.rb#7
module T::Types::Simple::NamePatch
  # source://tapioca//lib/tapioca/sorbet_ext/name_patch.rb#10
  def name; end

  # source://tapioca//lib/tapioca/sorbet_ext/name_patch.rb#16
  def qualified_name_of(constant); end
end

# : UnboundMethod
#
# source://tapioca//lib/tapioca/sorbet_ext/name_patch.rb#8
T::Types::Simple::NamePatch::NAME_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#87
module T::Utils::Private
  class << self
    # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#89
    def coerce_and_check_module_types(val, check_val, check_module_type); end
  end
end

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#88
module T::Utils::Private::PrivateCoercePatch
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#89
  def coerce_and_check_module_types(val, check_val, check_module_type); end
end

# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#4
module Tapioca
  class << self
    # : [Result] { -> Result } -> Result
    #
    # source://tapioca//lib/tapioca.rb#16
    def silence_warnings(&blk); end
  end
end

# : String
#
# source://tapioca//lib/tapioca.rb#35
Tapioca::BINARY_FILE = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#5
module Tapioca::BundlerExt; end

# This is a module that gets prepended to `Bundler::Dependency` and
# makes sure even gems marked as `require: false` are required during
# `Bundler.require`.
#
# source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#9
module Tapioca::BundlerExt::AutoRequireHook
  requires_ancestor { Bundler::Dependency }

  # : -> untyped
  #
  # source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#41
  sig { returns(T.untyped) }
  def autorequire; end

  class << self
    # @return [Boolean]
    #
    # source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#26
    def enabled?; end

    # : (untyped name) -> bool
    #
    # source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#22
    sig { params(name: T.untyped).returns(T::Boolean) }
    def excluded?(name); end

    # : [Result] (exclude: Array[String]) { -> Result } -> Result
    #
    # source://tapioca//lib/tapioca/bundler_ext/auto_require_hook.rb#31
    sig do
      type_parameters(:Result)
        .params(
          exclude: T::Array[::String],
          blk: T.proc.returns(T.type_parameter(:Result))
        ).returns(T.type_parameter(:Result))
    end
    def override_require_false(exclude:, &blk); end
  end
end

# source://tapioca//lib/tapioca.rb#55
Tapioca::CENTRAL_REPO_ANNOTATIONS_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca.rb#54
Tapioca::CENTRAL_REPO_INDEX_PATH = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca.rb#53
Tapioca::CENTRAL_REPO_ROOT_URI = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/cli.rb#5
class Tapioca::Cli < ::Thor
  include ::Tapioca::CliHelper
  include ::Tapioca::ConfigHelper
  include ::Tapioca::EnvHelper

  # source://tapioca//lib/tapioca/cli.rb#372
  def __print_version; end

  # source://tapioca//lib/tapioca/cli.rb#354
  def annotations; end

  # source://tapioca//lib/tapioca/cli.rb#326
  def check_shims; end

  # source://tapioca//lib/tapioca/cli.rb#46
  def configure; end

  # source://tapioca//lib/tapioca/cli.rb#146
  def dsl(*constant_or_paths); end

  # @raise [MalformattedArgumentError]
  #
  # source://tapioca//lib/tapioca/cli.rb#269
  def gem(*gems); end

  # source://tapioca//lib/tapioca/cli.rb#27
  def init; end

  # source://tapioca//lib/tapioca/cli.rb#57
  def require; end

  # source://tapioca//lib/tapioca/cli.rb#74
  def todo; end

  private

  # source://tapioca//lib/tapioca/cli.rb#399
  def print_init_next_steps; end

  class << self
    # source://tapioca//lib/tapioca/cli.rb#383
    def addon_mode; end

    # source://tapioca//lib/tapioca/cli.rb#386
    sig { void }
    def addon_mode!; end

    # source://tapioca//lib/tapioca/cli.rb#391
    sig { returns(T::Boolean) }
    def exit_on_failure?; end
  end
end

# source://tapioca//lib/tapioca/cli.rb#10
Tapioca::Cli::FILE_HEADER_OPTION_DESC = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/helpers/cli_helper.rb#5
module Tapioca::CliHelper
  requires_ancestor { Thor::Shell }

  # : (Hash[Symbol, untyped] options) -> String?
  #
  # source://tapioca//lib/tapioca/helpers/cli_helper.rb#33
  sig { params(options: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::String)) }
  def netrc_file(options); end

  # : (Hash[Symbol, untyped] options) -> RBIFormatter
  #
  # source://tapioca//lib/tapioca/helpers/cli_helper.rb#26
  sig { params(options: T::Hash[::Symbol, T.untyped]).returns(::Tapioca::RBIFormatter) }
  def rbi_formatter(options); end

  # : (?String message, *(Symbol | Array[Symbol]) color) -> void
  #
  # source://tapioca//lib/tapioca/helpers/cli_helper.rb#12
  sig { params(message: ::String, color: T.any(::Symbol, T::Array[::Symbol])).void }
  def say_error(message = T.unsafe(nil), *color); end
end

# source://tapioca//lib/tapioca/commands.rb#5
module Tapioca::Commands; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/commands/abstract_dsl.rb#6
class Tapioca::Commands::AbstractDsl < ::Tapioca::Commands::CommandWithoutTracker
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIFilesHelper

  abstract!

  # : (requested_constants: Array[String], requested_paths: Array[Pathname], outpath: Pathname, only: Array[String], exclude: Array[String], file_header: bool, tapioca_path: String, ?skip_constant: Array[String], ?quiet: bool, ?verbose: bool, ?number_of_workers: Integer?, ?auto_strictness: bool, ?gem_dir: String, ?rbi_formatter: RBIFormatter, ?app_root: String, ?halt_upon_load_error: bool, ?compiler_options: Hash[String, untyped], ?lsp_addon: bool) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#13
  sig do
    params(
      requested_constants: T::Array[::String],
      requested_paths: T::Array[::Pathname],
      outpath: ::Pathname,
      only: T::Array[::String],
      exclude: T::Array[::String],
      file_header: T::Boolean,
      tapioca_path: ::String,
      skip_constant: T::Array[::String],
      quiet: T::Boolean,
      verbose: T::Boolean,
      number_of_workers: T.nilable(::Integer),
      auto_strictness: T::Boolean,
      gem_dir: ::String,
      rbi_formatter: ::Tapioca::RBIFormatter,
      app_root: ::String,
      halt_upon_load_error: T::Boolean,
      compiler_options: T::Hash[::String, T.untyped],
      lsp_addon: T::Boolean
    ).void
  end
  def initialize(requested_constants:, requested_paths:, outpath:, only:, exclude:, file_header:, tapioca_path:, skip_constant: T.unsafe(nil), quiet: T.unsafe(nil), verbose: T.unsafe(nil), number_of_workers: T.unsafe(nil), auto_strictness: T.unsafe(nil), gem_dir: T.unsafe(nil), rbi_formatter: T.unsafe(nil), app_root: T.unsafe(nil), halt_upon_load_error: T.unsafe(nil), compiler_options: T.unsafe(nil), lsp_addon: T.unsafe(nil)); end

  private

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#86
  sig { returns(T::Array[::String]) }
  def all_requested_constants; end

  # : (Symbol cause, Array[String] files) -> String
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#282
  sig { params(cause: ::Symbol, files: T::Array[::String]).returns(::String) }
  def build_error_for_files(cause, files); end

  # : (String constant_name, RBI::File rbi, ?outpath: Pathname, ?quiet: bool) -> Pathname?
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#206
  sig do
    params(
      constant_name: ::String,
      rbi: ::RBI::File,
      outpath: ::Pathname,
      quiet: T::Boolean
    ).returns(T.nilable(::Pathname))
  end
  def compile_dsl_rbi(constant_name, rbi, outpath: T.unsafe(nil), quiet: T.unsafe(nil)); end

  # : (Array[String] constant_names, ?ignore_missing: bool) -> Array[Module]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#148
  sig { params(constant_names: T::Array[::String], ignore_missing: T::Boolean).returns(T::Array[::Module]) }
  def constantize(constant_names, ignore_missing: T.unsafe(nil)); end

  # : (Array[String] compiler_names) -> Array[singleton(Tapioca::Dsl::Compiler)]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#173
  sig { params(compiler_names: T::Array[::String]).returns(T::Array[T.class_of(Tapioca::Dsl::Compiler)]) }
  def constantize_compilers(compiler_names); end

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#342
  sig { returns(T::Array[::String]) }
  def constants_from_requested_paths; end

  # : -> Tapioca::Dsl::Pipeline
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#109
  sig { returns(::Tapioca::Dsl::Pipeline) }
  def create_pipeline; end

  # : (String constant_name) -> Pathname
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#245
  sig { params(constant_name: ::String).returns(::Pathname) }
  def dsl_rbi_filename(constant_name); end

  # : (Array[String] requested_constants, ?path: Pathname) -> Set[Pathname]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#134
  sig { params(requested_constants: T::Array[::String], path: ::Pathname).returns(T::Set[::Pathname]) }
  def existing_rbi_filenames(requested_constants, path: T.unsafe(nil)); end

  # : (String constant) -> String
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#337
  sig { params(constant: ::String).returns(::String) }
  def generate_command_for(constant); end

  # : (Pathname outpath, quiet: bool) -> Set[Pathname]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#58
  sig { params(outpath: ::Pathname, quiet: T::Boolean).returns(T::Set[::Pathname]) }
  def generate_dsl_rbi_files(outpath, quiet:); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#96
  sig { void }
  def load_application; end

  # : (Pathname dir) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#224
  sig { params(dir: ::Pathname).void }
  def perform_dsl_verification(dir); end

  # : -> Tapioca::Dsl::Pipeline
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#91
  sig { returns(::Tapioca::Dsl::Pipeline) }
  def pipeline; end

  # : (Set[Pathname] files) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#233
  sig { params(files: T::Set[::Pathname]).void }
  def purge_stale_dsl_rbi_files(files); end

  # : (String constant) -> String
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#332
  sig { params(constant: ::String).returns(::String) }
  def rbi_filename_for(constant); end

  # : (Pathname path) -> Array[Pathname]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#313
  sig { params(path: ::Pathname).returns(T::Array[::Pathname]) }
  def rbi_files_in(path); end

  # : (Hash[String, Symbol] diff, Symbol command) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#291
  sig { params(diff: T::Hash[::String, ::Symbol], command: ::Symbol).void }
  def report_diff_and_exit_if_out_of_date(diff, command); end

  # : (String name) -> singleton(Tapioca::Dsl::Compiler)?
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#193
  sig { params(name: ::String).returns(T.nilable(T.class_of(Tapioca::Dsl::Compiler))) }
  def resolve(name); end

  # : (String class_name) -> String
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#320
  sig { params(class_name: ::String).returns(::String) }
  def underscore(class_name); end

  # : (tmp_dir: Pathname) -> Hash[String, Symbol]
  #
  # source://tapioca//lib/tapioca/commands/abstract_dsl.rb#250
  sig { params(tmp_dir: ::Pathname).returns(T::Hash[::String, ::Symbol]) }
  def verify_dsl_rbi(tmp_dir:); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/commands/abstract_gem.rb#6
class Tapioca::Commands::AbstractGem < ::Tapioca::Commands::Command
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIFilesHelper

  abstract!

  # : (gem_names: Array[String], exclude: Array[String], include_dependencies: bool, prerequire: String?, postrequire: String, typed_overrides: Hash[String, String], outpath: Pathname, file_header: bool, include_doc: bool, include_loc: bool, include_exported_rbis: bool, ?number_of_workers: Integer?, ?auto_strictness: bool, ?dsl_dir: String, ?rbi_formatter: RBIFormatter, ?halt_upon_load_error: bool, ?lsp_addon: bool?) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#13
  sig do
    params(
      gem_names: T::Array[::String],
      exclude: T::Array[::String],
      include_dependencies: T::Boolean,
      prerequire: T.nilable(::String),
      postrequire: ::String,
      typed_overrides: T::Hash[::String, ::String],
      outpath: ::Pathname,
      file_header: T::Boolean,
      include_doc: T::Boolean,
      include_loc: T::Boolean,
      include_exported_rbis: T::Boolean,
      number_of_workers: T.nilable(::Integer),
      auto_strictness: T::Boolean,
      dsl_dir: ::String,
      rbi_formatter: ::Tapioca::RBIFormatter,
      halt_upon_load_error: T::Boolean,
      lsp_addon: T.nilable(T::Boolean)
    ).void
  end
  def initialize(gem_names:, exclude:, include_dependencies:, prerequire:, postrequire:, typed_overrides:, outpath:, file_header:, include_doc:, include_loc:, include_exported_rbis:, number_of_workers: T.unsafe(nil), auto_strictness: T.unsafe(nil), dsl_dir: T.unsafe(nil), rbi_formatter: T.unsafe(nil), halt_upon_load_error: T.unsafe(nil), lsp_addon: T.unsafe(nil)); end

  private

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#180
  sig { returns(T::Array[::String]) }
  def added_rbis; end

  # : (Symbol cause, Array[String] files) -> String
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#241
  sig { params(cause: ::Symbol, files: T::Array[::String]).returns(::String) }
  def build_error_for_files(cause, files); end

  # : (Gemfile::GemSpec gem) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#60
  sig { params(gem: ::Tapioca::Gemfile::GemSpec).void }
  def compile_gem_rbi(gem); end

  # : (String gem_name) -> Pathname
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#175
  sig { params(gem_name: ::String).returns(::Pathname) }
  def existing_rbi(gem_name); end

  # : -> Hash[String, String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#223
  sig { returns(T::Hash[::String, ::String]) }
  def existing_rbis; end

  # : (String gem_name) -> Pathname
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#187
  sig { params(gem_name: ::String).returns(::Pathname) }
  def expected_rbi(gem_name); end

  # : -> Hash[String, String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#229
  sig { returns(T::Hash[::String, ::String]) }
  def expected_rbis; end

  # : (String gem_name) -> bool
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#192
  sig { params(gem_name: ::String).returns(T::Boolean) }
  def gem_rbi_exists?(gem_name); end

  # : (String gem_name, String version) -> Pathname
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#236
  sig { params(gem_name: ::String, version: ::String).returns(::Pathname) }
  def gem_rbi_filename(gem_name, version); end

  # : (Gemfile::GemSpec gem, RBI::File file) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#246
  sig { params(gem: ::Tapioca::Gemfile::GemSpec, file: ::RBI::File).void }
  def merge_with_exported_rbi(gem, file); end

  # : (Pathname old_filename, Pathname new_filename) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#217
  sig { params(old_filename: ::Pathname, new_filename: ::Pathname).void }
  def move(old_filename, new_filename); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#127
  sig { void }
  def perform_additions; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#100
  sig { void }
  def perform_removals; end

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#170
  sig { returns(T::Array[::String]) }
  def removed_rbis; end

  # : (Hash[String, Symbol] diff, Symbol command) -> void
  #
  # source://tapioca//lib/tapioca/commands/abstract_gem.rb#197
  sig { params(diff: T::Hash[::String, ::Symbol], command: ::Symbol).void }
  def report_diff_and_exit_if_out_of_date(diff, command); end
end

# source://tapioca//lib/tapioca/commands/annotations.rb#6
class Tapioca::Commands::Annotations < ::Tapioca::Commands::CommandWithoutTracker
  # : (central_repo_root_uris: Array[String], ?auth: String?, ?netrc_file: String?, ?central_repo_index_path: String, ?typed_overrides: Hash[String, String]) -> void
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#10
  sig do
    params(
      central_repo_root_uris: T::Array[::String],
      auth: T.nilable(::String),
      netrc_file: T.nilable(::String),
      central_repo_index_path: ::String,
      typed_overrides: T::Hash[::String, ::String]
    ).void
  end
  def initialize(central_repo_root_uris:, auth: T.unsafe(nil), netrc_file: T.unsafe(nil), central_repo_index_path: T.unsafe(nil), typed_overrides: T.unsafe(nil)); end

  private

  # : (String name, String content) -> String
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#191
  sig { params(name: ::String, content: ::String).returns(::String) }
  def add_header(name, content); end

  # : (String name, String content) -> String
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#211
  sig { params(name: ::String, content: ::String).returns(::String) }
  def apply_typed_override(name, content); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#32
  sig { override.void }
  def execute; end

  # source://tapioca//lib/tapioca/commands/annotations.rb#129
  sig { params(repo_uris: T::Array[::String], gem_info: ::Tapioca::GemInfo).returns(T::Boolean) }
  def fetch_annotation(repo_uris, gem_info); end

  # : (Array[GemInfo] project_gems) -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#106
  sig { params(project_gems: T::Array[::Tapioca::GemInfo]).returns(T::Array[::String]) }
  def fetch_annotations(project_gems); end

  # : (String repo_uri, String path) -> String?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#150
  sig { params(repo_uri: ::String, path: ::String).returns(T.nilable(::String)) }
  def fetch_file(repo_uri, path); end

  # : (String repo_uri, String path) -> String?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#167
  sig { params(repo_uri: ::String, path: ::String).returns(T.nilable(::String)) }
  def fetch_http_file(repo_uri, path); end

  # : (String repo_uri, repo_number: Integer?) -> RepoIndex?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#95
  sig { params(repo_uri: ::String, repo_number: T.nilable(::Integer)).returns(T.nilable(Tapioca::RepoIndex)) }
  def fetch_index(repo_uri, repo_number:); end

  # : -> Hash[String, RepoIndex]
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#74
  sig { returns(T::Hash[::String, Tapioca::RepoIndex]) }
  def fetch_indexes; end

  # : (String repo_uri, String path) -> String?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#159
  sig { params(repo_uri: ::String, path: ::String).returns(T.nilable(::String)) }
  def fetch_local_file(repo_uri, path); end

  # : (::Gem::Version gem_version, String content) -> String
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#223
  sig { params(gem_version: ::Gem::Version, content: ::String).returns(::String) }
  def filter_versions(gem_version, content); end

  # : -> Array[GemInfo]
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#43
  sig { returns(T::Array[::Tapioca::GemInfo]) }
  def list_gemfile_gems; end

  # : (String gem_name, Array[String] contents) -> String?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#231
  sig { params(gem_name: ::String, contents: T::Array[::String]).returns(T.nilable(::String)) }
  def merge_files(gem_name, contents); end

  # : (Array[GemInfo] project_gems) -> void
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#53
  sig { params(project_gems: T::Array[::Tapioca::GemInfo]).void }
  def remove_expired_annotations(project_gems); end

  # : -> Hash[String, String?]
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#258
  sig { returns(T::Hash[::String, T.nilable(::String)]) }
  def repo_tokens; end

  # : (String path, String repo_uri, message: String) -> void
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#286
  sig { params(path: ::String, repo_uri: ::String, message: ::String).void }
  def say_http_error(path, repo_uri, message:); end

  # : (String repo_uri) -> String?
  #
  # source://tapioca//lib/tapioca/commands/annotations.rb#270
  sig { params(repo_uri: ::String).returns(T.nilable(::String)) }
  def token_for(repo_uri); end
end

# source://tapioca//lib/tapioca/commands/check_shims.rb#6
class Tapioca::Commands::CheckShims < ::Tapioca::Commands::CommandWithoutTracker
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIFilesHelper

  # : (gem_rbi_dir: String, dsl_rbi_dir: String, annotations_rbi_dir: String, shim_rbi_dir: String, todo_rbi_file: String, payload: bool, number_of_workers: Integer?) -> void
  #
  # source://tapioca//lib/tapioca/commands/check_shims.rb#12
  sig do
    params(
      gem_rbi_dir: ::String,
      dsl_rbi_dir: ::String,
      annotations_rbi_dir: ::String,
      shim_rbi_dir: ::String,
      todo_rbi_file: ::String,
      payload: T::Boolean,
      number_of_workers: T.nilable(::Integer)
    ).void
  end
  def initialize(gem_rbi_dir:, dsl_rbi_dir:, annotations_rbi_dir:, shim_rbi_dir:, todo_rbi_file:, payload:, number_of_workers:); end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/check_shims.rb#35
  sig { override.void }
  def execute; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/commands/command.rb#6
class Tapioca::Commands::Command
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  include ::Tapioca::CliHelper
  extend ::Thor::Base::ClassMethods
  extend ::Thor::Invocation::ClassMethods

  abstract!

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/command.rb#20
  sig { void }
  def initialize; end

  # : Thor::Actions
  #
  # source://thor/1.3.2/lib/thor/base.rb#155
  sig { returns(::Thor::Actions) }
  def file_writer; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/command.rb#26
  sig(:final) { void }
  def run; end

  private

  # : ((String | Pathname) path, String content, ?force: bool, ?skip: bool, ?verbose: bool) -> void
  #
  # source://tapioca//lib/tapioca/commands/command.rb#46
  sig do
    params(
      path: T.any(::Pathname, ::String),
      content: ::String,
      force: T::Boolean,
      skip: T::Boolean,
      verbose: T::Boolean
    ).void
  end
  def create_file(path, content, force: T.unsafe(nil), skip: T.unsafe(nil), verbose: T.unsafe(nil)); end

  # : (Symbol command, *String args) -> String
  #
  # source://tapioca//lib/tapioca/commands/command.rb#38
  sig { params(command: ::Symbol, args: ::String).returns(::String) }
  def default_command(command, *args); end

  # @abstract
  #
  # source://tapioca//lib/tapioca/commands/command.rb#35
  sig { abstract.void }
  def execute; end

  # : ((String | Pathname) path, ?verbose: bool) -> void
  #
  # source://tapioca//lib/tapioca/commands/command.rb#51
  sig { params(path: T.any(::Pathname, ::String), verbose: T::Boolean).void }
  def remove_file(path, verbose: T.unsafe(nil)); end
end

# source://tapioca//lib/tapioca/commands/command.rb#10
class Tapioca::Commands::Command::FileWriter < ::Thor
  include ::Thor::Actions
  extend ::Thor::Actions::ClassMethods
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/commands/command_without_tracker.rb#6
class Tapioca::Commands::CommandWithoutTracker < ::Tapioca::Commands::Command
  abstract!

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/command_without_tracker.rb#12
  sig { void }
  def initialize; end
end

# source://tapioca//lib/tapioca/commands/configure.rb#6
class Tapioca::Commands::Configure < ::Tapioca::Commands::CommandWithoutTracker
  # : (sorbet_config: String, tapioca_config: String, default_postrequire: String) -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#8
  sig { params(sorbet_config: ::String, tapioca_config: ::String, default_postrequire: ::String).void }
  def initialize(sorbet_config:, tapioca_config:, default_postrequire:); end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#74
  sig { void }
  def create_binstub; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#64
  sig { void }
  def create_post_require; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#35
  sig { void }
  def create_sorbet_config; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#45
  sig { void }
  def create_tapioca_config; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#27
  sig { override.void }
  def execute; end

  # : -> Bundler::Installer
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#87
  sig { returns(::Bundler::Installer) }
  def installer; end

  # : -> (Bundler::StubSpecification | ::Gem::Specification)
  #
  # source://tapioca//lib/tapioca/commands/configure.rb#92
  sig { returns(T.any(::Bundler::StubSpecification, ::Gem::Specification)) }
  def spec; end
end

# source://tapioca//lib/tapioca/commands/dsl_compiler_list.rb#6
class Tapioca::Commands::DslCompilerList < ::Tapioca::Commands::AbstractDsl
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/dsl_compiler_list.rb#11
  sig { override.void }
  def execute; end
end

# source://tapioca//lib/tapioca/commands/dsl_generate.rb#6
class Tapioca::Commands::DslGenerate < ::Tapioca::Commands::AbstractDsl
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/dsl_generate.rb#11
  sig { override.void }
  def execute; end
end

# source://tapioca//lib/tapioca/commands/dsl_verify.rb#6
class Tapioca::Commands::DslVerify < ::Tapioca::Commands::AbstractDsl
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/dsl_verify.rb#11
  sig { override.void }
  def execute; end
end

# source://tapioca//lib/tapioca/commands/gem_generate.rb#6
class Tapioca::Commands::GemGenerate < ::Tapioca::Commands::AbstractGem
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/gem_generate.rb#11
  sig { override.void }
  def execute; end

  # : (Gemfile::GemSpec gem, ?Array[Gemfile::GemSpec] dependencies) -> Array[Gemfile::GemSpec]
  #
  # source://tapioca//lib/tapioca/commands/gem_generate.rb#70
  sig do
    params(
      gem: ::Tapioca::Gemfile::GemSpec,
      dependencies: T::Array[::Tapioca::Gemfile::GemSpec]
    ).returns(T::Array[::Tapioca::Gemfile::GemSpec])
  end
  def gem_dependencies(gem, dependencies = T.unsafe(nil)); end

  # : (Array[String] gem_names) -> Array[Gemfile::GemSpec]
  #
  # source://tapioca//lib/tapioca/commands/gem_generate.rb#52
  sig { params(gem_names: T::Array[::String]).returns(T::Array[::Tapioca::Gemfile::GemSpec]) }
  def gems_to_generate(gem_names); end
end

# source://tapioca//lib/tapioca/commands/gem_sync.rb#6
class Tapioca::Commands::GemSync < ::Tapioca::Commands::AbstractGem
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/gem_sync.rb#11
  sig { override.void }
  def execute; end
end

# source://tapioca//lib/tapioca/commands/gem_verify.rb#6
class Tapioca::Commands::GemVerify < ::Tapioca::Commands::AbstractGem
  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/gem_verify.rb#11
  sig { override.void }
  def execute; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/gem_verify.rb#18
  sig { void }
  def perform_sync_verification; end
end

# source://tapioca//lib/tapioca/commands/require.rb#6
class Tapioca::Commands::Require < ::Tapioca::Commands::CommandWithoutTracker
  # : (requires_path: String, sorbet_config_path: String) -> void
  #
  # source://tapioca//lib/tapioca/commands/require.rb#8
  sig { params(requires_path: ::String, sorbet_config_path: ::String).void }
  def initialize(requires_path:, sorbet_config_path:); end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/require.rb#19
  sig { override.void }
  def execute; end
end

# source://tapioca//lib/tapioca/commands/todo.rb#6
class Tapioca::Commands::Todo < ::Tapioca::Commands::CommandWithoutTracker
  include ::Tapioca::SorbetHelper

  # : (todo_file: String, file_header: bool) -> void
  #
  # source://tapioca//lib/tapioca/commands/todo.rb#21
  sig { params(todo_file: ::String, file_header: T::Boolean).void }
  def initialize(todo_file:, file_header:); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/todo.rb#29
  sig { void }
  def run_with_deprecation; end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/commands/todo.rb#40
  sig { override.void }
  def execute; end

  # : (Array[String] constants, command: String) -> RBI::File
  #
  # source://tapioca//lib/tapioca/commands/todo.rb#64
  sig { params(constants: T::Array[::String], command: ::String).returns(::RBI::File) }
  def rbi(constants, command:); end

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/commands/todo.rb#84
  sig { returns(T::Array[::String]) }
  def unresolved_constants; end
end

# source://tapioca//lib/tapioca/commands/todo.rb#9
Tapioca::Commands::Todo::DEPRECATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/helpers/config_helper.rb#5
module Tapioca::ConfigHelper
  requires_ancestor { Thor }

  # : (?untyped args, ?untyped local_options, ?untyped config) -> void
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#18
  sig { params(args: T.untyped, local_options: T.untyped, config: T.untyped).void }
  def initialize(args = T.unsafe(nil), local_options = T.unsafe(nil), config = T.unsafe(nil)); end

  # : String
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#12
  sig { returns(::String) }
  def command_name; end

  # : Thor::CoreExt::HashWithIndifferentAccess
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#15
  sig { returns(::Thor::CoreExt::HashWithIndifferentAccess) }
  def defaults; end

  # : -> Thor::CoreExt::HashWithIndifferentAccess
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#34
  sig { returns(::Thor::CoreExt::HashWithIndifferentAccess) }
  def options; end

  private

  # : (String msg) -> ConfigError
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#147
  sig { params(msg: ::String).returns(::Tapioca::ConfigHelper::ConfigError) }
  def build_error(msg); end

  # : (String config_file, Array[ConfigError] errors) -> String
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#172
  sig { params(config_file: ::String, errors: T::Array[::Tapioca::ConfigHelper::ConfigError]).returns(::String) }
  def build_error_message(config_file, errors); end

  # : (Thor::CoreExt::HashWithIndifferentAccess options) -> Thor::CoreExt::HashWithIndifferentAccess
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#56
  sig do
    params(
      options: ::Thor::CoreExt::HashWithIndifferentAccess
    ).returns(::Thor::CoreExt::HashWithIndifferentAccess)
  end
  def config_options(options); end

  # : (Hash[Symbol, Thor::Option] options) -> void
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#46
  sig { params(options: T::Hash[::Symbol, ::Thor::Option]).void }
  def filter_defaults(options); end

  # : (*Thor::CoreExt::HashWithIndifferentAccess? options) -> Thor::CoreExt::HashWithIndifferentAccess
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#187
  sig do
    params(
      options: T.nilable(::Thor::CoreExt::HashWithIndifferentAccess)
    ).returns(::Thor::CoreExt::HashWithIndifferentAccess)
  end
  def merge_options(*options); end

  # : (String config_file, Hash[untyped, untyped] config) -> void
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#70
  sig { params(config_file: ::String, config: T::Hash[T.untyped, T.untyped]).void }
  def validate_config!(config_file, config); end

  # : (Hash[Symbol, Thor::Option] command_options, String config_key, Hash[untyped, untyped] config_options) -> Array[ConfigError]
  #
  # source://tapioca//lib/tapioca/helpers/config_helper.rb#96
  sig do
    params(
      command_options: T::Hash[::Symbol, ::Thor::Option],
      config_key: ::String,
      config_options: T::Hash[T.untyped, T.untyped]
    ).returns(T::Array[::Tapioca::ConfigHelper::ConfigError])
  end
  def validate_config_options(command_options, config_key, config_options); end
end

# source://tapioca//lib/tapioca/helpers/config_helper.rb#142
class Tapioca::ConfigHelper::ConfigError < ::T::Struct
  const :message_parts, T::Array[::Tapioca::ConfigHelper::ConfigErrorMessagePart]

  class << self
    # source://sorbet-runtime/0.5.12152/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://tapioca//lib/tapioca/helpers/config_helper.rb#137
class Tapioca::ConfigHelper::ConfigErrorMessagePart < ::T::Struct
  const :message, ::String
  const :colors, T::Array[::Symbol]

  class << self
    # source://sorbet-runtime/0.5.12152/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# : String
#
# source://tapioca//lib/tapioca.rb#42
Tapioca::DEFAULT_ANNOTATIONS_DIR = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#38
Tapioca::DEFAULT_DSL_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca.rb#51
Tapioca::DEFAULT_ENVIRONMENT = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#39
Tapioca::DEFAULT_GEM_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca.rb#44
Tapioca::DEFAULT_OVERRIDES = T.let(T.unsafe(nil), Hash)

# : String
#
# source://tapioca//lib/tapioca.rb#36
Tapioca::DEFAULT_POSTREQUIRE_FILE = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#37
Tapioca::DEFAULT_RBI_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/rbi_formatter.rb#25
Tapioca::DEFAULT_RBI_FORMATTER = T.let(T.unsafe(nil), Tapioca::RBIFormatter)

# : Hash[String, String]
#
# source://tapioca//lib/tapioca.rb#50
Tapioca::DEFAULT_RBI_MAX_LINE_LENGTH = T.let(T.unsafe(nil), Integer)

# : String
#
# source://tapioca//lib/tapioca.rb#40
Tapioca::DEFAULT_SHIM_DIR = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#41
Tapioca::DEFAULT_TODO_FILE = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/dsl/compilers.rb#5
module Tapioca::Dsl; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/dsl/compiler.rb#6
class Tapioca::Dsl::Compiler
  extend T::Generic
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIHelper
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection
  extend ::Tapioca::Runtime::AttachedClassOf
  extend ::Tapioca::Runtime::Reflection

  abstract!

  ConstantType = type_member { { upper: Module } }

  # : (Tapioca::Dsl::Pipeline pipeline, RBI::Tree root, ConstantType constant, ?Hash[String, untyped] options) -> void
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#90
  sig do
    params(
      pipeline: ::Tapioca::Dsl::Pipeline,
      root: ::RBI::Tree,
      constant: ConstantType,
      options: T::Hash[::String, T.untyped]
    ).void
  end
  def initialize(pipeline, root, constant, options = T.unsafe(nil)); end

  # NOTE: This should eventually accept an `Error` object or `Exception` rather than simply a `String`.
  # : (String error) -> void
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#108
  sig { params(error: ::String).void }
  def add_error(error); end

  # : (String compiler_name) -> bool
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#99
  sig { params(compiler_name: ::String).returns(T::Boolean) }
  def compiler_enabled?(compiler_name); end

  # : ConstantType
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#20
  sig { returns(ConstantType) }
  def constant; end

  # @abstract
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#104
  sig { abstract.void }
  def decorate; end

  # : Hash[String, untyped]
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#26
  sig { returns(T::Hash[::String, T.untyped]) }
  def options; end

  # : RBI::Tree
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#23
  sig { returns(::RBI::Tree) }
  def root; end

  private

  # : ((Method | UnboundMethod) method_def) -> Array[RBI::TypedParam]
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#152
  sig { params(method_def: T.any(::Method, ::UnboundMethod)).returns(T::Array[::RBI::TypedParam]) }
  def compile_method_parameters_to_rbi(method_def); end

  # : ((Method | UnboundMethod) method_def) -> String
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#188
  sig { params(method_def: T.any(::Method, ::UnboundMethod)).returns(::String) }
  def compile_method_return_type_to_rbi(method_def); end

  # : (RBI::Scope scope, (Method | UnboundMethod) method_def, ?class_method: bool) -> void
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#142
  sig { params(scope: ::RBI::Scope, method_def: T.any(::Method, ::UnboundMethod), class_method: T::Boolean).void }
  def create_method_from_def(scope, method_def, class_method: T.unsafe(nil)); end

  # Get the types of each parameter from a method signature
  # : ((Method | UnboundMethod) method_def, untyped signature) -> Array[String]
  #
  # source://tapioca//lib/tapioca/dsl/compiler.rb#116
  sig { params(method_def: T.any(::Method, ::UnboundMethod), signature: T.untyped).returns(T::Array[::String]) }
  def parameters_types_from_signature(method_def, signature); end

  class << self
    # @abstract
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#39
    sig { abstract.returns(T::Enumerable[::Module]) }
    def gather_constants; end

    # : (Module constant) -> bool
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#34
    sig { params(constant: ::Module).returns(T::Boolean) }
    def handles?(constant); end

    # : -> Set[Module]
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#42
    sig { returns(T::Set[::Module]) }
    def processable_constants; end

    # : (Array[Module] constants) -> void
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#47
    sig { params(constants: T::Array[::Module]).void }
    def requested_constants=(constants); end

    # : -> void
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#52
    sig { void }
    def reset_state; end

    private

    # : -> T::Enumerable[Class[top]]
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#75
    sig { returns(T::Enumerable[T::Class[T.anything]]) }
    def all_classes; end

    # : -> T::Enumerable[Module]
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#80
    sig { returns(T::Enumerable[::Module]) }
    def all_modules; end

    # : [U] ((Class[top] & U) klass) -> Array[U]
    #
    # source://tapioca//lib/tapioca/dsl/compiler.rb#61
    sig do
      type_parameters(:U)
        .params(
          klass: T.all(T.type_parameter(:U), T::Class[T.anything])
        ).returns(T::Array[T.type_parameter(:U)])
    end
    def descendants_of(klass); end
  end
end

# source://tapioca//lib/tapioca/dsl/compilers.rb#6
module Tapioca::Dsl::Compilers; end

# DSL compilers are either built-in to Tapioca and live under the
# `Tapioca::Dsl::Compilers` namespace (i.e. this namespace), and
# can be referred to by just using the class name, or they live in
# a different namespace and can only be referred to using their fully
# qualified name. This constant encapsulates that dual lookup when
# a compiler needs to be resolved by name.
#
# source://tapioca//lib/tapioca/dsl/compilers.rb#13
Tapioca::Dsl::Compilers::NAMESPACES = T.let(T.unsafe(nil), Array)

# source://tapioca//lib/tapioca/dsl/pipeline.rb#6
class Tapioca::Dsl::Pipeline
  # : (requested_constants: Array[Module], ?requested_paths: Array[Pathname], ?requested_compilers: Array[singleton(Compiler)], ?excluded_compilers: Array[singleton(Compiler)], ?error_handler: ^(String error) -> void, ?skipped_constants: Array[Module], ?number_of_workers: Integer?, ?compiler_options: Hash[String, untyped], ?lsp_addon: bool) -> void
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#28
  sig do
    params(
      requested_constants: T::Array[::Module],
      requested_paths: T::Array[::Pathname],
      requested_compilers: T::Array[T.class_of(Tapioca::Dsl::Compiler)],
      excluded_compilers: T::Array[T.class_of(Tapioca::Dsl::Compiler)],
      error_handler: T.proc.params(error: ::String).void,
      skipped_constants: T::Array[::Module],
      number_of_workers: T.nilable(::Integer),
      compiler_options: T::Hash[::String, T.untyped],
      lsp_addon: T::Boolean
    ).void
  end
  def initialize(requested_constants:, requested_paths: T.unsafe(nil), requested_compilers: T.unsafe(nil), excluded_compilers: T.unsafe(nil), error_handler: T.unsafe(nil), skipped_constants: T.unsafe(nil), number_of_workers: T.unsafe(nil), compiler_options: T.unsafe(nil), lsp_addon: T.unsafe(nil)); end

  # : T::Enumerable[singleton(Compiler)]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#10
  sig { returns(T::Enumerable[T.class_of(Tapioca::Dsl::Compiler)]) }
  def active_compilers; end

  # : (String error) -> void
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#92
  sig { params(error: ::String).void }
  def add_error(error); end

  # : (String compiler_name) -> bool
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#97
  sig { params(compiler_name: ::String).returns(T::Boolean) }
  def compiler_enabled?(compiler_name); end

  # : -> Array[singleton(Compiler)]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#106
  sig { returns(T::Array[T.class_of(Tapioca::Dsl::Compiler)]) }
  def compilers; end

  # : ^(String error) -> void
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#22
  sig { returns(T.proc.params(error: ::String).void) }
  def error_handler; end

  # : Array[String]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#25
  sig { returns(T::Array[::String]) }
  def errors; end

  # : Array[Module]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#13
  sig { returns(T::Array[::Module]) }
  def requested_constants; end

  # : Array[Pathname]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#16
  sig { returns(T::Array[::Pathname]) }
  def requested_paths; end

  # : [T] { (Module constant, RBI::File rbi) -> T } -> Array[T]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#52
  sig do
    type_parameters(:T)
      .params(
        blk: T.proc.params(constant: ::Module, rbi: ::RBI::File).returns(T.type_parameter(:T))
      ).returns(T::Array[T.type_parameter(:T)])
  end
  def run(&blk); end

  # : Array[Module]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#19
  sig { returns(T::Array[::Module]) }
  def skipped_constants; end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#199
  sig { void }
  def abort_if_pending_migrations!; end

  # : (Set[Module] constants) -> Set[Module]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#145
  sig { params(constants: T::Set[::Module]).returns(T::Set[::Module]) }
  def filter_anonymous_and_reloaded_constants(constants); end

  # : (Array[singleton(Compiler)] requested_compilers, Array[singleton(Compiler)] excluded_compilers) -> T::Enumerable[singleton(Compiler)]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#115
  sig do
    params(
      requested_compilers: T::Array[T.class_of(Tapioca::Dsl::Compiler)],
      excluded_compilers: T::Array[T.class_of(Tapioca::Dsl::Compiler)]
    ).returns(T::Enumerable[T.class_of(Tapioca::Dsl::Compiler)])
  end
  def gather_active_compilers(requested_compilers, excluded_compilers); end

  # : (Array[Module] requested_constants, Array[Pathname] requested_paths, Array[Module] skipped_constants) -> Set[Module]
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#123
  sig do
    params(
      requested_constants: T::Array[::Module],
      requested_paths: T::Array[::Pathname],
      skipped_constants: T::Array[::Module]
    ).returns(T::Set[::Module])
  end
  def gather_constants(requested_constants, requested_paths, skipped_constants); end

  # : (Module constant) -> RBI::File?
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#174
  sig { params(constant: ::Module).returns(T.nilable(::RBI::File)) }
  def rbi_for_constant(constant); end

  # : (String error) -> void
  #
  # source://tapioca//lib/tapioca/dsl/pipeline.rb#193
  sig { params(error: ::String).void }
  def report_error(error); end
end

# source://tapioca//lib/tapioca/helpers/env_helper.rb#5
module Tapioca::EnvHelper
  requires_ancestor { Thor }

  # : (Hash[Symbol, untyped] options) -> void
  #
  # source://tapioca//lib/tapioca/helpers/env_helper.rb#12
  sig { params(options: T::Hash[::Symbol, T.untyped]).void }
  def set_environment(options); end
end

class Tapioca::Error < ::StandardError; end

# source://tapioca//lib/tapioca/executor.rb#5
class Tapioca::Executor
  # : (Array[untyped] queue, ?number_of_workers: Integer?) -> void
  #
  # source://tapioca//lib/tapioca/executor.rb#11
  sig { params(queue: T::Array[T.untyped], number_of_workers: T.nilable(::Integer)).void }
  def initialize(queue, number_of_workers: T.unsafe(nil)); end

  # : [T] { (untyped item) -> T } -> Array[T]
  #
  # source://tapioca//lib/tapioca/executor.rb#22
  sig do
    type_parameters(:T)
      .params(
        block: T.proc.params(item: T.untyped).returns(T.type_parameter(:T))
      ).returns(T::Array[T.type_parameter(:T)])
  end
  def run_in_parallel(&block); end

  private

  # : -> Integer
  #
  # source://tapioca//lib/tapioca/executor.rb#31
  sig { returns(::Integer) }
  def max_processors; end
end

# : Integer
#
# source://tapioca//lib/tapioca/executor.rb#8
Tapioca::Executor::MINIMUM_ITEMS_PER_WORKER = T.let(T.unsafe(nil), Integer)

# source://tapioca//lib/tapioca/gem/events.rb#5
module Tapioca::Gem; end

# source://tapioca//lib/tapioca/gem/events.rb#80
class Tapioca::Gem::ConstNodeAdded < ::Tapioca::Gem::NodeAdded
  # : (String symbol, Module constant, RBI::Const node) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#87
  sig { params(symbol: ::String, constant: ::Module, node: ::RBI::Const).void }
  def initialize(symbol, constant, node); end

  # : RBI::Const
  #
  # source://tapioca//lib/tapioca/gem/events.rb#84
  sig { returns(::RBI::Const) }
  def node; end
end

# source://tapioca//lib/tapioca/gem/events.rb#26
class Tapioca::Gem::ConstantFound < ::Tapioca::Gem::Event
  # : (String symbol, BasicObject constant) -> void
  #
  # @return [ConstantFound] a new instance of ConstantFound
  #
  # source://tapioca//lib/tapioca/gem/events.rb#38
  def initialize(symbol, constant); end

  # : BasicObject
  #
  # source://tapioca//lib/tapioca/gem/events.rb#34
  def constant; end

  # : String
  #
  # source://tapioca//lib/tapioca/gem/events.rb#30
  sig { returns(::String) }
  def symbol; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/gem/events.rb#6
class Tapioca::Gem::Event
  abstract!
end

# source://tapioca//lib/tapioca/gem/events.rb#45
class Tapioca::Gem::ForeignConstantFound < ::Tapioca::Gem::ConstantFound
  # : (String symbol, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#55
  sig { params(symbol: ::String, constant: ::Module).void }
  def initialize(symbol, constant); end

  # : -> Module
  #
  # source://tapioca//lib/tapioca/gem/events.rb#50
  sig { override.returns(::Module) }
  def constant; end
end

# source://tapioca//lib/tapioca/gem/events.rb#106
class Tapioca::Gem::ForeignScopeNodeAdded < ::Tapioca::Gem::ScopeNodeAdded; end

# source://tapioca//lib/tapioca/gem/listeners/base.rb#6
module Tapioca::Gem::Listeners; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/gem/listeners/base.rb#7
class Tapioca::Gem::Listeners::Base
  abstract!

  # : (Pipeline pipeline) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#14
  sig { params(pipeline: ::Tapioca::Gem::Pipeline).void }
  def initialize(pipeline); end

  # : (NodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#19
  sig { params(event: ::Tapioca::Gem::NodeAdded).void }
  def dispatch(event); end

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#49
  sig { params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ConstNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#37
  sig { params(event: ::Tapioca::Gem::ConstNodeAdded).void }
  def on_const(event); end

  # : (MethodNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#45
  sig { params(event: ::Tapioca::Gem::MethodNodeAdded).void }
  def on_method(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/base.rb#41
  sig { params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/dynamic_mixins.rb#7
class Tapioca::Gem::Listeners::DynamicMixins < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/dynamic_mixins.rb#33
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/dynamic_mixins.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/foreign_constants.rb#7
class Tapioca::Gem::Listeners::ForeignConstants < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/foreign_constants.rb#58
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (String location) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/foreign_constants.rb#52
  sig { params(location: ::String).returns(T::Boolean) }
  def mixed_in_by_gem?(location); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/foreign_constants.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/methods.rb#7
class Tapioca::Gem::Listeners::Methods < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIHelper
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (RBI::Tree tree, String module_name, Module mod, ?Array[Symbol] for_visibility, ?attached_class: Module?) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#28
  sig do
    params(
      tree: ::RBI::Tree,
      module_name: ::String,
      mod: ::Module,
      for_visibility: T::Array[::Symbol],
      attached_class: T.nilable(::Module)
    ).void
  end
  def compile_directly_owned_methods(tree, module_name, mod, for_visibility = T.unsafe(nil), attached_class: T.unsafe(nil)); end

  # : (RBI::Tree tree, String symbol_name, Module constant, UnboundMethod? method, ?RBI::Visibility visibility) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#56
  sig do
    params(
      tree: ::RBI::Tree,
      symbol_name: ::String,
      constant: ::Module,
      method: T.nilable(::UnboundMethod),
      visibility: ::RBI::Visibility
    ).void
  end
  def compile_method(tree, symbol_name, constant, method, visibility = T.unsafe(nil)); end

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#192
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (Module constant) -> UnboundMethod?
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#184
  sig { params(constant: ::Module).returns(T.nilable(::UnboundMethod)) }
  def initialize_method_for(constant); end

  # : (UnboundMethod method) -> untyped
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#197
  sig { params(method: ::UnboundMethod).returns(T.untyped) }
  def lookup_signature_of(method); end

  # : (Module mod) -> Hash[Symbol, Array[Symbol]]
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#157
  sig { params(mod: ::Module).returns(T::Hash[::Symbol, T::Array[::Symbol]]) }
  def method_names_by_visibility(mod); end

  # : (Module? attached_class, Symbol method_name) -> bool?
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#176
  sig { params(attached_class: T.nilable(::Module), method_name: ::Symbol).returns(T.nilable(T::Boolean)) }
  def method_new_in_abstract_class?(attached_class, method_name); end

  # Check whether the method is defined by the constant.
  #
  # In most cases, it works to check that the constant is the method owner. However,
  # in the case that a method is also defined in a module prepended to the constant, it
  # will be owned by the prepended module, not the constant.
  #
  # This method implements a better way of checking whether a constant defines a method.
  # It walks up the ancestor tree via the `super_method` method; if any of the super
  # methods are owned by the constant, it means that the constant declares the method.
  # : (UnboundMethod method, Module constant) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#143
  sig { params(method: ::UnboundMethod, constant: ::Module).returns(T::Boolean) }
  def method_owned_by_constant?(method, constant); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#17
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end

  # : (Module constant, String method_name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/methods.rb#166
  sig { params(constant: ::Module, method_name: ::String).returns(T::Boolean) }
  def struct_method?(constant, method_name); end
end

# source://tapioca//lib/tapioca/gem/listeners/mixins.rb#7
class Tapioca::Gem::Listeners::Mixins < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (RBI::Tree tree, Module constant, Array[Module] mods, Runtime::Trackers::Mixin::Type mixin_type) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/mixins.rb#36
  sig do
    params(
      tree: ::RBI::Tree,
      constant: ::Module,
      mods: T::Array[::Module],
      mixin_type: ::Tapioca::Runtime::Trackers::Mixin::Type
    ).void
  end
  def add_mixins(tree, constant, mods, mixin_type); end

  # : (String mixin_name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/mixins.rb#72
  sig { params(mixin_name: ::String).returns(T::Boolean) }
  def filtered_mixin?(mixin_name); end

  # : (Module constant) -> Array[Module]
  #
  # source://tapioca//lib/tapioca/gem/listeners/mixins.rb#79
  sig { params(constant: ::Module).returns(T::Array[::Module]) }
  def interesting_ancestors_of(constant); end

  # : (Module constant, Module mixin, Runtime::Trackers::Mixin::Type mixin_type) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/mixins.rb#63
  sig do
    params(
      constant: ::Module,
      mixin: ::Module,
      mixin_type: ::Tapioca::Runtime::Trackers::Mixin::Type
    ).returns(T::Boolean)
  end
  def mixed_in_by_gem?(constant, mixin, mixin_type); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/mixins.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/remove_empty_payload_scopes.rb#7
class Tapioca::Gem::Listeners::RemoveEmptyPayloadScopes < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/remove_empty_payload_scopes.rb#22
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/remove_empty_payload_scopes.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_enums.rb#7
class Tapioca::Gem::Listeners::SorbetEnums < ::Tapioca::Gem::Listeners::Base
  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_enums.rb#30
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_enums.rb#14
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_helpers.rb#7
class Tapioca::Gem::Listeners::SorbetHelpers < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_helpers.rb#29
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_helpers.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_props.rb#7
class Tapioca::Gem::Listeners::SorbetProps < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIHelper

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_props.rb#35
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_props.rb#15
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_required_ancestors.rb#7
class Tapioca::Gem::Listeners::SorbetRequiredAncestors < ::Tapioca::Gem::Listeners::Base
  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_required_ancestors.rb#25
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_required_ancestors.rb#14
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#7
class Tapioca::Gem::Listeners::SorbetSignatures < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIHelper

  private

  # : (untyped signature, Array[[Symbol, String]] parameters) -> RBI::Sig
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#27
  sig { params(signature: T.untyped, parameters: T::Array[[::Symbol, ::String]]).returns(::RBI::Sig) }
  def compile_signature(signature, parameters); end

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#81
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (MethodNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#19
  sig { override.params(event: ::Tapioca::Gem::MethodNodeAdded).void }
  def on_method(event); end

  # : (untyped signature) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#69
  sig { params(signature: T.untyped).returns(T::Boolean) }
  def signature_final?(signature); end
end

# source://tapioca//lib/tapioca/gem/listeners/sorbet_signatures.rb#13
Tapioca::Gem::Listeners::SorbetSignatures::TYPE_PARAMETER_MATCHER = T.let(T.unsafe(nil), Regexp)

# source://tapioca//lib/tapioca/gem/listeners/sorbet_type_variables.rb#7
class Tapioca::Gem::Listeners::SorbetTypeVariables < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (RBI::Tree tree, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_type_variables.rb#28
  sig { params(tree: ::RBI::Tree, constant: ::Module).void }
  def compile_type_variable_declarations(tree, constant); end

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_type_variables.rb#65
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (Tapioca::TypeVariableModule type_variable) -> RBI::Node?
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_type_variables.rb#51
  sig { params(type_variable: ::Tapioca::TypeVariableModule).returns(T.nilable(::RBI::Node)) }
  def node_from_type_variable(type_variable); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/sorbet_type_variables.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/source_location.rb#7
class Tapioca::Gem::Listeners::SourceLocation < ::Tapioca::Gem::Listeners::Base
  private

  # : (RBI::NodeWithComments node, String? file, Integer? line) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/source_location.rb#44
  sig { params(node: ::RBI::NodeWithComments, file: T.nilable(::String), line: T.nilable(::Integer)).void }
  def add_source_location_comment(node, file, line); end

  # : (ConstNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/source_location.rb#14
  sig { override.params(event: ::Tapioca::Gem::ConstNodeAdded).void }
  def on_const(event); end

  # : (MethodNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/source_location.rb#38
  sig { override.params(event: ::Tapioca::Gem::MethodNodeAdded).void }
  def on_method(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/source_location.rb#21
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/subconstants.rb#7
class Tapioca::Gem::Listeners::Subconstants < ::Tapioca::Gem::Listeners::Base
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  private

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/subconstants.rb#37
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/subconstants.rb#16
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#7
class Tapioca::Gem::Listeners::YardDoc < ::Tapioca::Gem::Listeners::Base
  # : (Pipeline pipeline) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#24
  sig { params(pipeline: ::Tapioca::Gem::Pipeline).void }
  def initialize(pipeline); end

  private

  # : (String name, ?sigs: Array[RBI::Sig]) -> Array[RBI::Comment]
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#55
  sig { params(name: ::String, sigs: T::Array[::RBI::Sig]).returns(T::Array[::RBI::Comment]) }
  def documentation_comments(name, sigs: T.unsafe(nil)); end

  # : (NodeAdded event) -> bool
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#100
  sig { override.params(event: ::Tapioca::Gem::NodeAdded).returns(T::Boolean) }
  def ignore?(event); end

  # : (ConstNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#34
  sig { override.params(event: ::Tapioca::Gem::ConstNodeAdded).void }
  def on_const(event); end

  # : (MethodNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#46
  sig { override.params(event: ::Tapioca::Gem::MethodNodeAdded).void }
  def on_method(event); end

  # : (ScopeNodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#40
  sig { override.params(event: ::Tapioca::Gem::ScopeNodeAdded).void }
  def on_scope(event); end
end

# source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#10
Tapioca::Gem::Listeners::YardDoc::IGNORED_COMMENTS = T.let(T.unsafe(nil), Array)

# : Array[String]
#
# source://tapioca//lib/tapioca/gem/listeners/yard_doc.rb#21
Tapioca::Gem::Listeners::YardDoc::IGNORED_SIG_TAGS = T.let(T.unsafe(nil), Array)

# source://tapioca//lib/tapioca/gem/events.rb#108
class Tapioca::Gem::MethodNodeAdded < ::Tapioca::Gem::NodeAdded
  # : (String symbol, Module constant, UnboundMethod method, RBI::Method node, untyped signature, Array[[Symbol, String]] parameters) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#124
  sig do
    params(
      symbol: ::String,
      constant: ::Module,
      method: ::UnboundMethod,
      node: ::RBI::Method,
      signature: T.untyped,
      parameters: T::Array[[::Symbol, ::String]]
    ).void
  end
  def initialize(symbol, constant, method, node, signature, parameters); end

  # : UnboundMethod
  #
  # source://tapioca//lib/tapioca/gem/events.rb#112
  sig { returns(::UnboundMethod) }
  def method; end

  # : RBI::Method
  #
  # source://tapioca//lib/tapioca/gem/events.rb#115
  sig { returns(::RBI::Method) }
  def node; end

  # : Array[[Symbol, String]]
  #
  # source://tapioca//lib/tapioca/gem/events.rb#121
  sig { returns(T::Array[[::Symbol, ::String]]) }
  def parameters; end

  # : untyped
  #
  # source://tapioca//lib/tapioca/gem/events.rb#118
  sig { returns(T.untyped) }
  def signature; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/gem/events.rb#60
class Tapioca::Gem::NodeAdded < ::Tapioca::Gem::Event
  abstract!

  # : (String symbol, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#73
  sig { params(symbol: ::String, constant: ::Module).void }
  def initialize(symbol, constant); end

  # : Module
  #
  # source://tapioca//lib/tapioca/gem/events.rb#70
  sig { returns(::Module) }
  def constant; end

  # : String
  #
  # source://tapioca//lib/tapioca/gem/events.rb#67
  sig { returns(::String) }
  def symbol; end
end

# source://tapioca//lib/tapioca/gem/pipeline.rb#6
class Tapioca::Gem::Pipeline
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection
  include ::Tapioca::SorbetHelper
  include ::Tapioca::RBIHelper

  # : (Gemfile::GemSpec gem, error_handler: ^(String error) -> void, ?include_doc: bool, ?include_loc: bool) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#20
  sig do
    params(
      gem: ::Tapioca::Gemfile::GemSpec,
      error_handler: T.proc.params(error: ::String).void,
      include_doc: T::Boolean,
      include_loc: T::Boolean
    ).void
  end
  def initialize(gem, error_handler:, include_doc: T.unsafe(nil), include_loc: T.unsafe(nil)); end

  # : -> RBI::Tree
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#57
  sig { returns(::RBI::Tree) }
  def compile; end

  # : ((String | Symbol) name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#116
  sig { params(name: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def constant_in_gem?(name); end

  # : ^(String error) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#17
  sig { returns(T.proc.params(error: ::String).void) }
  def error_handler; end

  # : Gemfile::GemSpec
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#14
  sig { returns(::Tapioca::Gemfile::GemSpec) }
  def gem; end

  # : (UnboundMethod method) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#134
  sig { params(method: ::UnboundMethod).returns(T::Boolean) }
  def method_in_gem?(method); end

  # : (Module constant) -> String?
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#144
  sig { params(constant: ::Module).returns(T.nilable(::String)) }
  def name_of(constant); end

  # : (String symbol, Module constant, RBI::Const node) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#81
  sig { params(symbol: ::String, constant: ::Module, node: ::RBI::Const).void }
  def push_const(symbol, constant, node); end

  # : (String symbol, BasicObject constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#71
  def push_constant(symbol, constant); end

  # : (String symbol, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#76
  sig { params(symbol: ::String, constant: ::Module).void }
  def push_foreign_constant(symbol, constant); end

  # : (String symbol, Module constant, RBI::Scope node) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#91
  sig { params(symbol: ::String, constant: ::Module, node: ::RBI::Scope).void }
  def push_foreign_scope(symbol, constant, node); end

  # : (String symbol, Module constant, UnboundMethod method, RBI::Method node, untyped signature, Array[[Symbol, String]] parameters) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#96
  sig do
    params(
      symbol: ::String,
      constant: ::Module,
      method: ::UnboundMethod,
      node: ::RBI::Method,
      signature: T.untyped,
      parameters: T::Array[[::Symbol, ::String]]
    ).void
  end
  def push_method(symbol, constant, method, node, signature, parameters); end

  # : (String symbol, Module constant, RBI::Scope node) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#86
  sig { params(symbol: ::String, constant: ::Module, node: ::RBI::Scope).void }
  def push_scope(symbol, constant, node); end

  # : (String symbol) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#65
  sig { params(symbol: ::String).void }
  def push_symbol(symbol); end

  # : (String symbol_name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#103
  sig { params(symbol_name: ::String).returns(T::Boolean) }
  def symbol_in_payload?(symbol_name); end

  private

  # : (String name) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#441
  sig { params(name: ::String).void }
  def add_to_alias_namespace(name); end

  # : (String name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#446
  sig { params(name: ::String).returns(T::Boolean) }
  def alias_namespaced?(name); end

  # : (String name, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#242
  sig { params(name: ::String, constant: ::Module).void }
  def compile_alias(name, constant); end

  # : (String symbol, BasicObject constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#228
  def compile_constant(symbol, constant); end

  # : (String symbol, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#216
  sig { params(symbol: ::String, constant: ::Module).void }
  def compile_foreign_constant(symbol, constant); end

  # : (String name, Module constant) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#297
  sig { params(name: ::String, constant: ::Module).void }
  def compile_module(name, constant); end

  # : (String name, BasicObject value) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#264
  def compile_object(name, value); end

  # : (String name, Module constant) -> RBI::Scope
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#308
  sig { params(name: ::String, constant: ::Module).returns(::RBI::Scope) }
  def compile_scope(name, constant); end

  # : (Class[top] constant) -> String?
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#322
  sig { params(constant: T::Class[T.anything]).returns(T.nilable(::String)) }
  def compile_superclass(constant); end

  # : (Module constant, ?strict: bool) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#422
  sig { params(constant: ::Module, strict: T::Boolean).returns(T::Boolean) }
  def defined_in_gem?(constant, strict: T.unsafe(nil)); end

  # : (Gem::Event event) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#174
  sig { params(event: ::Tapioca::Gem::Event).void }
  def dispatch(event); end

  # : ((Module & T::Generic) constant) -> String
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#465
  sig { params(constant: T.all(::Module, ::T::Generic)).returns(::String) }
  def generic_name_of(constant); end

  # : (Module constant) -> Set[String]
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#434
  sig { params(constant: ::Module).returns(T::Set[::String]) }
  def get_file_candidates(constant); end

  # : (Gemfile::GemSpec gem) -> Set[String]
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#159
  sig { params(gem: ::Tapioca::Gemfile::GemSpec).returns(T::Set[::String]) }
  def load_bootstrap_symbols(gem); end

  # : (Module constant, String? class_name) -> String?
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#481
  sig { params(constant: ::Module, class_name: T.nilable(::String)).returns(T.nilable(::String)) }
  def name_of_proxy_target(constant, class_name); end

  # : -> Gem::Event
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#169
  sig { returns(::Tapioca::Gem::Event) }
  def next_event; end

  # : (Gem::ConstantFound event) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#197
  sig { params(event: ::Tapioca::Gem::ConstantFound).void }
  def on_constant(event); end

  # : (Gem::NodeAdded event) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#209
  sig { params(event: ::Tapioca::Gem::NodeAdded).void }
  def on_node(event); end

  # : (Gem::SymbolFound event) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#188
  sig { params(event: ::Tapioca::Gem::SymbolFound).void }
  def on_symbol(event); end

  # : (String name) -> void
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#453
  sig { params(name: ::String).void }
  def seen!(name); end

  # : (String name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#458
  sig { params(name: ::String).returns(T::Boolean) }
  def seen?(name); end

  # : (String name, Module constant) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#391
  sig { params(name: ::String, constant: ::Module).returns(T::Boolean) }
  def skip_alias?(name, constant); end

  # : (String name, top constant) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#379
  def skip_constant?(name, constant); end

  # : (String name, Module constant) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#409
  sig { params(name: ::String, constant: ::Module).returns(T::Boolean) }
  def skip_foreign_constant?(name, constant); end

  # : (String name, Module constant) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#414
  sig { params(name: ::String, constant: ::Module).returns(T::Boolean) }
  def skip_module?(name, constant); end

  # : (String name, BasicObject constant) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#401
  def skip_object?(name, constant); end

  # : (String name) -> bool
  #
  # source://tapioca//lib/tapioca/gem/pipeline.rb#373
  sig { params(name: ::String).returns(T::Boolean) }
  def skip_symbol?(name); end
end

# this looks something like:
# "(eval at /path/to/file.rb:123)"
# and we are just interested in the "/path/to/file.rb" part
#
# source://tapioca//lib/tapioca/gem/pipeline.rb#113
Tapioca::Gem::Pipeline::EVAL_SOURCE_FILE_PATTERN = T.let(T.unsafe(nil), Regexp)

# : Array[String]
#
# source://tapioca//lib/tapioca/gem/pipeline.rb#11
Tapioca::Gem::Pipeline::IGNORED_SYMBOLS = T.let(T.unsafe(nil), Array)

# source://tapioca//lib/tapioca/gem/events.rb#93
class Tapioca::Gem::ScopeNodeAdded < ::Tapioca::Gem::NodeAdded
  # : (String symbol, Module constant, RBI::Scope node) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#100
  sig { params(symbol: ::String, constant: ::Module, node: ::RBI::Scope).void }
  def initialize(symbol, constant, node); end

  # : RBI::Scope
  #
  # source://tapioca//lib/tapioca/gem/events.rb#97
  sig { returns(::RBI::Scope) }
  def node; end
end

# source://tapioca//lib/tapioca/gem/events.rb#13
class Tapioca::Gem::SymbolFound < ::Tapioca::Gem::Event
  # : (String symbol) -> void
  #
  # source://tapioca//lib/tapioca/gem/events.rb#20
  sig { params(symbol: ::String).void }
  def initialize(symbol); end

  # : String
  #
  # source://tapioca//lib/tapioca/gem/events.rb#17
  sig { returns(::String) }
  def symbol; end
end

# source://tapioca//lib/tapioca/helpers/gem_helper.rb#5
module Tapioca::GemHelper
  # : ((String | Pathname) app_dir, String full_gem_path) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/gem_helper.rb#9
  sig { params(app_dir: T.any(::Pathname, ::String), full_gem_path: ::String).returns(T::Boolean) }
  def gem_in_app_dir?(app_dir, full_gem_path); end

  # : (String full_gem_path) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/gem_helper.rb#17
  sig { params(full_gem_path: ::String).returns(T::Boolean) }
  def gem_in_bundle_path?(full_gem_path); end

  # : (String full_gem_path) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/gem_helper.rb#22
  sig { params(full_gem_path: ::String).returns(T::Boolean) }
  def gem_in_ruby_path?(full_gem_path); end

  # : ((String | Pathname) path) -> String
  #
  # source://tapioca//lib/tapioca/helpers/gem_helper.rb#27
  sig { params(path: T.any(::Pathname, ::String)).returns(::String) }
  def to_realpath(path); end

  private

  # : ((Pathname | String) path, (Pathname | String) dir) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/gem_helper.rb#36
  sig { params(path: T.any(::Pathname, ::String), dir: T.any(::Pathname, ::String)).returns(T::Boolean) }
  def path_in_dir?(path, dir); end
end

# source://tapioca//lib/tapioca/gem_info.rb#5
class Tapioca::GemInfo < ::T::Struct
  const :name, ::String
  const :version, ::Gem::Version

  class << self
    # : (Bundler::LazySpecification spec) -> GemInfo
    #
    # source://tapioca//lib/tapioca/gem_info.rb#13
    sig { params(spec: ::Bundler::LazySpecification).returns(::Tapioca::GemInfo) }
    def from_spec(spec); end

    # source://sorbet-runtime/0.5.12152/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://tapioca//lib/tapioca/gemfile.rb#7
class Tapioca::Gemfile
  # : (Array[String] excluded_gems) -> void
  #
  # source://tapioca//lib/tapioca/gemfile.rb#27
  sig { params(excluded_gems: T::Array[::String]).void }
  def initialize(excluded_gems); end

  # : Bundler::Definition
  #
  # source://tapioca//lib/tapioca/gemfile.rb#18
  sig { returns(::Bundler::Definition) }
  def definition; end

  # : Array[GemSpec]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#21
  sig { returns(T::Array[::Tapioca::Gemfile::GemSpec]) }
  def dependencies; end

  # : (String gem_name) -> GemSpec?
  #
  # source://tapioca//lib/tapioca/gemfile.rb#40
  sig { params(gem_name: ::String).returns(T.nilable(::Tapioca::Gemfile::GemSpec)) }
  def gem(gem_name); end

  # : Array[String]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#24
  sig { returns(T::Array[::String]) }
  def missing_specs; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/gemfile.rb#45
  sig { void }
  def require_bundle; end

  private

  # : -> String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#101
  sig { returns(::String) }
  def dir; end

  # : File
  #
  # source://tapioca//lib/tapioca/gemfile.rb#54
  sig { returns(::File) }
  def gemfile; end

  # : -> Array[Symbol]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#96
  sig { returns(T::Array[::Symbol]) }
  def groups; end

  # : -> [Array[GemSpec], Array[String]]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#57
  sig { returns([T::Array[::Tapioca::Gemfile::GemSpec], T::Array[::String]]) }
  def load_dependencies; end

  # : File
  #
  # source://tapioca//lib/tapioca/gemfile.rb#54
  def lockfile; end

  # : -> [T::Enumerable[Spec], Array[String]]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#68
  sig { returns([T::Enumerable[T.any(::Bundler::StubSpecification, ::Gem::Specification)], T::Array[::String]]) }
  def materialize_deps; end

  # : -> Bundler::Runtime
  #
  # source://tapioca//lib/tapioca/gemfile.rb#91
  sig { returns(::Bundler::Runtime) }
  def runtime; end
end

# source://tapioca//lib/tapioca/gemfile.rb#105
class Tapioca::Gemfile::GemSpec
  include ::Tapioca::GemHelper

  # : (Spec spec) -> void
  #
  # source://tapioca//lib/tapioca/gemfile.rb#139
  sig { params(spec: T.any(::Bundler::StubSpecification, ::Gem::Specification)).void }
  def initialize(spec); end

  # : (BasicObject other) -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#149
  sig { params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : (String path) -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#174
  sig { params(path: ::String).returns(T::Boolean) }
  def contains_path?(path); end

  # : -> Array[::Gem::Dependency]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#164
  sig { returns(T::Array[::Gem::Dependency]) }
  def dependencies; end

  # : -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#204
  sig { returns(T::Boolean) }
  def export_rbi_files?; end

  # : -> Array[String]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#199
  sig { returns(T::Array[::String]) }
  def exported_rbi_files; end

  # : -> RBI::MergeTree
  #
  # source://tapioca//lib/tapioca/gemfile.rb#209
  sig { returns(::RBI::MergeTree) }
  def exported_rbi_tree; end

  # : Array[Pathname]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#136
  sig { returns(T::Array[::Pathname]) }
  def files; end

  # : String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#133
  sig { returns(::String) }
  def full_gem_path; end

  # : (String gemfile_dir) -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#154
  sig { params(gemfile_dir: ::String).returns(T::Boolean) }
  def ignore?(gemfile_dir); end

  # : -> String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#159
  sig { returns(::String) }
  def name; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/gemfile.rb#183
  sig { void }
  def parse_yard_docs; end

  # : -> String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#169
  sig { returns(::String) }
  def rbi_file_name; end

  # : (Pathname file) -> Pathname
  #
  # source://tapioca//lib/tapioca/gemfile.rb#221
  sig { params(file: ::Pathname).returns(::Pathname) }
  def relative_path_for(file); end

  # : String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#133
  def version; end

  private

  # : -> Array[Pathname]
  #
  # source://tapioca//lib/tapioca/gemfile.rb#232
  sig { returns(T::Array[::Pathname]) }
  def collect_files; end

  # : -> bool?
  #
  # source://tapioca//lib/tapioca/gemfile.rb#247
  sig { returns(T.nilable(T::Boolean)) }
  def default_gem?; end

  # : -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#303
  sig { returns(T::Boolean) }
  def gem_ignored?; end

  # : (String path) -> bool
  #
  # source://tapioca//lib/tapioca/gemfile.rb#282
  sig { params(path: ::String).returns(T::Boolean) }
  def has_parent_gemspec?(path); end

  # : -> Regexp
  #
  # source://tapioca//lib/tapioca/gemfile.rb#252
  sig { returns(::Regexp) }
  def require_paths_prefix_matcher; end

  # : (String file) -> Pathname
  #
  # source://tapioca//lib/tapioca/gemfile.rb#261
  sig { params(file: ::String).returns(::Pathname) }
  def resolve_to_ruby_lib_dir(file); end

  # : -> String
  #
  # source://tapioca//lib/tapioca/gemfile.rb#275
  sig { returns(::String) }
  def version_string; end

  class << self
    # : -> Hash[String, Gemfile::GemSpec]
    #
    # source://tapioca//lib/tapioca/gemfile.rb#113
    sig { returns(T::Hash[::String, ::Tapioca::Gemfile::GemSpec]) }
    def spec_lookup_by_file_path; end
  end
end

# source://tapioca//lib/tapioca/gemfile.rb#122
Tapioca::Gemfile::GemSpec::IGNORED_GEMS = T.let(T.unsafe(nil), Array)

# source://tapioca//lib/tapioca/gemfile.rb#10
Tapioca::Gemfile::Spec = T.type_alias { T.any(::Bundler::StubSpecification, ::Gem::Specification) }

# : String
#
# source://tapioca//lib/tapioca.rb#29
Tapioca::LIB_ROOT_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/loaders/loader.rb#5
module Tapioca::Loaders; end

# source://tapioca//lib/tapioca/loaders/dsl.rb#6
class Tapioca::Loaders::Dsl < ::Tapioca::Loaders::Loader
  # : (tapioca_path: String, ?eager_load: bool, ?app_root: String, ?halt_upon_load_error: bool) -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#66
  sig do
    params(
      tapioca_path: ::String,
      eager_load: T::Boolean,
      app_root: ::String,
      halt_upon_load_error: T::Boolean
    ).void
  end
  def initialize(tapioca_path:, eager_load: T.unsafe(nil), app_root: T.unsafe(nil), halt_upon_load_error: T.unsafe(nil)); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#30
  sig { override.void }
  def load; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#37
  sig { void }
  def load_dsl_extensions_and_compilers; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#43
  sig { void }
  def reload_custom_compilers; end

  protected

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#112
  sig { void }
  def load_application; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#92
  sig { void }
  def load_dsl_compilers; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#77
  sig { void }
  def load_dsl_extensions; end

  private

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/dsl.rb#128
  sig { void }
  def load_custom_dsl_compilers; end

  class << self
    # : (tapioca_path: String, ?eager_load: bool, ?app_root: String, ?halt_upon_load_error: bool) -> void
    #
    # source://tapioca//lib/tapioca/loaders/dsl.rb#13
    sig do
      params(
        tapioca_path: ::String,
        eager_load: T::Boolean,
        app_root: ::String,
        halt_upon_load_error: T::Boolean
      ).void
    end
    def load_application(tapioca_path:, eager_load: T.unsafe(nil), app_root: T.unsafe(nil), halt_upon_load_error: T.unsafe(nil)); end
  end
end

# source://tapioca//lib/tapioca/loaders/gem.rb#6
class Tapioca::Loaders::Gem < ::Tapioca::Loaders::Loader
  # : (bundle: Gemfile, prerequire: String?, postrequire: String, default_command: String, halt_upon_load_error: bool) -> void
  #
  # source://tapioca//lib/tapioca/loaders/gem.rb#34
  sig do
    params(
      bundle: ::Tapioca::Gemfile,
      prerequire: T.nilable(::String),
      postrequire: ::String,
      default_command: ::String,
      halt_upon_load_error: T::Boolean
    ).void
  end
  def initialize(bundle:, prerequire:, postrequire:, default_command:, halt_upon_load_error:); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/gem.rb#27
  sig { override.void }
  def load; end

  protected

  # : (String file, LoadError error) -> void
  #
  # source://tapioca//lib/tapioca/loaders/gem.rb#65
  sig { params(file: ::String, error: ::LoadError).void }
  def explain_failed_require(file, error); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/gem.rb#45
  sig { void }
  def require_gem_file; end

  class << self
    # : (bundle: Gemfile, prerequire: String?, postrequire: String, default_command: String, halt_upon_load_error: bool) -> void
    #
    # source://tapioca//lib/tapioca/loaders/gem.rb#13
    sig do
      params(
        bundle: ::Tapioca::Gemfile,
        prerequire: T.nilable(::String),
        postrequire: ::String,
        default_command: ::String,
        halt_upon_load_error: T::Boolean
      ).void
    end
    def load_application(bundle:, prerequire:, postrequire:, default_command:, halt_upon_load_error:); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://tapioca//lib/tapioca/loaders/loader.rb#6
class Tapioca::Loaders::Loader
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  include ::Tapioca::CliHelper
  include ::Tapioca::GemHelper
  extend ::Thor::Base::ClassMethods
  extend ::Thor::Invocation::ClassMethods

  abstract!

  # @abstract
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#17
  sig { abstract.void }
  def load; end

  private

  # Rails 7.2 renamed `eager_load_paths` to `all_eager_load_paths`, which maintains the same original functionality.
  # The `eager_load_paths` method still exists, but doesn't return all paths anymore and causes Tapioca to miss some
  # engine paths. The following commit is the change:
  # https://github.com/rails/rails/commit/ebfca905db14020589c22e6937382e6f8f687664
  # : (singleton(Rails::Engine) engine) -> Array[String]
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#218
  def eager_load_paths(engine); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#182
  sig { void }
  def eager_load_rails_app; end

  # : -> Array[singleton(Rails::Engine)]
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#161
  def engines; end

  # : (Tapioca::Gemfile gemfile, String? initialize_file, String? require_file, bool halt_upon_load_error) -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#22
  sig do
    params(
      gemfile: ::Tapioca::Gemfile,
      initialize_file: T.nilable(::String),
      require_file: T.nilable(::String),
      halt_upon_load_error: T::Boolean
    ).void
  end
  def load_bundle(gemfile, initialize_file, require_file, halt_upon_load_error); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#118
  sig { void }
  def load_engines_in_classic_mode; end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#100
  sig { void }
  def load_engines_in_zeitwerk_mode; end

  # : (?environment_load: bool, ?eager_load: bool, ?app_root: String, ?halt_upon_load_error: bool) -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#35
  sig do
    params(
      environment_load: T::Boolean,
      eager_load: T::Boolean,
      app_root: ::String,
      halt_upon_load_error: T::Boolean
    ).void
  end
  def load_rails_application(environment_load: T.unsafe(nil), eager_load: T.unsafe(nil), app_root: T.unsafe(nil), halt_upon_load_error: T.unsafe(nil)); end

  # : -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#75
  sig { void }
  def load_rails_engines; end

  # : (String? file) -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#203
  sig { params(file: T.nilable(::String)).void }
  def require_helper(file); end

  # source://tapioca//lib/tapioca/loaders/loader.rb#89
  def run_initializers; end

  # : (String path) -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#175
  sig { params(path: ::String).void }
  def safe_require(path); end

  # : { -> void } -> void
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#143
  sig { params(blk: T.proc.void).void }
  def with_rails_application(&blk); end

  # : -> bool
  #
  # source://tapioca//lib/tapioca/loaders/loader.rb#136
  sig { returns(T::Boolean) }
  def zeitwerk_mode?; end
end

# source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#5
module Tapioca::RBIFilesHelper
  requires_ancestor { Tapioca::SorbetHelper }
  requires_ancestor { Thor::Shell }

  # : (RBI::Index index, shim_rbi_dir: String, todo_rbi_file: String) -> Hash[String, Array[RBI::Node]]
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#42
  sig do
    params(
      index: ::RBI::Index,
      shim_rbi_dir: ::String,
      todo_rbi_file: ::String
    ).returns(T::Hash[::String, T::Array[::RBI::Node]])
  end
  def duplicated_nodes_from_index(index, shim_rbi_dir:, todo_rbi_file:); end

  # : (RBI::Index index, String kind, String file) -> void
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#13
  sig { params(index: ::RBI::Index, kind: ::String, file: ::String).void }
  def index_rbi(index, kind, file); end

  # : (RBI::Index index, String kind, String dir, number_of_workers: Integer?) -> void
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#25
  sig { params(index: ::RBI::Index, kind: ::String, dir: ::String, number_of_workers: T.nilable(::Integer)).void }
  def index_rbis(index, kind, dir, number_of_workers:); end

  # : (RBI::Loc loc, path_prefix: String?) -> String
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#59
  sig { params(loc: ::RBI::Loc, path_prefix: T.nilable(::String)).returns(::String) }
  def location_to_payload_url(loc, path_prefix:); end

  # : (command: String, gem_dir: String, dsl_dir: String, auto_strictness: bool, ?gems: Array[Gemfile::GemSpec], ?compilers: T::Enumerable[singleton(Dsl::Compiler)]) -> void
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#71
  sig do
    params(
      command: ::String,
      gem_dir: ::String,
      dsl_dir: ::String,
      auto_strictness: T::Boolean,
      gems: T::Array[::Tapioca::Gemfile::GemSpec],
      compilers: T::Enumerable[T.class_of(Tapioca::Dsl::Compiler)]
    ).void
  end
  def validate_rbi_files(command:, gem_dir:, dsl_dir:, auto_strictness:, gems: T.unsafe(nil), compilers: T.unsafe(nil)); end

  private

  # : (Array[RBI::Node] nodes) -> Array[(RBI::Method | RBI::Attr)]
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#249
  sig { params(nodes: T::Array[::RBI::Node]).returns(T::Array[T.any(::RBI::Attr, ::RBI::Method)]) }
  def extract_methods_and_attrs(nodes); end

  # : (Array[RBI::Node] nodes, shim_rbi_dir: String, todo_rbi_file: String) -> Array[RBI::Node]
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#242
  sig do
    params(
      nodes: T::Array[::RBI::Node],
      shim_rbi_dir: ::String,
      todo_rbi_file: ::String
    ).returns(T::Array[::RBI::Node])
  end
  def extract_shims_and_todos(nodes, shim_rbi_dir:, todo_rbi_file:); end

  # : (String path) -> String
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#286
  sig { params(path: ::String).returns(::String) }
  def gem_name_from_rbi_path(path); end

  # : (Array[RBI::Node] nodes, Array[RBI::Node] shims_or_todos) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#210
  sig { params(nodes: T::Array[::RBI::Node], shims_or_todos: T::Array[::RBI::Node]).returns(T::Boolean) }
  def has_duplicated_methods_and_attrs?(nodes, shims_or_todos); end

  # : (Array[RBI::Node] shims_or_todos) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#202
  sig { params(shims_or_todos: T::Array[::RBI::Node]).returns(T::Boolean) }
  def has_duplicated_mixins?(shims_or_todos); end

  # : (Array[RBI::Node], Array[RBI::Node]) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#174
  sig { params(all_nodes: T::Array[::RBI::Node], shims_or_todos: T::Array[::RBI::Node]).returns(T::Boolean) }
  def has_duplicated_scopes?(all_nodes, shims_or_todos); end

  # : (RBI::Index index, Array[String] files, number_of_workers: Integer?) -> void
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#140
  sig { params(index: ::RBI::Index, files: T::Array[::String], number_of_workers: T.nilable(::Integer)).void }
  def parse_and_index_files(index, files, number_of_workers:); end

  # Do the list of `nodes` sharing the same name have duplicates?
  # : (Array[RBI::Node] nodes, shim_rbi_dir: String, todo_rbi_file: String) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#157
  sig { params(nodes: T::Array[::RBI::Node], shim_rbi_dir: ::String, todo_rbi_file: ::String).returns(T::Boolean) }
  def shims_or_todos_have_duplicates?(nodes, shim_rbi_dir:, todo_rbi_file:); end

  # : (Array[Spoom::Sorbet::Errors::Error] errors, String gem_dir) -> void
  #
  # source://tapioca//lib/tapioca/helpers/rbi_files_helper.rb#259
  sig { params(errors: T::Array[::Spoom::Sorbet::Errors::Error], gem_dir: ::String).void }
  def update_gem_rbis_strictnesses(errors, gem_dir); end
end

# source://tapioca//lib/tapioca/rbi_formatter.rb#5
class Tapioca::RBIFormatter < ::RBI::Formatter
  # : (RBI::File file) -> void
  #
  # source://tapioca//lib/tapioca/rbi_formatter.rb#18
  sig { params(file: ::RBI::File).void }
  def write_empty_body_comment!(file); end

  # : (RBI::File file, String command, ?reason: String?) -> void
  #
  # source://tapioca//lib/tapioca/rbi_formatter.rb#9
  sig { params(file: ::RBI::File, command: ::String, reason: T.nilable(::String)).void }
  def write_header!(file, command, reason: T.unsafe(nil)); end
end

# source://tapioca//lib/tapioca/helpers/rbi_helper.rb#5
module Tapioca::RBIHelper
  include ::Tapioca::SorbetHelper
  extend ::Tapioca::SorbetHelper
  extend ::Tapioca::RBIHelper

  # : (String type) -> String
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#83
  sig { params(type: ::String).returns(::String) }
  def as_nilable_type(type); end

  # : (String type) -> String
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#92
  sig { params(type: ::String).returns(::String) }
  def as_non_nilable_type(type); end

  # : (String name, type: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#64
  sig { params(name: ::String, type: ::String).returns(::RBI::TypedParam) }
  def create_block_param(name, type:); end

  # : (String name, type: String, default: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#54
  sig { params(name: ::String, type: ::String, default: ::String).returns(::RBI::TypedParam) }
  def create_kw_opt_param(name, type:, default:); end

  # : (String name, type: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#49
  sig { params(name: ::String, type: ::String).returns(::RBI::TypedParam) }
  def create_kw_param(name, type:); end

  # : (String name, type: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#59
  sig { params(name: ::String, type: ::String).returns(::RBI::TypedParam) }
  def create_kw_rest_param(name, type:); end

  # : (String name, type: String, default: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#39
  sig { params(name: ::String, type: ::String, default: ::String).returns(::RBI::TypedParam) }
  def create_opt_param(name, type:, default:); end

  # : (String name, type: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#34
  sig { params(name: ::String, type: ::String).returns(::RBI::TypedParam) }
  def create_param(name, type:); end

  # : (String name, type: String) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#44
  sig { params(name: ::String, type: ::String).returns(::RBI::TypedParam) }
  def create_rest_param(name, type:); end

  # : (RBI::Param param, String type) -> RBI::TypedParam
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#69
  sig { params(param: ::RBI::Param, type: ::String).returns(::RBI::TypedParam) }
  def create_typed_param(param, type); end

  # : (String sig_string) -> String
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#74
  sig { params(sig_string: ::String).returns(::String) }
  def sanitize_signature_types(sig_string); end

  # : (String name) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#101
  sig { params(name: ::String).returns(T::Boolean) }
  def valid_method_name?(name); end

  # : (String name) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#106
  sig { params(name: ::String).returns(T::Boolean) }
  def valid_parameter_name?(name); end

  class << self
    # : (String type, Symbol variance, String? fixed, String? upper, String? lower) -> String
    #
    # source://tapioca//lib/tapioca/helpers/rbi_helper.rb#15
    sig do
      params(
        type: ::String,
        variance: ::Symbol,
        fixed: T.nilable(::String),
        upper: T.nilable(::String),
        lower: T.nilable(::String)
      ).returns(::String)
    end
    def serialize_type_variable(type, variance, fixed, upper, lower); end
  end
end

# source://tapioca//lib/tapioca/repo_index.rb#5
class Tapioca::RepoIndex
  # : -> void
  #
  # source://tapioca//lib/tapioca/repo_index.rb#26
  sig { void }
  def initialize; end

  # : (String gem_name) -> void
  #
  # source://tapioca//lib/tapioca/repo_index.rb#31
  sig { params(gem_name: ::String).void }
  def <<(gem_name); end

  # : -> T::Enumerable[String]
  #
  # source://tapioca//lib/tapioca/repo_index.rb#36
  sig { returns(T::Enumerable[::String]) }
  def gems; end

  # : (String gem_name) -> bool
  #
  # source://tapioca//lib/tapioca/repo_index.rb#41
  sig { params(gem_name: ::String).returns(T::Boolean) }
  def has_gem?(gem_name); end

  class << self
    # : (Hash[String, Hash[untyped, untyped]] hash) -> RepoIndex
    #
    # source://tapioca//lib/tapioca/repo_index.rb#18
    sig { params(hash: T::Hash[::String, T::Hash[T.untyped, T.untyped]]).returns(Tapioca::RepoIndex) }
    def from_hash(hash); end

    # : (String json) -> RepoIndex
    #
    # source://tapioca//lib/tapioca/repo_index.rb#13
    sig { params(json: ::String).returns(Tapioca::RepoIndex) }
    def from_json(json); end
  end
end

# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#5
module Tapioca::Runtime; end

# This module should only be included when running versions of Ruby
# older than 3.2. Because the Class#attached_object method is not
# available, it implements finding the attached class of a singleton
# class by iterating through ObjectSpace.
module Tapioca::Runtime::AttachedClassOf
  # : (Class singleton_class) -> Module?
  #
  # source://tapioca//lib/tapioca/runtime/attached_class_of_32.rb#14
  def attached_class_of(singleton_class); end
end

# source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#6
class Tapioca::Runtime::DynamicMixinCompiler
  include ::Tapioca::Runtime::AttachedClassOf
  include ::Tapioca::Runtime::Reflection

  # : (Module constant) -> void
  #
  # @return [DynamicMixinCompiler] a new instance of DynamicMixinCompiler
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#20
  def initialize(constant); end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#14
  def class_attribute_predicates; end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#14
  def class_attribute_readers; end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#14
  def class_attribute_writers; end

  # : (RBI::Tree tree) -> void
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#137
  def compile_class_attributes(tree); end

  # : (RBI::Tree tree) -> [Array[Module], Array[Module]]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#180
  def compile_mixes_in_class_methods(tree); end

  # : Array[Module]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#11
  def dynamic_extends; end

  # : Array[Module]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#11
  def dynamic_includes; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#132
  def empty_attributes?; end

  # : (String qualified_mixin_name) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#222
  def filtered_mixin?(qualified_mixin_name); end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#17
  def instance_attribute_predicates; end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#17
  def instance_attribute_readers; end

  # : Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#17
  def instance_attribute_writers; end

  # : (Module mod, Array[Module] dynamic_extends) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/dynamic_mixin_compiler.rb#215
  def module_included_by_another_dynamic_extend?(mod, dynamic_extends); end
end

# This class is responsible for storing and looking up information related to generic types.
#
# The class stores 2 different kinds of data, in two separate lookup tables:
#   1. a lookup of generic type instances by name: `@generic_instances`
#   2. a lookup of type variable serializer by constant and type variable
#      instance: `@type_variables`
#
# By storing the above data, we can cheaply query each constant against this registry
# to see if it declares any generic type variables. This becomes a simple lookup in the
# `@type_variables` hash table with the given constant.
#
# If there is no entry, then we can cheaply know that we can skip generic type
# information generation for this type.
#
# On the other hand, if we get a result, then the result will be a hash of type
# variable to type variable serializers. This allows us to associate type variables
# to the constant names that represent them, easily.
#
# source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#23
module Tapioca::Runtime::GenericTypeRegistry
  class << self
    # : (Object instance) -> bool
    #
    # @return [Boolean]
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#75
    def generic_type_instance?(instance); end

    # : (Module constant) -> Array[TypeVariableModule]?
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#80
    def lookup_type_variables(constant); end

    # This method is responsible for building the name of the instantiated concrete type
    # and cloning the given constant so that we can return a type that is the same
    # as the current type but is a different instance and has a different name method.
    #
    # We cache those cloned instances by their name in `@generic_instances`, so that
    # we don't keep instantiating a new type every single time it is referenced.
    # For example, `[Foo[Integer], Foo[Integer], Foo[Integer], Foo[String]]` will only
    # result in 2 clones (1 for `Foo[Integer]` and another for `Foo[String]`) and
    # 2 hash lookups (for the other two `Foo[Integer]`s).
    #
    # This method returns the created or cached clone of the constant.
    # : (untyped constant, untyped types) -> Module
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#60
    def register_type(constant, types); end

    # This method is called from intercepted calls to `type_member` and `type_template`.
    # We get passed all the arguments to those methods, as well as the `T::Types::TypeVariable`
    # instance generated by the Sorbet defined `type_member`/`type_template` call on `T::Generic`.
    #
    # This method creates a `String` with that data and stores it in the
    # `@type_variables` lookup table, keyed by the `constant` and `type_variable`.
    #
    # Finally, the original `type_variable` is returned from this method, so that the caller
    # can return it from the original methods as well.
    # : (untyped constant, TypeVariableModule type_variable) -> void
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#94
    def register_type_variable(constant, type_variable); end

    private

    # : (Module constant, String name) -> Module
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#103
    def create_generic_type(constant, name); end

    # : (Class[top] constant) -> Class[top]
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#145
    def create_safe_subclass(constant); end

    # : (Module constant) -> Array[TypeVariableModule]
    #
    # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#172
    def lookup_or_initialize_type_variables(constant); end
  end
end

# source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#28
class Tapioca::Runtime::GenericTypeRegistry::GenericType < ::T::Types::Simple
  # : (Module raw_type, Module underlying_type) -> void
  #
  # @return [GenericType] a new instance of GenericType
  #
  # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#32
  def initialize(raw_type, underlying_type); end

  # : (untyped obj) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/generic_type_registry.rb#40
  def valid?(obj); end
end

module Tapioca::Runtime::Reflection
  include ::Tapioca::Runtime::AttachedClassOf
  extend ::Tapioca::Runtime::AttachedClassOf
  extend ::Tapioca::Runtime::Reflection

  # : (Module constant) -> untyped
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#199
  def abstract_type_of(constant); end

  # : (Module constant) -> Array[Module]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#73
  def ancestors_of(constant); end

  # : (BasicObject object, BasicObject other) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#88
  def are_equal?(object, other); end

  # : (BasicObject object) -> Class[top]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#52
  def class_of(object); end

  # : (BasicObject constant) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#39
  def constant_defined?(constant); end

  # : (String symbol, ?inherit: bool, ?namespace: Module) -> BasicObject
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#45
  def constantize(symbol, inherit: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # : (Module constant) -> Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#57
  def constants_of(constant); end

  # Returns an array with all classes that are < than the supplied class.
  #
  #   class C; end
  #   descendants_of(C) # => []
  #
  #   class B < C; end
  #   descendants_of(C) # => [B]
  #
  #   class A < B; end
  #   descendants_of(C) # => [B, A]
  #
  #   class D < C; end
  #   descendants_of(C) # => [B, A, D]
  # : [U] ((Class[top] & U) klass) -> Array[U]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#164
  def descendants_of(klass); end

  # : (Module constant) -> Set[String]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#192
  def file_candidates_for(constant); end

  # : (Module constant) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#205
  def final_module?(constant); end

  # : (Module constant) -> Array[Module]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#108
  def inherited_ancestors_of(constant); end

  # : (Module constant, Symbol method) -> Method
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#146
  def method_of(constant, method); end

  # : (Module constant) -> String?
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#62
  def name_of(constant); end

  # : (T::Types::Base type) -> String
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#141
  def name_of_type(type); end

  # : (BasicObject object) -> Integer
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#83
  def object_id_of(object); end

  # : (Module constant) -> Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#103
  def private_instance_methods_of(constant); end

  # : (Module constant) -> Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#98
  def protected_instance_methods_of(constant); end

  # : (Module constant) -> Array[Symbol]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#93
  def public_instance_methods_of(constant); end

  # : (Module constant) -> String?
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#117
  def qualified_name_of(constant); end

  # Examines the call stack to identify the closest location where a "require" is performed
  # by searching for the label "<top (required)>" or "block in <class:...>" in the
  # case of an ActiveSupport.on_load hook. If none is found, it returns the location
  # labeled "<main>", which is the original call site.
  # : (Array[Thread::Backtrace::Location]? locations) -> String
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#177
  def resolve_loc(locations); end

  # : (Module constant) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#210
  def sealed_module?(constant); end

  # : ((UnboundMethod | Method) method) -> untyped
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#134
  def signature_of(method); end

  # : ((UnboundMethod | Method) method) -> untyped
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#129
  def signature_of!(method); end

  # : (Module constant) -> Class[top]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#68
  def singleton_class_of(constant); end

  # : (Class[top] constant) -> Class[top]?
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#78
  def superclass_of(constant); end

  private

  # : (Module parent, String name) -> Module?
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#247
  def child_module_for_parent_with_name(parent, name); end

  # : (String name) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#263
  def has_aliased_namespace?(name); end

  # : (UnboundMethod method) -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#258
  def method_defined_by_forwardable_module?(method); end

  # : (Module constant) -> Array[UnboundMethod]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#233
  def methods_for(constant); end

  # : (Module constant) -> Array[UnboundMethod]
  #
  # source://tapioca//lib/tapioca/runtime/reflection.rb#217
  def relevant_methods_for(constant); end
end

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#25
Tapioca::Runtime::Reflection::ANCESTORS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#21
Tapioca::Runtime::Reflection::CLASS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#22
Tapioca::Runtime::Reflection::CONSTANTS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#28
Tapioca::Runtime::Reflection::EQUAL_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#32
Tapioca::Runtime::Reflection::METHOD_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#23
Tapioca::Runtime::Reflection::NAME_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#27
Tapioca::Runtime::Reflection::OBJECT_ID_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#31
Tapioca::Runtime::Reflection::PRIVATE_INSTANCE_METHODS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#30
Tapioca::Runtime::Reflection::PROTECTED_INSTANCE_METHODS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#29
Tapioca::Runtime::Reflection::PUBLIC_INSTANCE_METHODS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : Array[String]
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#35
Tapioca::Runtime::Reflection::REQUIRED_FROM_LABELS = T.let(T.unsafe(nil), Array)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#24
Tapioca::Runtime::Reflection::SINGLETON_CLASS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# : UnboundMethod
#
# source://tapioca//lib/tapioca/runtime/reflection.rb#26
Tapioca::Runtime::Reflection::SUPERCLASS_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#6
module Tapioca::Runtime::Trackers
  class << self
    # : -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers.rb#30
    def disable_all!; end

    # : (Tracker tracker) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers.rb#35
    def register_tracker(tracker); end

    # : [Return] { -> Return } -> Return
    #
    # source://tapioca//lib/tapioca/runtime/trackers.rb#17
    def with_trackers_enabled(&blk); end
  end
end

# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#7
module Tapioca::Runtime::Trackers::Autoload
  extend ::Tapioca::Runtime::Trackers::Tracker

  class << self
    # : -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#19
    def eager_load_all!; end

    # : (String constant_name) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#31
    def register(constant_name); end

    # : [Result] { -> Result } -> Result
    #
    # source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#38
    def with_disabled_exits(&block); end
  end
end

# source://tapioca//lib/tapioca/runtime/trackers/autoload.rb#11
Tapioca::Runtime::Trackers::Autoload::NOOP_METHOD = T.let(T.unsafe(nil), Proc)

# Registers a TracePoint immediately upon load to track points at which
# classes and modules are opened for definition. This is used to track
# correspondence between classes/modules and files, as this information isn't
# available in the ruby runtime without extra accounting.
module Tapioca::Runtime::Trackers::ConstantDefinition
  extend ::Tapioca::Runtime::Trackers::Tracker
  extend ::Tapioca::Runtime::AttachedClassOf
  extend ::Tapioca::Runtime::Reflection

  class << self
    # source://tapioca//lib/tapioca/runtime/trackers/constant_definition.rb#61
    def build_constant_location(tp, locations); end

    # source://tapioca//lib/tapioca/runtime/trackers/constant_definition.rb#55
    def disable!; end

    # Returns the files in which this class or module was opened. Doesn't know
    # about situations where the class was opened prior to +require+ing,
    # or where metaprogramming was used via +eval+, etc.
    #
    # source://tapioca//lib/tapioca/runtime/trackers/constant_definition.rb#71
    def files_for(klass); end

    # source://tapioca//lib/tapioca/runtime/trackers/constant_definition.rb#75
    def locations_for(klass); end
  end
end

module Tapioca::Runtime::Trackers::Mixin
  extend ::Tapioca::Runtime::Trackers::Tracker

  class << self
    # : (Module mixin) -> Hash[Type, Hash[Module, String]]
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#52
    def constants_with_mixin(mixin); end

    # : (Module mixin, Type mixin_type, Module constant) -> String?
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#57
    def mixin_location(mixin, mixin_type, constant); end

    # : (Module constant, Module mixin, Type mixin_type) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#31
    def register(constant, mixin, mixin_type); end

    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#39
    def resolve_to_attached_class(constant, mixin, mixin_type); end

    # : [Result] { -> Result } -> Result
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#26
    def with_disabled_registration(&block); end

    private

    # : (Module mixin) -> Hash[Type, Hash[Module, String]]
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#72
    def find_or_initialize_mixin_lookup(mixin); end

    # : (Module constant, Module mixin, Type mixin_type, String location) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/mixin.rb#64
    def register_with_location(constant, mixin, mixin_type, location); end
  end
end

class Tapioca::Runtime::Trackers::Mixin::Type < ::T::Enum
  enums do
    Extend = new
    Include = new
    Prepend = new
  end
end

# source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#7
module Tapioca::Runtime::Trackers::RequiredAncestor
  extend ::Tapioca::Runtime::Trackers::Tracker

  class << self
    # : (T::Helpers requiring, ^-> void block) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#15
    def register(requiring, block); end

    # : (Module mod) -> Array[^-> void]
    #
    # source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#23
    def required_ancestors_blocks_by(mod); end

    # : (Module mod) -> Array[untyped]
    #
    # source://tapioca//lib/tapioca/runtime/trackers/required_ancestor.rb#28
    def required_ancestors_by(mod); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
module Tapioca::Runtime::Trackers::Tracker
  abstract!

  # : -> void
  #
  # source://tapioca//lib/tapioca/runtime/trackers/tracker.rb#26
  def disable!; end

  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/runtime/trackers/tracker.rb#30
  def enabled?; end

  # source://tapioca//lib/tapioca/runtime/trackers/tracker.rb#34
  def with_disabled_tracker(&block); end

  class << self
    # : ((Tracker & Module) base) -> void
    #
    # source://tapioca//lib/tapioca/runtime/trackers/tracker.rb#17
    def extended(base); end
  end
end

# : String
#
# source://tapioca//lib/tapioca.rb#31
Tapioca::SORBET_CONFIG_FILE = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#30
Tapioca::SORBET_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#5
module Tapioca::SorbetHelper
  # : (*String sorbet_args) -> Spoom::ExecResult
  #
  # source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#23
  sig { params(sorbet_args: ::String).returns(::Spoom::ExecResult) }
  def sorbet(*sorbet_args); end

  # : -> String
  #
  # source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#28
  sig { returns(::String) }
  def sorbet_path; end

  # : (Symbol feature, ?version: ::Gem::Version?) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#35
  sig { params(feature: ::Symbol, version: T.nilable(::Gem::Version)).returns(T::Boolean) }
  def sorbet_supports?(feature, version: T.unsafe(nil)); end
end

# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#18
Tapioca::SorbetHelper::FEATURE_REQUIREMENTS = T.let(T.unsafe(nil), Hash)

# : Pathname
#
# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#10
Tapioca::SorbetHelper::SORBET_BIN = T.let(T.unsafe(nil), Pathname)

# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#12
Tapioca::SorbetHelper::SORBET_EXE_PATH_ENV_VAR = T.let(T.unsafe(nil), String)

# : ::Gem::Specification
#
# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#8
Tapioca::SorbetHelper::SORBET_GEM_SPEC = T.let(T.unsafe(nil), Gem::Specification)

# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#14
Tapioca::SorbetHelper::SORBET_PAYLOAD_URL = T.let(T.unsafe(nil), String)

# : Spoom::Context
#
# source://tapioca//lib/tapioca/helpers/sorbet_helper.rb#16
Tapioca::SorbetHelper::SPOOM_CONTEXT = T.let(T.unsafe(nil), Spoom::Context)

# source://tapioca//lib/tapioca/helpers/source_uri.rb#7
class Tapioca::SourceURI < ::URI::File
  # : (String? v) -> bool
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#62
  sig { params(v: T.nilable(::String)).returns(T::Boolean) }
  def check_host(v); end

  # : -> String?
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#45
  sig { returns(T.nilable(::String)) }
  def gem_name; end

  # : String?
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#26
  sig { returns(T.nilable(::String)) }
  def gem_version; end

  # : -> String?
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#50
  sig { returns(T.nilable(::String)) }
  def line_number; end

  # : (String? v) -> void
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#55
  sig { params(v: T.nilable(::String)).void }
  def set_path(v); end

  # : -> String
  #
  # source://tapioca//lib/tapioca/helpers/source_uri.rb#74
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (gem_name: String, gem_version: String?, path: String, line_number: String?) -> instance
    #
    # source://tapioca//lib/tapioca/helpers/source_uri.rb#32
    sig do
      params(
        gem_name: ::String,
        gem_version: T.nilable(::String),
        path: ::String,
        line_number: T.nilable(::String)
      ).returns(T.attached_class)
    end
    def build(gem_name:, gem_version:, path:, line_number:); end
  end
end

# source://tapioca//lib/tapioca/helpers/source_uri.rb#10
Tapioca::SourceURI::COMPONENT = T.let(T.unsafe(nil), Array)

# `uri` for Ruby 3.4 switched the default parser from RFC2396 to RFC3986. The new parser emits a deprecation
# warning on a few methods and delegates them to RFC2396, namely `extract`/`make_regexp`/`escape`/`unescape`.
# On earlier versions of the uri gem, the RFC2396_PARSER constant doesn't exist, so it needs some special
# handling to select a parser that doesn't emit deprecations. While it was backported to Ruby 3.1, users may
# have the uri gem in their own bundle and thus not use a compatible version.
#
# source://tapioca//lib/tapioca/helpers/source_uri.rb#23
Tapioca::SourceURI::PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# source://tapioca//lib/tapioca/static/symbol_table_parser.rb#5
module Tapioca::Static; end

# source://tapioca//lib/tapioca/static/requires_compiler.rb#6
class Tapioca::Static::RequiresCompiler
  # : (String sorbet_path) -> void
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#10
  sig { params(sorbet_path: ::String).void }
  def initialize(sorbet_path); end

  # : -> String
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#15
  sig { returns(::String) }
  def compile; end

  private

  # : (Spoom::Sorbet::Config config) -> Array[String]
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#29
  sig { params(config: ::Spoom::Sorbet::Config).returns(T::Array[::String]) }
  def collect_files(config); end

  # : (String file_path) -> T::Enumerable[String]
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#44
  sig { params(file_path: ::String).returns(T::Enumerable[::String]) }
  def collect_requires(file_path); end

  # : (Spoom::Sorbet::Config config, Pathname file_path) -> bool
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#51
  sig { params(config: ::Spoom::Sorbet::Config, file_path: ::Pathname).returns(T::Boolean) }
  def file_ignored_by_sorbet?(config, file_path); end

  # : (Pathname path) -> Array[String]
  #
  # source://tapioca//lib/tapioca/static/requires_compiler.rb#80
  sig { params(path: ::Pathname).returns(T::Array[::String]) }
  def path_parts(path); end
end

# source://tapioca//lib/tapioca/static/symbol_loader.rb#6
module Tapioca::Static::SymbolLoader
  extend ::Tapioca::SorbetHelper
  extend ::Tapioca::Runtime::AttachedClassOf
  extend ::Tapioca::Runtime::Reflection

  class << self
    # : (Gemfile::GemSpec gem) -> Set[String]
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#23
    sig { params(gem: ::Tapioca::Gemfile::GemSpec).returns(T::Set[::String]) }
    def engine_symbols(gem); end

    # : (Gemfile::GemSpec gem) -> Set[String]
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#48
    sig { params(gem: ::Tapioca::Gemfile::GemSpec).returns(T::Set[::String]) }
    def gem_symbols(gem); end

    # : -> Set[String]
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#13
    sig { returns(T::Set[::String]) }
    def payload_symbols; end

    # : (Array[Pathname] paths) -> Set[String]
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#53
    sig { params(paths: T::Array[::Pathname]).returns(T::Set[::String]) }
    def symbols_from_paths(paths); end

    private

    # : -> Array[singleton(Rails::Engine)]
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#72
    def engines; end

    # : (String input, ?table_type: String) -> String
    #
    # source://tapioca//lib/tapioca/static/symbol_loader.rb#82
    sig { params(input: ::String, table_type: ::String).returns(::String) }
    def symbol_table_json_from(input, table_type: T.unsafe(nil)); end
  end
end

# source://tapioca//lib/tapioca/static/symbol_table_parser.rb#6
class Tapioca::Static::SymbolTableParser
  # : -> void
  #
  # source://tapioca//lib/tapioca/static/symbol_table_parser.rb#30
  sig { void }
  def initialize; end

  # : (String name) -> String
  #
  # source://tapioca//lib/tapioca/static/symbol_table_parser.rb#65
  sig { params(name: ::String).returns(::String) }
  def fully_qualified_name(name); end

  # : (Hash[String, untyped] object) -> void
  #
  # source://tapioca//lib/tapioca/static/symbol_table_parser.rb#36
  sig { params(object: T::Hash[::String, T.untyped]).void }
  def parse_object(object); end

  # : Set[String]
  #
  # source://tapioca//lib/tapioca/static/symbol_table_parser.rb#27
  sig { returns(T::Set[::String]) }
  def symbols; end

  class << self
    # : (String json_string) -> Set[String]
    #
    # source://tapioca//lib/tapioca/static/symbol_table_parser.rb#15
    sig { params(json_string: ::String).returns(T::Set[::String]) }
    def parse_json(json_string); end
  end
end

# : Array[String]
#
# source://tapioca//lib/tapioca/static/symbol_table_parser.rb#9
Tapioca::Static::SymbolTableParser::SKIP_PARSE_KINDS = T.let(T.unsafe(nil), Array)

# : String
#
# source://tapioca//lib/tapioca.rb#33
Tapioca::TAPIOCA_CONFIG_FILE = T.let(T.unsafe(nil), String)

# : String
#
# source://tapioca//lib/tapioca.rb#32
Tapioca::TAPIOCA_DIR = T.let(T.unsafe(nil), String)

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#108
class Tapioca::TypeVariable < ::T::Types::TypeVariable
  # @return [TypeVariable] a new instance of TypeVariable
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#109
  def initialize(name, variance); end

  # Returns the value of attribute name.
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#114
  def name; end
end

# This is subclassing from `Module` so that instances of this type will be modules.
# The reason why we want that is because that means those instances will automatically
# get bound to the constant names they are assigned to by Ruby. As a result, we don't
# need to do any matching of constants to type variables to bind their names, Ruby will
# do that automatically for us and we get the `name` method for free from `Module`.
#
# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#122
class Tapioca::TypeVariableModule < ::Module
  # : (Module context, Type type, Symbol variance, (^-> Hash[Symbol, untyped])? bounds_proc) -> void
  #
  # @return [TypeVariableModule] a new instance of TypeVariableModule
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#139
  def initialize(context, type, variance, bounds_proc); end

  # : -> Tapioca::TypeVariable
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#175
  def coerce_to_type_variable; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#155
  def fixed?; end

  # : -> String?
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#149
  def name; end

  # : -> String
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#160
  def serialize; end

  # : Type
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#136
  def type; end

  private

  # : -> Hash[Symbol, untyped]
  #
  # source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#182
  def bounds; end
end

# : ^-> Hash[Symbol, untyped]
#
# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#133
Tapioca::TypeVariableModule::DEFAULT_BOUNDS_PROC = T.let(T.unsafe(nil), Proc)

# source://tapioca//lib/tapioca/sorbet_ext/generic_name_patch.rb#125
class Tapioca::TypeVariableModule::Type < ::T::Enum
  enums do
    HasAttachedClass = new
    Member = new
    Template = new
  end
end

# source://tapioca//lib/tapioca/version.rb#5
Tapioca::VERSION = T.let(T.unsafe(nil), String)
