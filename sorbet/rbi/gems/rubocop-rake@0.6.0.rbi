# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rake` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rake`.

module RuboCop; end
module RuboCop::Cop; end
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern
module RuboCop::Cop::Rake; end

# This cop detects class or module definition in a task or namespace,
# because it is defined to the top level.
# It is confusing because the scope looks in the task or namespace,
# but actually it is defined to the top level.
#
# @example
#   # bad
#   task :foo do
#   class C
#   end
#   end
#
#   # bad
#   namespace :foo do
#   module M
#   end
#   end
#
#   # good - It is also defined to the top level,
#   #        but it looks expected behavior.
#   class C
#   end
#   task :foo do
#   end
class RuboCop::Cop::Rake::ClassDefinitionInTask < ::RuboCop::Cop::Base
  def on_class(node); end
  def on_module(node); end
end

RuboCop::Cop::Rake::ClassDefinitionInTask::MSG = T.let(T.unsafe(nil), String)

# Rake task definition should have a description with `desc` method.
# It is useful as a documentation of task. And Rake does not display
# task that does not have `desc` by `rake -T`.
#
# Note: This cop does not require description for the default task,
#       because the default task is executed with `rake` without command.
#
# @example
#   # bad
#   task :do_something
#
#   # bad
#   task :do_something do
#   end
#
#   # good
#   desc 'Do something'
#   task :do_something
#
#   # good
#   desc 'Do something'
#   task :do_something do
#   end
class RuboCop::Cop::Rake::Desc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Rake::Helper::OnTask
  extend ::RuboCop::Cop::AutoCorrector

  def on_task(node); end
  def prerequisites(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def can_insert_desc_to?(parent); end

  def parent_and_task(task_node); end

  # @return [Boolean]
  def task_with_desc?(node); end
end

RuboCop::Cop::Rake::Desc::MSG = T.let(T.unsafe(nil), String)

# If namespaces are defined with the same name, Rake executes the both namespaces
# in definition order.
# It is redundant. You should squash them into one definition.
# This cop detects it.
#
# @example
#   # bad
#   namespace :foo do
#   task :bar do
#   end
#   end
#   namespace :foo do
#   task :hoge do
#   end
#   end
#
#   # good
#   namespace :foo do
#   task :bar do
#   end
#   task :hoge do
#   end
#   end
class RuboCop::Cop::Rake::DuplicateNamespace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Rake::Helper::OnNamespace

  # @return [DuplicateNamespace] a new instance of DuplicateNamespace
  def initialize(*_arg0); end

  def message_for_dup(previous:, current:, namespace:); end
  def namespaces(node); end
  def on_namespace(node); end
  def source_location(node); end
end

RuboCop::Cop::Rake::DuplicateNamespace::MSG = T.let(T.unsafe(nil), String)

# If tasks are defined with the same name, Rake executes the both tasks
# in definition order.
# It is misleading sometimes. You should squash them into one definition.
# This cop detects it.
#
# @example
#   # bad
#   task :foo do
#   p 'foo 1'
#   end
#   task :foo do
#   p 'foo 2'
#   end
#
#   # good
#   task :foo do
#   p 'foo 1'
#   p 'foo 2'
#   end
class RuboCop::Cop::Rake::DuplicateTask < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Rake::Helper::OnTask

  # @return [DuplicateTask] a new instance of DuplicateTask
  def initialize(*_arg0); end

  def message_for_dup(previous:, current:, task_name:); end
  def namespaces(node); end
  def on_task(node); end
  def source_location(node); end
end

RuboCop::Cop::Rake::DuplicateTask::MSG = T.let(T.unsafe(nil), String)
module RuboCop::Cop::Rake::Helper; end

module RuboCop::Cop::Rake::Helper::ClassDefinition
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::Cop::Rake::Helper::ClassDefinition

  def class_definition?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def in_class_definition?(node); end
end

module RuboCop::Cop::Rake::Helper::OnNamespace
  extend ::RuboCop::AST::NodePattern::Macros

  def namespace?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

module RuboCop::Cop::Rake::Helper::OnTask
  extend ::RuboCop::AST::NodePattern::Macros

  def on_send(node); end
  def task?(param0 = T.unsafe(nil)); end
end

module RuboCop::Cop::Rake::Helper::TaskDefinition
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::Cop::Rake::Helper::TaskDefinition

  # @return [Boolean]
  def in_task_or_namespace?(node); end

  def task_or_namespace?(param0 = T.unsafe(nil)); end
end

module RuboCop::Cop::Rake::Helper::TaskName
  extend ::RuboCop::Cop::Rake::Helper::TaskName

  def task_name(node); end
end

# This cop detects method definition in a task or namespace,
# because it is defined to the top level.
# It is confusing because the scope looks in the task or namespace,
# but actually it is defined to the top level.
#
# @example
#   # bad
#   task :foo do
#   def helper_method
#   do_something
#   end
#   end
#
#   # bad
#   namespace :foo do
#   def helper_method
#   do_something
#   end
#   end
#
#   # good - It is also defined to the top level,
#   #        but it looks expected behavior.
#   def helper_method
#   end
#   task :foo do
#   end
class RuboCop::Cop::Rake::MethodDefinitionInTask < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Rake::MethodDefinitionInTask::MSG = T.let(T.unsafe(nil), String)
RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource
module RuboCop::Rake; end
RuboCop::Rake::CONFIG = T.let(T.unsafe(nil), Hash)
RuboCop::Rake::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)
class RuboCop::Rake::Error < ::StandardError; end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::Rake::Inject
  class << self
    def defaults!; end
  end
end

RuboCop::Rake::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)
RuboCop::Rake::VERSION = T.let(T.unsafe(nil), String)
RuboCop::Token = RuboCop::AST::Token
