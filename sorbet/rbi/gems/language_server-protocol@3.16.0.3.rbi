# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `language_server-protocol` gem.
# Please instead update this file by running `bin/tapioca gem language_server-protocol`.

module LanguageServer; end
module LanguageServer::Protocol; end
module LanguageServer::Protocol::Constant; end

# The kind of a code action.
#
# Kinds are a hierarchical list of identifiers separated by `.`,
# e.g. `"refactor.extract.function"`.
#
# The set of kinds is open and client needs to announce the kinds it supports
# to the server during initialization.
# A set of predefined code action kinds.
module LanguageServer::Protocol::Constant::CodeActionKind; end

# Empty kind.
LanguageServer::Protocol::Constant::CodeActionKind::EMPTY = T.let(T.unsafe(nil), String)

# Base kind for quickfix actions: 'quickfix'.
LanguageServer::Protocol::Constant::CodeActionKind::QUICK_FIX = T.let(T.unsafe(nil), String)

# Base kind for refactoring actions: 'refactor'.
LanguageServer::Protocol::Constant::CodeActionKind::REFACTOR = T.let(T.unsafe(nil), String)

# Base kind for refactoring extraction actions: 'refactor.extract'.
#
# Example extract actions:
#
# - Extract method
# - Extract function
# - Extract variable
# - Extract interface from class
# - ...
LanguageServer::Protocol::Constant::CodeActionKind::REFACTOR_EXTRACT = T.let(T.unsafe(nil), String)

# Base kind for refactoring inline actions: 'refactor.inline'.
#
# Example inline actions:
#
# - Inline function
# - Inline variable
# - Inline constant
# - ...
LanguageServer::Protocol::Constant::CodeActionKind::REFACTOR_INLINE = T.let(T.unsafe(nil), String)

# Base kind for refactoring rewrite actions: 'refactor.rewrite'.
#
# Example rewrite actions:
#
# - Convert JavaScript function to class
# - Add or remove parameter
# - Encapsulate field
# - Make method static
# - Move method to base class
# - ...
LanguageServer::Protocol::Constant::CodeActionKind::REFACTOR_REWRITE = T.let(T.unsafe(nil), String)

# Base kind for source actions: `source`.
#
# Source code actions apply to the entire file.
LanguageServer::Protocol::Constant::CodeActionKind::SOURCE = T.let(T.unsafe(nil), String)

# Base kind for an organize imports source action:
# `source.organizeImports`.
LanguageServer::Protocol::Constant::CodeActionKind::SOURCE_ORGANIZE_IMPORTS = T.let(T.unsafe(nil), String)

# The kind of a completion entry.
module LanguageServer::Protocol::Constant::CompletionItemKind; end

LanguageServer::Protocol::Constant::CompletionItemKind::CLASS = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::COLOR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::CONSTANT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::ENUM = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::EVENT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::FIELD = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::FILE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::FOLDER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::FUNCTION = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::INTERFACE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::KEYWORD = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::METHOD = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::MODULE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::OPERATOR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::PROPERTY = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::REFERENCE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::SNIPPET = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::STRUCT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::TEXT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::UNIT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::VALUE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::CompletionItemKind::VARIABLE = T.let(T.unsafe(nil), Integer)

# Completion item tags are extra annotations that tweak the rendering of a
# completion item.
module LanguageServer::Protocol::Constant::CompletionItemTag; end

# Render a completion as obsolete, usually using a strike-out.
LanguageServer::Protocol::Constant::CompletionItemTag::DEPRECATED = T.let(T.unsafe(nil), Integer)

# How a completion was triggered
module LanguageServer::Protocol::Constant::CompletionTriggerKind; end

# Completion was triggered by typing an identifier (24x7 code
# complete), manual invocation (e.g Ctrl+Space) or via API.
LanguageServer::Protocol::Constant::CompletionTriggerKind::INVOKED = T.let(T.unsafe(nil), Integer)

# Completion was triggered by a trigger character specified by
# the `triggerCharacters` properties of the
# `CompletionRegistrationOptions`.
LanguageServer::Protocol::Constant::CompletionTriggerKind::TRIGGER_CHARACTER = T.let(T.unsafe(nil), Integer)

# Completion was re-triggered as the current completion list is incomplete.
LanguageServer::Protocol::Constant::CompletionTriggerKind::TRIGGER_FOR_INCOMPLETE_COMPLETIONS = T.let(T.unsafe(nil), Integer)

module LanguageServer::Protocol::Constant::DiagnosticSeverity; end

# Reports an error.
LanguageServer::Protocol::Constant::DiagnosticSeverity::ERROR = T.let(T.unsafe(nil), Integer)

# Reports a hint.
LanguageServer::Protocol::Constant::DiagnosticSeverity::HINT = T.let(T.unsafe(nil), Integer)

# Reports an information.
LanguageServer::Protocol::Constant::DiagnosticSeverity::INFORMATION = T.let(T.unsafe(nil), Integer)

# Reports a warning.
LanguageServer::Protocol::Constant::DiagnosticSeverity::WARNING = T.let(T.unsafe(nil), Integer)

# The diagnostic tags.
module LanguageServer::Protocol::Constant::DiagnosticTag; end

# Deprecated or obsolete code.
#
# Clients are allowed to rendered diagnostics with this tag strike through.
LanguageServer::Protocol::Constant::DiagnosticTag::DEPRECATED = T.let(T.unsafe(nil), Integer)

# Unused or unnecessary code.
#
# Clients are allowed to render diagnostics with this tag faded out
# instead of having an error squiggle.
LanguageServer::Protocol::Constant::DiagnosticTag::UNNECESSARY = T.let(T.unsafe(nil), Integer)

# A document highlight kind.
module LanguageServer::Protocol::Constant::DocumentHighlightKind; end

# Read-access of a symbol, like reading a variable.
LanguageServer::Protocol::Constant::DocumentHighlightKind::READ = T.let(T.unsafe(nil), Integer)

# A textual occurrence.
LanguageServer::Protocol::Constant::DocumentHighlightKind::TEXT = T.let(T.unsafe(nil), Integer)

# Write-access of a symbol, like writing to a variable.
LanguageServer::Protocol::Constant::DocumentHighlightKind::WRITE = T.let(T.unsafe(nil), Integer)

module LanguageServer::Protocol::Constant::ErrorCodes; end
LanguageServer::Protocol::Constant::ErrorCodes::CONTENT_MODIFIED = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::INVALID_PARAMS = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::INVALID_REQUEST = T.let(T.unsafe(nil), Integer)

# This is the start range of JSON RPC reserved error codes.
# It doesn't denote a real error code.
LanguageServer::Protocol::Constant::ErrorCodes::JSONRPC_RESERVED_ERROR_RANGE_END = T.let(T.unsafe(nil), Integer)

# This is the start range of JSON RPC reserved error codes.
# It doesn't denote a real error code. No LSP error codes should
# be defined between the start and end range. For backwards
# compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
# are left in the range.
LanguageServer::Protocol::Constant::ErrorCodes::JSONRPC_RESERVED_ERROR_RANGE_START = T.let(T.unsafe(nil), Integer)

# This is the end range of LSP reserved error codes.
# It doesn't denote a real error code.
LanguageServer::Protocol::Constant::ErrorCodes::LSP_RESERVED_ERROR_RANGE_END = T.let(T.unsafe(nil), Integer)

# This is the start range of LSP reserved error codes.
# It doesn't denote a real error code.
LanguageServer::Protocol::Constant::ErrorCodes::LSP_RESERVED_ERROR_RANGE_START = T.let(T.unsafe(nil), Integer)

LanguageServer::Protocol::Constant::ErrorCodes::METHOD_NOT_FOUND = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::PARSE_ERROR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::REQUEST_CANCELLED = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::SERVER_ERROR_END = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::SERVER_ERROR_START = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::SERVER_NOT_INITIALIZED = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::ErrorCodes::UNKNOWN_ERROR_CODE = T.let(T.unsafe(nil), Integer)
module LanguageServer::Protocol::Constant::FailureHandlingKind; end

# Applying the workspace change is simply aborted if one of the changes
# provided fails. All operations executed before the failing operation
# stay executed.
LanguageServer::Protocol::Constant::FailureHandlingKind::ABORT = T.let(T.unsafe(nil), String)

# If the workspace edit contains only textual file changes they are
# executed transactional. If resource changes (create, rename or delete
# file) are part of the change the failure handling strategy is abort.
LanguageServer::Protocol::Constant::FailureHandlingKind::TEXT_ONLY_TRANSACTIONAL = T.let(T.unsafe(nil), String)

# All operations are executed transactional. That means they either all
# succeed or no changes at all are applied to the workspace.
LanguageServer::Protocol::Constant::FailureHandlingKind::TRANSACTIONAL = T.let(T.unsafe(nil), String)

# The client tries to undo the operations already executed. But there is no
# guarantee that this is succeeding.
LanguageServer::Protocol::Constant::FailureHandlingKind::UNDO = T.let(T.unsafe(nil), String)

# The file event type.
module LanguageServer::Protocol::Constant::FileChangeType; end

# The file got changed.
LanguageServer::Protocol::Constant::FileChangeType::CHANGED = T.let(T.unsafe(nil), Integer)

# The file got created.
LanguageServer::Protocol::Constant::FileChangeType::CREATED = T.let(T.unsafe(nil), Integer)

# The file got deleted.
LanguageServer::Protocol::Constant::FileChangeType::DELETED = T.let(T.unsafe(nil), Integer)

# A pattern kind describing if a glob pattern matches a file a folder or
# both.
module LanguageServer::Protocol::Constant::FileOperationPatternKind; end

# The pattern matches a file only.
LanguageServer::Protocol::Constant::FileOperationPatternKind::FILE = T.let(T.unsafe(nil), String)

# The pattern matches a folder only.
LanguageServer::Protocol::Constant::FileOperationPatternKind::FOLDER = T.let(T.unsafe(nil), String)

# Known error codes for an `InitializeError`;
module LanguageServer::Protocol::Constant::InitializeError; end

# If the protocol version provided by the client can't be handled by the
# server.
LanguageServer::Protocol::Constant::InitializeError::UNKNOWN_PROTOCOL_VERSION = T.let(T.unsafe(nil), Integer)

# Defines whether the insert text in a completion item should be interpreted as
# plain text or a snippet.
module LanguageServer::Protocol::Constant::InsertTextFormat; end

# The primary text to be inserted is treated as a plain string.
LanguageServer::Protocol::Constant::InsertTextFormat::PLAIN_TEXT = T.let(T.unsafe(nil), Integer)

# The primary text to be inserted is treated as a snippet.
#
# A snippet can define tab stops and placeholders with `$1`, `$2`
# and `${3:foo}`. `$0` defines the final tab stop, it defaults to
# the end of the snippet. Placeholders with equal identifiers are linked,
# that is typing in one will update others too.
LanguageServer::Protocol::Constant::InsertTextFormat::SNIPPET = T.let(T.unsafe(nil), Integer)

# How whitespace and indentation is handled during completion
# item insertion.
module LanguageServer::Protocol::Constant::InsertTextMode; end

# The editor adjusts leading whitespace of new lines so that
# they match the indentation up to the cursor of the line for
# which the item is accepted.
#
# Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
# multi line completion item is indented using 2 tabs and all
# following lines inserted will be indented using 2 tabs as well.
LanguageServer::Protocol::Constant::InsertTextMode::ADJUST_INDENTATION = T.let(T.unsafe(nil), Integer)

# The insertion or replace strings is taken as it is. If the
# value is multi line the lines below the cursor will be
# inserted using the indentation defined in the string value.
# The client will not apply any kind of adjustments to the
# string.
LanguageServer::Protocol::Constant::InsertTextMode::AS_IS = T.let(T.unsafe(nil), Integer)

# Describes the content type that a client supports in various
# result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
#
# Please note that `MarkupKinds` must not start with a `$`. This kinds
# are reserved for internal usage.
module LanguageServer::Protocol::Constant::MarkupKind; end

# Markdown is supported as a content format
LanguageServer::Protocol::Constant::MarkupKind::MARKDOWN = T.let(T.unsafe(nil), String)

# Plain text is supported as a content format
LanguageServer::Protocol::Constant::MarkupKind::PLAIN_TEXT = T.let(T.unsafe(nil), String)

module LanguageServer::Protocol::Constant::MessageType; end

# An error message.
LanguageServer::Protocol::Constant::MessageType::ERROR = T.let(T.unsafe(nil), Integer)

# An information message.
LanguageServer::Protocol::Constant::MessageType::INFO = T.let(T.unsafe(nil), Integer)

# A log message.
LanguageServer::Protocol::Constant::MessageType::LOG = T.let(T.unsafe(nil), Integer)

# A warning message.
LanguageServer::Protocol::Constant::MessageType::WARNING = T.let(T.unsafe(nil), Integer)

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior; end

# The client's default behavior is to select the identifier
# according the to language's syntax rule.
LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior::IDENTIFIER = T.let(T.unsafe(nil), Integer)

# The kind of resource operations supported by the client.
module LanguageServer::Protocol::Constant::ResourceOperationKind; end

# Supports creating new files and folders.
LanguageServer::Protocol::Constant::ResourceOperationKind::CREATE = T.let(T.unsafe(nil), String)

# Supports deleting existing files and folders.
LanguageServer::Protocol::Constant::ResourceOperationKind::DELETE = T.let(T.unsafe(nil), String)

# Supports renaming existing files and folders.
LanguageServer::Protocol::Constant::ResourceOperationKind::RENAME = T.let(T.unsafe(nil), String)

# How a signature help was triggered.
module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind; end

# Signature help was triggered by the cursor moving or by the document
# content changing.
LanguageServer::Protocol::Constant::SignatureHelpTriggerKind::CONTENT_CHANGE = T.let(T.unsafe(nil), Integer)

# Signature help was invoked manually by the user or by a command.
LanguageServer::Protocol::Constant::SignatureHelpTriggerKind::INVOKED = T.let(T.unsafe(nil), Integer)

# Signature help was triggered by a trigger character.
LanguageServer::Protocol::Constant::SignatureHelpTriggerKind::TRIGGER_CHARACTER = T.let(T.unsafe(nil), Integer)

# A symbol kind.
module LanguageServer::Protocol::Constant::SymbolKind; end

LanguageServer::Protocol::Constant::SymbolKind::ARRAY = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::BOOLEAN = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::CLASS = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::CONSTANT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::CONSTRUCTOR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::ENUM = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::ENUM_MEMBER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::EVENT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::FIELD = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::FILE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::FUNCTION = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::INTERFACE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::KEY = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::METHOD = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::MODULE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::NAMESPACE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::NULL = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::NUMBER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::OBJECT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::OPERATOR = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::PACKAGE = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::PROPERTY = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::STRING = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::STRUCT = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::TYPE_PARAMETER = T.let(T.unsafe(nil), Integer)
LanguageServer::Protocol::Constant::SymbolKind::VARIABLE = T.let(T.unsafe(nil), Integer)

# Symbol tags are extra annotations that tweak the rendering of a symbol.
module LanguageServer::Protocol::Constant::SymbolTag; end

# Render a symbol as obsolete, usually using a strike-out.
LanguageServer::Protocol::Constant::SymbolTag::DEPRECATED = T.let(T.unsafe(nil), Integer)

# Represents reasons why a text document is saved.
module LanguageServer::Protocol::Constant::TextDocumentSaveReason; end

# Automatic after a delay.
LanguageServer::Protocol::Constant::TextDocumentSaveReason::AFTER_DELAY = T.let(T.unsafe(nil), Integer)

# When the editor lost focus.
LanguageServer::Protocol::Constant::TextDocumentSaveReason::FOCUS_OUT = T.let(T.unsafe(nil), Integer)

# Manually triggered, e.g. by the user pressing save, by starting
# debugging, or by an API call.
LanguageServer::Protocol::Constant::TextDocumentSaveReason::MANUAL = T.let(T.unsafe(nil), Integer)

# Defines how the host (editor) should sync document changes to the language
# server.
module LanguageServer::Protocol::Constant::TextDocumentSyncKind; end

# Documents are synced by always sending the full content
# of the document.
LanguageServer::Protocol::Constant::TextDocumentSyncKind::FULL = T.let(T.unsafe(nil), Integer)

# Documents are synced by sending the full content on open.
# After that only incremental updates to the document are
# send.
LanguageServer::Protocol::Constant::TextDocumentSyncKind::INCREMENTAL = T.let(T.unsafe(nil), Integer)

# Documents should not be synced at all.
LanguageServer::Protocol::Constant::TextDocumentSyncKind::NONE = T.let(T.unsafe(nil), Integer)

module LanguageServer::Protocol::Constant::TokenFormat; end
LanguageServer::Protocol::Constant::TokenFormat::RELATIVE = T.let(T.unsafe(nil), String)
module LanguageServer::Protocol::Constant::WatchKind; end

# Interested in change events
LanguageServer::Protocol::Constant::WatchKind::CHANGE = T.let(T.unsafe(nil), Integer)

# Interested in create events.
LanguageServer::Protocol::Constant::WatchKind::CREATE = T.let(T.unsafe(nil), Integer)

# Interested in delete events
LanguageServer::Protocol::Constant::WatchKind::DELETE = T.let(T.unsafe(nil), Integer)

module LanguageServer::Protocol::Interface; end

# A special text edit with an additional change annotation.
class LanguageServer::Protocol::Interface::AnnotatedTextEdit
  # @return [AnnotatedTextEdit] a new instance of AnnotatedTextEdit
  def initialize(range:, new_text:, annotation_id:); end

  # The actual annotation identifier.
  #
  # @return [string]
  def annotation_id; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The string to be inserted. For delete operations use an
  # empty string.
  #
  # @return [string]
  def new_text; end

  # The range of the text document to be manipulated. To insert
  # text into a document create a range where start === end.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
  # @return [ApplyWorkspaceEditParams] a new instance of ApplyWorkspaceEditParams
  def initialize(edit:, label: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The edits to apply.
  #
  # @return [WorkspaceEdit]
  def edit; end

  # An optional label of the workspace edit. This label is
  # presented in the user interface for example on an undo
  # stack to undo the workspace edit.
  #
  # @return [string]
  def label; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResponse
  # @return [ApplyWorkspaceEditResponse] a new instance of ApplyWorkspaceEditResponse
  def initialize(applied:, failure_reason: T.unsafe(nil), failed_change: T.unsafe(nil)); end

  # Indicates whether the edit was applied or not.
  #
  # @return [boolean]
  def applied; end

  # Returns the value of attribute attributes.
  def attributes; end

  # Depending on the client's failure handling strategy `failedChange`
  # might contain the index of the change that failed. This property is
  # only available if the client signals a `failureHandlingStrategy`
  # in its client capabilities.
  #
  # @return [number]
  def failed_change; end

  # An optional textual description for why the edit was not applied.
  # This may be used by the server for diagnostic logging or to provide
  # a suitable error for a request that triggered the edit.
  #
  # @return [string]
  def failure_reason; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
  # @return [CallHierarchyClientCapabilities] a new instance of CallHierarchyClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration. If this is set to
  # `true` the client supports the new `(TextDocumentRegistrationOptions &
  # StaticRegistrationOptions)` return value for the corresponding server
  # capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
  # @return [CallHierarchyIncomingCall] a new instance of CallHierarchyIncomingCall
  def initialize(from:, from_ranges:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The item that makes the call.
  #
  # @return [CallHierarchyItem]
  def from; end

  # The ranges at which the calls appear. This is relative to the caller
  # denoted by [`this.from`](#CallHierarchyIncomingCall.from).
  #
  # @return [Range[]]
  def from_ranges; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
  # @return [CallHierarchyIncomingCallsParams] a new instance of CallHierarchyIncomingCallsParams
  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [CallHierarchyItem]
  def item; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
  # @return [CallHierarchyItem] a new instance of CallHierarchyItem
  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A data entry field that is preserved between a call hierarchy prepare and
  # incoming calls or outgoing calls requests.
  #
  # @return [unknown]
  def data; end

  # More detail for this item, e.g. the signature of a function.
  #
  # @return [string]
  def detail; end

  # The kind of this item.
  #
  # @return [any]
  def kind; end

  # The name of this item.
  #
  # @return [string]
  def name; end

  # The range enclosing this symbol not including leading/trailing whitespace
  # but everything else, e.g. comments and code.
  #
  # @return [Range]
  def range; end

  # The range that should be selected and revealed when this symbol is being
  # picked, e.g. the name of a function. Must be contained by the
  # [`range`](#CallHierarchyItem.range).
  #
  # @return [Range]
  def selection_range; end

  # Tags for this item.
  #
  # @return [1[]]
  def tags; end

  def to_hash; end
  def to_json(*args); end

  # The resource identifier of this item.
  #
  # @return [string]
  def uri; end
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
  # @return [CallHierarchyOptions] a new instance of CallHierarchyOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
  # @return [CallHierarchyOutgoingCall] a new instance of CallHierarchyOutgoingCall
  def initialize(to:, from_ranges:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The range at which this item is called. This is the range relative to
  # the caller, e.g the item passed to `callHierarchy/outgoingCalls` request.
  #
  # @return [Range[]]
  def from_ranges; end

  # The item that is called.
  #
  # @return [CallHierarchyItem]
  def to; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
  # @return [CallHierarchyOutgoingCallsParams] a new instance of CallHierarchyOutgoingCallsParams
  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [CallHierarchyItem]
  def item; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
  # @return [CallHierarchyPrepareParams] a new instance of CallHierarchyPrepareParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
  # @return [CallHierarchyRegistrationOptions] a new instance of CallHierarchyRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::CancelParams
  # @return [CancelParams] a new instance of CancelParams
  def initialize(id:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The request id to cancel.
  #
  # @return [string | number]
  def id; end

  def to_hash; end
  def to_json(*args); end
end

# Additional information that describes document changes.
class LanguageServer::Protocol::Interface::ChangeAnnotation
  # @return [ChangeAnnotation] a new instance of ChangeAnnotation
  def initialize(label:, needs_confirmation: T.unsafe(nil), description: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A human-readable string which is rendered less prominent in
  # the user interface.
  #
  # @return [string]
  def description; end

  # A human-readable string describing the actual change. The string
  # is rendered prominent in the user interface.
  #
  # @return [string]
  def label; end

  # A flag which indicates that user confirmation is needed
  # before applying the change.
  #
  # @return [boolean]
  def needs_confirmation; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ClientCapabilities
  # @return [ClientCapabilities] a new instance of ClientCapabilities
  def initialize(workspace: T.unsafe(nil), text_document: T.unsafe(nil), window: T.unsafe(nil), general: T.unsafe(nil), experimental: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Experimental client capabilities.
  #
  # @return [any]
  def experimental; end

  # General client capabilities.
  #
  # @return [{ regularExpressions?: RegularExpressionsClientCapabilities; markdown?: MarkdownClientCapabilities; }]
  def general; end

  # Text document specific client capabilities.
  #
  # @return [TextDocumentClientCapabilities]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # Window specific client capabilities.
  #
  # @return [{ workDoneProgress?: boolean; showMessage?: ShowMessageRequestClientCapabilities; showDocument?: ShowDocumentClientCapabilities; }]
  def window; end

  # Workspace specific client capabilities.
  #
  # @return [{ applyEdit?: boolean; workspaceEdit?: WorkspaceEditClientCapabilities; didChangeConfiguration?: DidChangeConfigurationClientCapabilities; ... 7 more ...; fileOperations?: { ...; }; }]
  def workspace; end
end

# A code action represents a change that can be performed in code, e.g. to fix
# a problem or to refactor code.
#
# A CodeAction must set either `edit` and/or a `command`. If both are supplied,
# the `edit` is applied first, then the `command` is executed.
class LanguageServer::Protocol::Interface::CodeAction
  # @return [CodeAction] a new instance of CodeAction
  def initialize(title:, kind: T.unsafe(nil), diagnostics: T.unsafe(nil), is_preferred: T.unsafe(nil), disabled: T.unsafe(nil), edit: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A command this code action executes. If a code action
  # provides an edit and a command, first the edit is
  # executed and then the command.
  #
  # @return [Command]
  def command; end

  # A data entry field that is preserved on a code action between
  # a `textDocument/codeAction` and a `codeAction/resolve` request.
  #
  # @return [any]
  def data; end

  # The diagnostics that this code action resolves.
  #
  # @return [Diagnostic[]]
  def diagnostics; end

  # Marks that the code action cannot currently be applied.
  #
  # Clients should follow the following guidelines regarding disabled code
  # actions:
  #
  # - Disabled code actions are not shown in automatic lightbulbs code
  # action menus.
  #
  # - Disabled actions are shown as faded out in the code action menu when
  # the user request a more specific type of code action, such as
  # refactorings.
  #
  # - If the user has a keybinding that auto applies a code action and only
  # a disabled code actions are returned, the client should show the user
  # an error message with `reason` in the editor.
  #
  # @return [{ reason: string; }]
  def disabled; end

  # The workspace edit this code action performs.
  #
  # @return [WorkspaceEdit]
  def edit; end

  # Marks this as a preferred action. Preferred actions are used by the
  # `auto fix` command and can be targeted by keybindings.
  #
  # A quick fix should be marked preferred if it properly addresses the
  # underlying error. A refactoring should be marked preferred if it is the
  # most reasonable choice of actions to take.
  #
  # @return [boolean]
  def is_preferred; end

  # The kind of the code action.
  #
  # Used to filter code actions.
  #
  # @return [string]
  def kind; end

  # A short, human-readable, title for this code action.
  #
  # @return [string]
  def title; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
  # @return [CodeActionClientCapabilities] a new instance of CodeActionClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), code_action_literal_support: T.unsafe(nil), is_preferred_support: T.unsafe(nil), disabled_support: T.unsafe(nil), data_support: T.unsafe(nil), resolve_support: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client supports code action literals as a valid
  # response of the `textDocument/codeAction` request.
  #
  # @return [{ codeActionKind: { valueSet: string[]; }; }]
  def code_action_literal_support; end

  # Whether code action supports the `data` property which is
  # preserved between a `textDocument/codeAction` and a
  # `codeAction/resolve` request.
  #
  # @return [boolean]
  def data_support; end

  # Whether code action supports the `disabled` property.
  #
  # @return [boolean]
  def disabled_support; end

  # Whether code action supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # Whether the client honors the change annotations in
  # text edits and resource operations returned via the
  # `CodeAction#edit` property by for example presenting
  # the workspace edit in the user interface and asking
  # for confirmation.
  #
  # @return [boolean]
  def honors_change_annotations; end

  # Whether code action supports the `isPreferred` property.
  #
  # @return [boolean]
  def is_preferred_support; end

  # Whether the client supports resolving additional code action
  # properties via a separate `codeAction/resolve` request.
  #
  # @return [{ properties: string[]; }]
  def resolve_support; end

  def to_hash; end
  def to_json(*args); end
end

# Contains additional diagnostic information about the context in which
# a code action is run.
class LanguageServer::Protocol::Interface::CodeActionContext
  # @return [CodeActionContext] a new instance of CodeActionContext
  def initialize(diagnostics:, only: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An array of diagnostics known on the client side overlapping the range
  # provided to the `textDocument/codeAction` request. They are provided so
  # that the server knows which errors are currently presented to the user
  # for the given range. There is no guarantee that these accurately reflect
  # the error state of the resource. The primary parameter
  # to compute code actions is the provided range.
  #
  # @return [Diagnostic[]]
  def diagnostics; end

  # Requested kind of actions to return.
  #
  # Actions not of this kind are filtered out by the client before being
  # shown. So servers can omit computing them.
  #
  # @return [string[]]
  def only; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionOptions
  # @return [CodeActionOptions] a new instance of CodeActionOptions
  def initialize(work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # CodeActionKinds that this server may return.
  #
  # The list of kinds may be generic, such as `CodeActionKind.Refactor`,
  # or the server may list out every specific kind they provide.
  #
  # @return [string[]]
  def code_action_kinds; end

  # The server provides support to resolve additional
  # information for a code action.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Params for the CodeActionRequest
class LanguageServer::Protocol::Interface::CodeActionParams
  # @return [CodeActionParams] a new instance of CodeActionParams
  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Context carrying additional information.
  #
  # @return [CodeActionContext]
  def context; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The range for which the command was invoked.
  #
  # @return [Range]
  def range; end

  # The document in which the command was invoked.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
  # @return [CodeActionRegistrationOptions] a new instance of CodeActionRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # CodeActionKinds that this server may return.
  #
  # The list of kinds may be generic, such as `CodeActionKind.Refactor`,
  # or the server may list out every specific kind they provide.
  #
  # @return [string[]]
  def code_action_kinds; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The server provides support to resolve additional
  # information for a code action.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Structure to capture a description for an error code.
class LanguageServer::Protocol::Interface::CodeDescription
  # @return [CodeDescription] a new instance of CodeDescription
  def initialize(href:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An URI to open with more information about the diagnostic error.
  #
  # @return [string]
  def href; end

  def to_hash; end
  def to_json(*args); end
end

# A code lens represents a command that should be shown along with
# source text, like the number of references, a way to run tests, etc.
#
# A code lens is _unresolved_ when no command is associated to it. For
# performance reasons the creation of a code lens and resolving should be done
# in two stages.
class LanguageServer::Protocol::Interface::CodeLens
  # @return [CodeLens] a new instance of CodeLens
  def initialize(range:, command: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The command this code lens represents.
  #
  # @return [Command]
  def command; end

  # A data entry field that is preserved on a code lens item between
  # a code lens and a code lens resolve request.
  #
  # @return [any]
  def data; end

  # The range in which this code lens is valid. Should only span a single
  # line.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
  # @return [CodeLensClientCapabilities] a new instance of CodeLensClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether code lens supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensOptions
  # @return [CodeLensOptions] a new instance of CodeLensOptions
  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Code lens has a resolve provider as well.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::CodeLensParams
  # @return [CodeLensParams] a new instance of CodeLensParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The document to request code lens for.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
  # @return [CodeLensRegistrationOptions] a new instance of CodeLensRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # Code lens has a resolve provider as well.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
  # @return [CodeLensWorkspaceClientCapabilities] a new instance of CodeLensWorkspaceClientCapabilities
  def initialize(refresh_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether the client implementation supports a refresh request sent from the
  # server to the client.
  #
  # Note that this event is global and will force the client to refresh all
  # code lenses currently shown. It should be used with absolute care and is
  # useful for situation where a server for example detect a project wide
  # change that requires such a calculation.
  #
  # @return [boolean]
  def refresh_support; end

  def to_hash; end
  def to_json(*args); end
end

# Represents a color in RGBA space.
class LanguageServer::Protocol::Interface::Color
  # @return [Color] a new instance of Color
  def initialize(red:, green:, blue:, alpha:); end

  # The alpha component of this color in the range [0-1].
  #
  # @return [number]
  def alpha; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The blue component of this color in the range [0-1].
  #
  # @return [number]
  def blue; end

  # The green component of this color in the range [0-1].
  #
  # @return [number]
  def green; end

  # The red component of this color in the range [0-1].
  #
  # @return [number]
  def red; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorInformation
  # @return [ColorInformation] a new instance of ColorInformation
  def initialize(range:, color:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual color value for this color range.
  #
  # @return [Color]
  def color; end

  # The range in the document where this color appears.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentation
  # @return [ColorPresentation] a new instance of ColorPresentation
  def initialize(label:, text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil)); end

  # An optional array of additional [text edits](#TextEdit) that are applied
  # when selecting this color presentation. Edits must not overlap with the
  # main [edit](#ColorPresentation.textEdit) nor with themselves.
  #
  # @return [TextEdit[]]
  def additional_text_edits; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The label of this color presentation. It will be shown on the color
  # picker header. By default this is also the text that is inserted when
  # selecting this color presentation.
  #
  # @return [string]
  def label; end

  # An [edit](#TextEdit) which is applied to a document when selecting
  # this presentation for the color.  When `falsy` the
  # [label](#ColorPresentation.label) is used.
  #
  # @return [TextEdit]
  def text_edit; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
  # @return [ColorPresentationParams] a new instance of ColorPresentationParams
  def initialize(text_document:, color:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The color information to request presentations for.
  #
  # @return [Color]
  def color; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The range where the color would be inserted. Serves as a context.
  #
  # @return [Range]
  def range; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::Command
  # @return [Command] a new instance of Command
  def initialize(title:, command:, arguments: T.unsafe(nil)); end

  # Arguments that the command handler should be
  # invoked with.
  #
  # @return [any[]]
  def arguments; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The identifier of the actual command handler.
  #
  # @return [string]
  def command; end

  # Title of the command, like `save`.
  #
  # @return [string]
  def title; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
  # @return [CompletionClientCapabilities] a new instance of CompletionClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), completion_item: T.unsafe(nil), completion_item_kind: T.unsafe(nil), context_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client supports the following `CompletionItem` specific
  # capabilities.
  #
  # @return [{ snippetSupport?: boolean; commitCharactersSupport?: boolean; documentationFormat?: MarkupKind[]; deprecatedSupport?: boolean; preselectSupport?: boolean; tagSupport?: { valueSet: 1[]; }; insertReplaceSupport?: boolean; resolveSupport?: { ...; }; insertTextModeSupport?: { ...; }; }]
  def completion_item; end

  # @return [{ valueSet?: any[]; }]
  def completion_item_kind; end

  # The client supports to send additional context information for a
  # `textDocument/completion` request.
  #
  # @return [boolean]
  def context_support; end

  # Whether completion supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

# Contains additional information about the context in which a completion
# request is triggered.
class LanguageServer::Protocol::Interface::CompletionContext
  # @return [CompletionContext] a new instance of CompletionContext
  def initialize(trigger_kind:, trigger_character: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The trigger character (a single character) that has trigger code
  # complete. Is undefined if
  # `triggerKind !== CompletionTriggerKind.TriggerCharacter`
  #
  # @return [string]
  def trigger_character; end

  # How the completion was triggered.
  #
  # @return [CompletionTriggerKind]
  def trigger_kind; end
end

class LanguageServer::Protocol::Interface::CompletionItem
  # @return [CompletionItem] a new instance of CompletionItem
  def initialize(label:, kind: T.unsafe(nil), tags: T.unsafe(nil), detail: T.unsafe(nil), documentation: T.unsafe(nil), deprecated: T.unsafe(nil), preselect: T.unsafe(nil), sort_text: T.unsafe(nil), filter_text: T.unsafe(nil), insert_text: T.unsafe(nil), insert_text_format: T.unsafe(nil), insert_text_mode: T.unsafe(nil), text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil), commit_characters: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  # An optional array of additional text edits that are applied when
  # selecting this completion. Edits must not overlap (including the same
  # insert position) with the main edit nor with themselves.
  #
  # Additional text edits should be used to change text unrelated to the
  # current cursor position (for example adding an import statement at the
  # top of the file if the completion item will insert an unqualified type).
  #
  # @return [TextEdit[]]
  def additional_text_edits; end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional command that is executed *after* inserting this completion.
  # *Note* that additional modifications to the current document should be
  # described with the additionalTextEdits-property.
  #
  # @return [Command]
  def command; end

  # An optional set of characters that when pressed while this completion is
  # active will accept it first and then type that character. *Note* that all
  # commit characters should have `length=1` and that superfluous characters
  # will be ignored.
  #
  # @return [string[]]
  def commit_characters; end

  # A data entry field that is preserved on a completion item between
  # a completion and a completion resolve request.
  #
  # @return [any]
  def data; end

  # Indicates if this item is deprecated.
  #
  # @return [boolean]
  def deprecated; end

  # A human-readable string with additional information
  # about this item, like type or symbol information.
  #
  # @return [string]
  def detail; end

  # A human-readable string that represents a doc-comment.
  #
  # @return [string | MarkupContent]
  def documentation; end

  # A string that should be used when filtering a set of
  # completion items. When `falsy` the label is used as the
  # filter text for this item.
  #
  # @return [string]
  def filter_text; end

  # A string that should be inserted into a document when selecting
  # this completion. When `falsy` the label is used as the insert text
  # for this item.
  #
  # The `insertText` is subject to interpretation by the client side.
  # Some tools might not take the string literally. For example
  # VS Code when code complete is requested in this example
  # `con<cursor position>` and a completion item with an `insertText` of
  # `console` is provided it will only insert `sole`. Therefore it is
  # recommended to use `textEdit` instead since it avoids additional client
  # side interpretation.
  #
  # @return [string]
  def insert_text; end

  # The format of the insert text. The format applies to both the
  # `insertText` property and the `newText` property of a provided
  # `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
  #
  # @return [InsertTextFormat]
  def insert_text_format; end

  # How whitespace and indentation is handled during completion
  # item insertion. If not provided the client's default value depends on
  # the `textDocument.completion.insertTextMode` client capability.
  #
  # @return [InsertTextMode]
  def insert_text_mode; end

  # The kind of this completion item. Based of the kind
  # an icon is chosen by the editor. The standardized set
  # of available values is defined in `CompletionItemKind`.
  #
  # @return [any]
  def kind; end

  # The label of this completion item. By default
  # also the text that is inserted when selecting
  # this completion.
  #
  # @return [string]
  def label; end

  # Select this item when showing.
  #
  # *Note* that only one completion item can be selected and that the
  # tool / client decides which item that is. The rule is that the *first*
  # item of those that match best is selected.
  #
  # @return [boolean]
  def preselect; end

  # A string that should be used when comparing this item
  # with other items. When `falsy` the label is used
  # as the sort text for this item.
  #
  # @return [string]
  def sort_text; end

  # Tags for this completion item.
  #
  # @return [1[]]
  def tags; end

  # An edit which is applied to a document when selecting this completion.
  # When an edit is provided the value of `insertText` is ignored.
  #
  # *Note:* The range of the edit must be a single line range and it must
  # contain the position at which completion has been requested.
  #
  # Most editors support two different operations when accepting a completion
  # item. One is to insert a completion text and the other is to replace an
  # existing text with a completion text. Since this can usually not be
  # predetermined by a server it can report both ranges. Clients need to
  # signal support for `InsertReplaceEdits` via the
  # `textDocument.completion.insertReplaceSupport` client capability
  # property.
  #
  # *Note 1:* The text edit's range as well as both ranges from an insert
  # replace edit must be a [single line] and they must contain the position
  # at which completion has been requested.
  # *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
  # must be a prefix of the edit's replace range, that means it must be
  # contained and starting at the same position.
  #
  # @return [TextEdit | InsertReplaceEdit]
  def text_edit; end

  def to_hash; end
  def to_json(*args); end
end

# Represents a collection of [completion items](#CompletionItem) to be
# presented in the editor.
class LanguageServer::Protocol::Interface::CompletionList
  # @return [CompletionList] a new instance of CompletionList
  def initialize(is_incomplete:, items:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # This list it not complete. Further typing should result in recomputing
  # this list.
  #
  # @return [boolean]
  def is_incomplete; end

  # The completion items.
  #
  # @return [CompletionItem[]]
  def items; end

  def to_hash; end
  def to_json(*args); end
end

# Completion options.
class LanguageServer::Protocol::Interface::CompletionOptions
  # @return [CompletionOptions] a new instance of CompletionOptions
  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # The list of all possible characters that commit a completion. This field
  # can be used if clients don't support individual commit characters per
  # completion item. See client capability
  # `completion.completionItem.commitCharactersSupport`.
  #
  # If a server provides both `allCommitCharacters` and commit characters on
  # an individual completion item the ones on the completion item win.
  #
  # @return [string[]]
  def all_commit_characters; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The server provides support to resolve additional
  # information for a completion item.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # Most tools trigger completion request automatically without explicitly
  # requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they
  # do so when the user starts to type an identifier. For example if the user
  # types `c` in a JavaScript file code complete will automatically pop up
  # present `console` besides others as a completion item. Characters that
  # make up identifiers don't need to be listed here.
  #
  # If code complete should automatically be trigger on characters not being
  # valid inside an identifier (for example `.` in JavaScript) list them in
  # `triggerCharacters`.
  #
  # @return [string[]]
  def trigger_characters; end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::CompletionParams
  # @return [CompletionParams] a new instance of CompletionParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The completion context. This is only available if the client specifies
  # to send this using the client capability
  # `completion.contextSupport === true`
  #
  # @return [CompletionContext]
  def context; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
  # @return [CompletionRegistrationOptions] a new instance of CompletionRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # The list of all possible characters that commit a completion. This field
  # can be used if clients don't support individual commit characters per
  # completion item. See client capability
  # `completion.completionItem.commitCharactersSupport`.
  #
  # If a server provides both `allCommitCharacters` and commit characters on
  # an individual completion item the ones on the completion item win.
  #
  # @return [string[]]
  def all_commit_characters; end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The server provides support to resolve additional
  # information for a completion item.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # Most tools trigger completion request automatically without explicitly
  # requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they
  # do so when the user starts to type an identifier. For example if the user
  # types `c` in a JavaScript file code complete will automatically pop up
  # present `console` besides others as a completion item. Characters that
  # make up identifiers don't need to be listed here.
  #
  # If code complete should automatically be trigger on characters not being
  # valid inside an identifier (for example `.` in JavaScript) list them in
  # `triggerCharacters`.
  #
  # @return [string[]]
  def trigger_characters; end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ConfigurationItem
  # @return [ConfigurationItem] a new instance of ConfigurationItem
  def initialize(scope_uri: T.unsafe(nil), section: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The scope to get the configuration section for.
  #
  # @return [string]
  def scope_uri; end

  # The configuration section asked for.
  #
  # @return [string]
  def section; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationParams
  # @return [ConfigurationParams] a new instance of ConfigurationParams
  def initialize(items:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [ConfigurationItem[]]
  def items; end

  def to_hash; end
  def to_json(*args); end
end

# Create file operation
class LanguageServer::Protocol::Interface::CreateFile
  # @return [CreateFile] a new instance of CreateFile
  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  # An optional annotation identifer describing the operation.
  #
  # @return [string]
  def annotation_id; end

  # Returns the value of attribute attributes.
  def attributes; end

  # A create
  #
  # @return ["create"]
  def kind; end

  # Additional options
  #
  # @return [CreateFileOptions]
  def options; end

  def to_hash; end
  def to_json(*args); end

  # The resource to create.
  #
  # @return [string]
  def uri; end
end

# Options to create a file.
class LanguageServer::Protocol::Interface::CreateFileOptions
  # @return [CreateFileOptions] a new instance of CreateFileOptions
  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Ignore if exists.
  #
  # @return [boolean]
  def ignore_if_exists; end

  # Overwrite existing file. Overwrite wins over `ignoreIfExists`
  #
  # @return [boolean]
  def overwrite; end

  def to_hash; end
  def to_json(*args); end
end

# The parameters sent in notifications/requests for user-initiated creation
# of files.
class LanguageServer::Protocol::Interface::CreateFilesParams
  # @return [CreateFilesParams] a new instance of CreateFilesParams
  def initialize(files:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An array of all files/folders created in this operation.
  #
  # @return [FileCreate[]]
  def files; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
  # @return [DeclarationClientCapabilities] a new instance of DeclarationClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether declaration supports dynamic registration. If this is set to
  # `true` the client supports the new `DeclarationRegistrationOptions`
  # return value for the corresponding server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports additional metadata in the form of declaration links.
  #
  # @return [boolean]
  def link_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationOptions
  # @return [DeclarationOptions] a new instance of DeclarationOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DeclarationParams
  # @return [DeclarationParams] a new instance of DeclarationParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
  # @return [DeclarationRegistrationOptions] a new instance of DeclarationRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
  # @return [DefinitionClientCapabilities] a new instance of DefinitionClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether definition supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports additional metadata in the form of definition links.
  #
  # @return [boolean]
  def link_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DefinitionOptions
  # @return [DefinitionOptions] a new instance of DefinitionOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DefinitionParams
  # @return [DefinitionParams] a new instance of DefinitionParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
  # @return [DefinitionRegistrationOptions] a new instance of DefinitionRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Delete file operation
class LanguageServer::Protocol::Interface::DeleteFile
  # @return [DeleteFile] a new instance of DeleteFile
  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  # An optional annotation identifer describing the operation.
  #
  # @return [string]
  def annotation_id; end

  # Returns the value of attribute attributes.
  def attributes; end

  # A delete
  #
  # @return ["delete"]
  def kind; end

  # Delete options.
  #
  # @return [DeleteFileOptions]
  def options; end

  def to_hash; end
  def to_json(*args); end

  # The file to delete.
  #
  # @return [string]
  def uri; end
end

# Delete file options
class LanguageServer::Protocol::Interface::DeleteFileOptions
  # @return [DeleteFileOptions] a new instance of DeleteFileOptions
  def initialize(recursive: T.unsafe(nil), ignore_if_not_exists: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Ignore the operation if the file doesn't exist.
  #
  # @return [boolean]
  def ignore_if_not_exists; end

  # Delete the content recursively if a folder is denoted.
  #
  # @return [boolean]
  def recursive; end

  def to_hash; end
  def to_json(*args); end
end

# The parameters sent in notifications/requests for user-initiated deletes
# of files.
class LanguageServer::Protocol::Interface::DeleteFilesParams
  # @return [DeleteFilesParams] a new instance of DeleteFilesParams
  def initialize(files:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An array of all files/folders deleted in this operation.
  #
  # @return [FileDelete[]]
  def files; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Diagnostic
  # @return [Diagnostic] a new instance of Diagnostic
  def initialize(range:, message:, severity: T.unsafe(nil), code: T.unsafe(nil), code_description: T.unsafe(nil), source: T.unsafe(nil), tags: T.unsafe(nil), related_information: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The diagnostic's code, which might appear in the user interface.
  #
  # @return [string | number]
  def code; end

  # An optional property to describe the error code.
  #
  # @return [CodeDescription]
  def code_description; end

  # A data entry field that is preserved between a
  # `textDocument/publishDiagnostics` notification and
  # `textDocument/codeAction` request.
  #
  # @return [unknown]
  def data; end

  # The diagnostic's message.
  #
  # @return [string]
  def message; end

  # The range at which the message applies.
  #
  # @return [Range]
  def range; end

  # An array of related diagnostic information, e.g. when symbol-names within
  # a scope collide all definitions can be marked via this property.
  #
  # @return [DiagnosticRelatedInformation[]]
  def related_information; end

  # The diagnostic's severity. Can be omitted. If omitted it is up to the
  # client to interpret diagnostics as error, warning, info or hint.
  #
  # @return [DiagnosticSeverity]
  def severity; end

  # A human-readable string describing the source of this
  # diagnostic, e.g. 'typescript' or 'super lint'.
  #
  # @return [string]
  def source; end

  # Additional metadata about the diagnostic.
  #
  # @return [DiagnosticTag[]]
  def tags; end

  def to_hash; end
  def to_json(*args); end
end

# Represents a related message and source code location for a diagnostic.
# This should be used to point to code locations that cause or are related to
# a diagnostics, e.g when duplicating a symbol in a scope.
class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
  # @return [DiagnosticRelatedInformation] a new instance of DiagnosticRelatedInformation
  def initialize(location:, message:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The location of this related diagnostic information.
  #
  # @return [Location]
  def location; end

  # The message of this related diagnostic information.
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
  # @return [DidChangeConfigurationClientCapabilities] a new instance of DidChangeConfigurationClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Did change configuration notification supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
  # @return [DidChangeConfigurationParams] a new instance of DidChangeConfigurationParams
  def initialize(settings:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual changed settings
  #
  # @return [any]
  def settings; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
  # @return [DidChangeTextDocumentParams] a new instance of DidChangeTextDocumentParams
  def initialize(text_document:, content_changes:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual content changes. The content changes describe single state
  # changes to the document. So if there are two content changes c1 (at
  # array index 0) and c2 (at array index 1) for a document in state S then
  # c1 moves the document from S to S' and c2 from S' to S''. So c1 is
  # computed on the state S and c2 is computed on the state S'.
  #
  # To mirror the content of a document using change events use the following
  # approach:
  # - start with the same initial content
  # - apply the 'textDocument/didChange' notifications in the order you
  # receive them.
  # - apply the `TextDocumentContentChangeEvent`s in a single notification
  # in the order you receive them.
  #
  # @return [TextDocumentContentChangeEvent[]]
  def content_changes; end

  # The document that did change. The version number points
  # to the version after all provided content changes have
  # been applied.
  #
  # @return [VersionedTextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
  # @return [DidChangeWatchedFilesClientCapabilities] a new instance of DidChangeWatchedFilesClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Did change watched files notification supports dynamic registration.
  # Please note that the current protocol doesn't support static
  # configuration for file changes from the server side.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
  # @return [DidChangeWatchedFilesParams] a new instance of DidChangeWatchedFilesParams
  def initialize(changes:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual file events.
  #
  # @return [FileEvent[]]
  def changes; end

  def to_hash; end
  def to_json(*args); end
end

# Describe options to be used when registering for file system change events.
class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
  # @return [DidChangeWatchedFilesRegistrationOptions] a new instance of DidChangeWatchedFilesRegistrationOptions
  def initialize(watchers:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The watchers to register.
  #
  # @return [FileSystemWatcher[]]
  def watchers; end
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
  # @return [DidChangeWorkspaceFoldersParams] a new instance of DidChangeWorkspaceFoldersParams
  def initialize(event:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual workspace folder change event.
  #
  # @return [WorkspaceFoldersChangeEvent]
  def event; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
  # @return [DidCloseTextDocumentParams] a new instance of DidCloseTextDocumentParams
  def initialize(text_document:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The document that was closed.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
  # @return [DidOpenTextDocumentParams] a new instance of DidOpenTextDocumentParams
  def initialize(text_document:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The document that was opened.
  #
  # @return [TextDocumentItem]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
  # @return [DidSaveTextDocumentParams] a new instance of DidSaveTextDocumentParams
  def initialize(text_document:, text: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Optional the content when saved. Depends on the includeText value
  # when the save notification was requested.
  #
  # @return [string]
  def text; end

  # The document that was saved.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
  # @return [DocumentColorClientCapabilities] a new instance of DocumentColorClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether document color supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
  # @return [DocumentColorOptions] a new instance of DocumentColorOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentColorParams
  # @return [DocumentColorParams] a new instance of DocumentColorParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
  # @return [DocumentColorRegistrationOptions] a new instance of DocumentColorRegistrationOptions
  def initialize(document_selector:, id: T.unsafe(nil), work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentFilter
  # @return [DocumentFilter] a new instance of DocumentFilter
  def initialize(language: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A language id, like `typescript`.
  #
  # @return [string]
  def language; end

  # A glob pattern, like `*.{ts,js}`.
  #
  # Glob patterns can have the following syntax:
  # - `*` to match one or more characters in a path segment
  # - `?` to match on one character in a path segment
  # - `**` to match any number of path segments, including none
  # - `{}` to group sub patterns into an OR expression. (e.g. `**/*.{ts,js}`
  # matches all TypeScript and JavaScript files)
  # - `[]` to declare a range of characters to match in a path segment
  # (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
  # - `[!...]` to negate a range of characters to match in a path segment
  # (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but
  # not `example.0`)
  #
  # @return [string]
  def pattern; end

  # A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
  #
  # @return [string]
  def scheme; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
  # @return [DocumentFormattingClientCapabilities] a new instance of DocumentFormattingClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether formatting supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
  # @return [DocumentFormattingOptions] a new instance of DocumentFormattingOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
  # @return [DocumentFormattingParams] a new instance of DocumentFormattingParams
  def initialize(text_document:, options:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The format options.
  #
  # @return [FormattingOptions]
  def options; end

  # The document to format.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
  # @return [DocumentFormattingRegistrationOptions] a new instance of DocumentFormattingRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# A document highlight is a range inside a text document which deserves
# special attention. Usually a document highlight is visualized by changing
# the background color of its range.
class LanguageServer::Protocol::Interface::DocumentHighlight
  # @return [DocumentHighlight] a new instance of DocumentHighlight
  def initialize(range:, kind: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The highlight kind, default is DocumentHighlightKind.Text.
  #
  # @return [DocumentHighlightKind]
  def kind; end

  # The range this highlight applies to.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
  # @return [DocumentHighlightClientCapabilities] a new instance of DocumentHighlightClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether document highlight supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
  # @return [DocumentHighlightOptions] a new instance of DocumentHighlightOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
  # @return [DocumentHighlightParams] a new instance of DocumentHighlightParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
  # @return [DocumentHighlightRegistrationOptions] a new instance of DocumentHighlightRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# A document link is a range in a text document that links to an internal or
# external resource, like another text document or a web site.
class LanguageServer::Protocol::Interface::DocumentLink
  # @return [DocumentLink] a new instance of DocumentLink
  def initialize(range:, target: T.unsafe(nil), tooltip: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A data entry field that is preserved on a document link between a
  # DocumentLinkRequest and a DocumentLinkResolveRequest.
  #
  # @return [any]
  def data; end

  # The range this link applies to.
  #
  # @return [Range]
  def range; end

  # The uri this link points to. If missing a resolve request is sent later.
  #
  # @return [string]
  def target; end

  def to_hash; end
  def to_json(*args); end

  # The tooltip text when you hover over this link.
  #
  # If a tooltip is provided, is will be displayed in a string that includes
  # instructions on how to trigger the link, such as `{0} (ctrl + click)`.
  # The specific instructions vary depending on OS, user settings, and
  # localization.
  #
  # @return [string]
  def tooltip; end
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
  # @return [DocumentLinkClientCapabilities] a new instance of DocumentLinkClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), tooltip_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether document link supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end

  # Whether the client supports the `tooltip` property on `DocumentLink`.
  #
  # @return [boolean]
  def tooltip_support; end
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
  # @return [DocumentLinkOptions] a new instance of DocumentLinkOptions
  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Document links have a resolve provider as well.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
  # @return [DocumentLinkParams] a new instance of DocumentLinkParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The document to provide document links for.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
  # @return [DocumentLinkRegistrationOptions] a new instance of DocumentLinkRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # Document links have a resolve provider as well.
  #
  # @return [boolean]
  def resolve_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
  # @return [DocumentOnTypeFormattingClientCapabilities] a new instance of DocumentOnTypeFormattingClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether on type formatting supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
  # @return [DocumentOnTypeFormattingOptions] a new instance of DocumentOnTypeFormattingOptions
  def initialize(first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A character on which formatting should be triggered, like `}`.
  #
  # @return [string]
  def first_trigger_character; end

  # More trigger characters.
  #
  # @return [string[]]
  def more_trigger_character; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
  # @return [DocumentOnTypeFormattingParams] a new instance of DocumentOnTypeFormattingParams
  def initialize(text_document:, position:, ch:, options:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The character that has been typed.
  #
  # @return [string]
  def ch; end

  # The format options.
  #
  # @return [FormattingOptions]
  def options; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
  # @return [DocumentOnTypeFormattingRegistrationOptions] a new instance of DocumentOnTypeFormattingRegistrationOptions
  def initialize(document_selector:, first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # A character on which formatting should be triggered, like `}`.
  #
  # @return [string]
  def first_trigger_character; end

  # More trigger characters.
  #
  # @return [string[]]
  def more_trigger_character; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
  # @return [DocumentRangeFormattingClientCapabilities] a new instance of DocumentRangeFormattingClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether formatting supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
  # @return [DocumentRangeFormattingOptions] a new instance of DocumentRangeFormattingOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
  # @return [DocumentRangeFormattingParams] a new instance of DocumentRangeFormattingParams
  def initialize(text_document:, range:, options:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The format options
  #
  # @return [FormattingOptions]
  def options; end

  # The range to format
  #
  # @return [Range]
  def range; end

  # The document to format.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
  # @return [DocumentRangeFormattingRegistrationOptions] a new instance of DocumentRangeFormattingRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Represents programming constructs like variables, classes, interfaces etc.
# that appear in a document. Document symbols can be hierarchical and they
# have two ranges: one that encloses its definition and one that points to its
# most interesting range, e.g. the range of an identifier.
class LanguageServer::Protocol::Interface::DocumentSymbol
  # @return [DocumentSymbol] a new instance of DocumentSymbol
  def initialize(name:, kind:, range:, selection_range:, detail: T.unsafe(nil), tags: T.unsafe(nil), deprecated: T.unsafe(nil), children: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Children of this symbol, e.g. properties of a class.
  #
  # @return [DocumentSymbol[]]
  def children; end

  # Indicates if this symbol is deprecated.
  #
  # @return [boolean]
  def deprecated; end

  # More detail for this symbol, e.g the signature of a function.
  #
  # @return [string]
  def detail; end

  # The kind of this symbol.
  #
  # @return [any]
  def kind; end

  # The name of this symbol. Will be displayed in the user interface and
  # therefore must not be an empty string or a string only consisting of
  # white spaces.
  #
  # @return [string]
  def name; end

  # The range enclosing this symbol not including leading/trailing whitespace
  # but everything else like comments. This information is typically used to
  # determine if the clients cursor is inside the symbol to reveal in the
  # symbol in the UI.
  #
  # @return [Range]
  def range; end

  # The range that should be selected and revealed when this symbol is being
  # picked, e.g. the name of a function. Must be contained by the `range`.
  #
  # @return [Range]
  def selection_range; end

  # Tags for this document symbol.
  #
  # @return [1[]]
  def tags; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
  # @return [DocumentSymbolClientCapabilities] a new instance of DocumentSymbolClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), hierarchical_document_symbol_support: T.unsafe(nil), tag_support: T.unsafe(nil), label_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether document symbol supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports hierarchical document symbols.
  #
  # @return [boolean]
  def hierarchical_document_symbol_support; end

  # The client supports an additional label presented in the UI when
  # registering a document symbol provider.
  #
  # @return [boolean]
  def label_support; end

  # Specific capabilities for the `SymbolKind` in the
  # `textDocument/documentSymbol` request.
  #
  # @return [{ valueSet?: any[]; }]
  def symbol_kind; end

  # The client supports tags on `SymbolInformation`. Tags are supported on
  # `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
  # Clients supporting tags have to handle unknown tags gracefully.
  #
  # @return [{ valueSet: 1[]; }]
  def tag_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
  # @return [DocumentSymbolOptions] a new instance of DocumentSymbolOptions
  def initialize(work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A human-readable string that is shown when multiple outlines trees
  # are shown for the same document.
  #
  # @return [string]
  def label; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
  # @return [DocumentSymbolParams] a new instance of DocumentSymbolParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
  # @return [DocumentSymbolRegistrationOptions] a new instance of DocumentSymbolRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # A human-readable string that is shown when multiple outlines trees
  # are shown for the same document.
  #
  # @return [string]
  def label; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
  # @return [ExecuteCommandClientCapabilities] a new instance of ExecuteCommandClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Execute command supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
  # @return [ExecuteCommandOptions] a new instance of ExecuteCommandOptions
  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The commands to be executed on the server
  #
  # @return [string[]]
  def commands; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
  # @return [ExecuteCommandParams] a new instance of ExecuteCommandParams
  def initialize(command:, work_done_token: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Arguments that the command should be invoked with.
  #
  # @return [any[]]
  def arguments; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The identifier of the actual command handler.
  #
  # @return [string]
  def command; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

# Execute command registration options.
class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
  # @return [ExecuteCommandRegistrationOptions] a new instance of ExecuteCommandRegistrationOptions
  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The commands to be executed on the server
  #
  # @return [string[]]
  def commands; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Represents information on a file/folder create.
class LanguageServer::Protocol::Interface::FileCreate
  # @return [FileCreate] a new instance of FileCreate
  def initialize(uri:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # A file:// URI for the location of the file/folder being created.
  #
  # @return [string]
  def uri; end
end

# Represents information on a file/folder delete.
class LanguageServer::Protocol::Interface::FileDelete
  # @return [FileDelete] a new instance of FileDelete
  def initialize(uri:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # A file:// URI for the location of the file/folder being deleted.
  #
  # @return [string]
  def uri; end
end

# An event describing a file change.
class LanguageServer::Protocol::Interface::FileEvent
  # @return [FileEvent] a new instance of FileEvent
  def initialize(uri:, type:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The change type.
  #
  # @return [number]
  def type; end

  # The file's URI.
  #
  # @return [string]
  def uri; end
end

# A filter to describe in which file operation requests or notifications
# the server is interested in.
class LanguageServer::Protocol::Interface::FileOperationFilter
  # @return [FileOperationFilter] a new instance of FileOperationFilter
  def initialize(pattern:, scheme: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual file operation pattern.
  #
  # @return [FileOperationPattern]
  def pattern; end

  # A Uri like `file` or `untitled`.
  #
  # @return [string]
  def scheme; end

  def to_hash; end
  def to_json(*args); end
end

# A pattern to describe in which file operation requests or notifications
# the server is interested in.
class LanguageServer::Protocol::Interface::FileOperationPattern
  # @return [FileOperationPattern] a new instance of FileOperationPattern
  def initialize(glob:, matches: T.unsafe(nil), options: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The glob pattern to match. Glob patterns can have the following syntax:
  # - `*` to match one or more characters in a path segment
  # - `?` to match on one character in a path segment
  # - `**` to match any number of path segments, including none
  # - `{}` to group sub patterns into an OR expression. (e.g. `**/*.{ts,js}`
  # matches all TypeScript and JavaScript files)
  # - `[]` to declare a range of characters to match in a path segment
  # (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
  # - `[!...]` to negate a range of characters to match in a path segment
  # (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but
  # not `example.0`)
  #
  # @return [string]
  def glob; end

  # Whether to match files or folders with this pattern.
  #
  # Matches both if undefined.
  #
  # @return [FileOperationPatternKind]
  def matches; end

  # Additional options used during matching.
  #
  # @return [FileOperationPatternOptions]
  def options; end

  def to_hash; end
  def to_json(*args); end
end

# Matching options for the file operation pattern.
class LanguageServer::Protocol::Interface::FileOperationPatternOptions
  # @return [FileOperationPatternOptions] a new instance of FileOperationPatternOptions
  def initialize(ignore_case: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The pattern should be matched ignoring casing.
  #
  # @return [boolean]
  def ignore_case; end

  def to_hash; end
  def to_json(*args); end
end

# The options to register for file operations.
class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
  # @return [FileOperationRegistrationOptions] a new instance of FileOperationRegistrationOptions
  def initialize(filters:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual filters.
  #
  # @return [FileOperationFilter[]]
  def filters; end

  def to_hash; end
  def to_json(*args); end
end

# Represents information on a file/folder rename.
class LanguageServer::Protocol::Interface::FileRename
  # @return [FileRename] a new instance of FileRename
  def initialize(old_uri:, new_uri:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A file:// URI for the new location of the file/folder being renamed.
  #
  # @return [string]
  def new_uri; end

  # A file:// URI for the original location of the file/folder being renamed.
  #
  # @return [string]
  def old_uri; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
  # @return [FileSystemWatcher] a new instance of FileSystemWatcher
  def initialize(glob_pattern:, kind: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The  glob pattern to watch.
  #
  # Glob patterns can have the following syntax:
  # - `*` to match one or more characters in a path segment
  # - `?` to match on one character in a path segment
  # - `**` to match any number of path segments, including none
  # - `{}` to group sub patterns into an OR expression. (e.g. `**/*.{ts,js}`
  # matches all TypeScript and JavaScript files)
  # - `[]` to declare a range of characters to match in a path segment
  # (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
  # - `[!...]` to negate a range of characters to match in a path segment
  # (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not
  # `example.0`)
  #
  # @return [string]
  def glob_pattern; end

  # The kind of events of interest. If omitted it defaults
  # to WatchKind.Create | WatchKind.Change | WatchKind.Delete
  # which is 7.
  #
  # @return [number]
  def kind; end

  def to_hash; end
  def to_json(*args); end
end

# Represents a folding range. To be valid, start and end line must be bigger
# than zero and smaller than the number of lines in the document. Clients
# are free to ignore invalid ranges.
class LanguageServer::Protocol::Interface::FoldingRange
  # @return [FoldingRange] a new instance of FoldingRange
  def initialize(start_line:, end_line:, start_character: T.unsafe(nil), end_character: T.unsafe(nil), kind: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The zero-based character offset before the folded range ends. If not
  # defined, defaults to the length of the end line.
  #
  # @return [number]
  def end_character; end

  # The zero-based end line of the range to fold. The folded area ends with
  # the line's last character. To be valid, the end must be zero or larger
  # and smaller than the number of lines in the document.
  #
  # @return [number]
  def end_line; end

  # Describes the kind of the folding range such as `comment` or `region`.
  # The kind is used to categorize folding ranges and used by commands like
  # 'Fold all comments'. See [FoldingRangeKind](#FoldingRangeKind) for an
  # enumeration of standardized kinds.
  #
  # @return [string]
  def kind; end

  # The zero-based character offset from where the folded range starts. If
  # not defined, defaults to the length of the start line.
  #
  # @return [number]
  def start_character; end

  # The zero-based start line of the range to fold. The folded area starts
  # after the line's last character. To be valid, the end must be zero or
  # larger and smaller than the number of lines in the document.
  #
  # @return [number]
  def start_line; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
  # @return [FoldingRangeClientCapabilities] a new instance of FoldingRangeClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), range_limit: T.unsafe(nil), line_folding_only: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration for folding range
  # providers. If this is set to `true` the client supports the new
  # `FoldingRangeRegistrationOptions` return value for the corresponding
  # server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  # If set, the client signals that it only supports folding complete lines.
  # If set, client will ignore specified `startCharacter` and `endCharacter`
  # properties in a FoldingRange.
  #
  # @return [boolean]
  def line_folding_only; end

  # The maximum number of folding ranges that the client prefers to receive
  # per document. The value serves as a hint, servers are free to follow the
  # limit.
  #
  # @return [number]
  def range_limit; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
  # @return [FoldingRangeOptions] a new instance of FoldingRangeOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
  # @return [FoldingRangeParams] a new instance of FoldingRangeParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
  # @return [FoldingRangeRegistrationOptions] a new instance of FoldingRangeRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Value-object describing what options formatting should use.
class LanguageServer::Protocol::Interface::FormattingOptions
  # @return [FormattingOptions] a new instance of FormattingOptions
  def initialize(tab_size:, insert_spaces:, trim_trailing_whitespace: T.unsafe(nil), insert_final_newline: T.unsafe(nil), trim_final_newlines: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Insert a newline character at the end of the file if one does not exist.
  #
  # @return [boolean]
  def insert_final_newline; end

  # Prefer spaces over tabs.
  #
  # @return [boolean]
  def insert_spaces; end

  # Size of a tab in spaces.
  #
  # @return [number]
  def tab_size; end

  def to_hash; end
  def to_json(*args); end

  # Trim all newlines after the final newline at the end of the file.
  #
  # @return [boolean]
  def trim_final_newlines; end

  # Trim trailing whitespace on a line.
  #
  # @return [boolean]
  def trim_trailing_whitespace; end
end

# The result of a hover request.
class LanguageServer::Protocol::Interface::Hover
  # @return [Hover] a new instance of Hover
  def initialize(contents:, range: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The hover's content
  #
  # @return [MarkupContent | MarkedString | MarkedString[]]
  def contents; end

  # An optional range is a range inside a text document
  # that is used to visualize a hover, e.g. by changing the background color.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
  # @return [HoverClientCapabilities] a new instance of HoverClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), content_format: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Client supports the following content formats if the content
  # property refers to a `literal of type MarkupContent`.
  # The order describes the preferred format of the client.
  #
  # @return [MarkupKind[]]
  def content_format; end

  # Whether hover supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverOptions
  # @return [HoverOptions] a new instance of HoverOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::HoverParams
  # @return [HoverParams] a new instance of HoverParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
  # @return [HoverRegistrationOptions] a new instance of HoverRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
  # @return [ImplementationClientCapabilities] a new instance of ImplementationClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration. If this is set to
  # `true` the client supports the new `ImplementationRegistrationOptions`
  # return value for the corresponding server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports additional metadata in the form of definition links.
  #
  # @return [boolean]
  def link_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ImplementationOptions
  # @return [ImplementationOptions] a new instance of ImplementationOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ImplementationParams
  # @return [ImplementationParams] a new instance of ImplementationParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
  # @return [ImplementationRegistrationOptions] a new instance of ImplementationRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# Known error codes for an `InitializeError`;
class LanguageServer::Protocol::Interface::InitializeError
  # @return [InitializeError] a new instance of InitializeError
  def initialize(retry:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Indicates whether the client execute the following retry logic:
  # (1) show the message provided by the ResponseError to the user
  # (2) user selects retry or cancel
  # (3) if user selected retry the initialize method is sent again.
  #
  # @return [boolean]
  def retry; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeParams
  # @return [InitializeParams] a new instance of InitializeParams
  def initialize(process_id:, root_uri:, capabilities:, work_done_token: T.unsafe(nil), client_info: T.unsafe(nil), locale: T.unsafe(nil), root_path: T.unsafe(nil), initialization_options: T.unsafe(nil), trace: T.unsafe(nil), workspace_folders: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The capabilities provided by the client (editor or tool)
  #
  # @return [ClientCapabilities]
  def capabilities; end

  # Information about the client
  #
  # @return [{ name: string; version?: string; }]
  def client_info; end

  # User provided initialization options.
  #
  # @return [any]
  def initialization_options; end

  # The locale the client is currently showing the user interface
  # in. This must not necessarily be the locale of the operating
  # system.
  #
  # Uses IETF language tags as the value's syntax
  # (See https://en.wikipedia.org/wiki/IETF_language_tag)
  #
  # @return [string]
  def locale; end

  # The process Id of the parent process that started the server. Is null if
  # the process has not been started by another process. If the parent
  # process is not alive then the server should exit (see exit notification)
  # its process.
  #
  # @return [number]
  def process_id; end

  # The rootPath of the workspace. Is null
  # if no folder is open.
  #
  # @return [string]
  def root_path; end

  # The rootUri of the workspace. Is null if no
  # folder is open. If both `rootPath` and `rootUri` are set
  # `rootUri` wins.
  #
  # @return [string]
  def root_uri; end

  def to_hash; end
  def to_json(*args); end

  # The initial trace setting. If omitted trace is disabled ('off').
  #
  # @return [TraceValue]
  def trace; end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end

  # The workspace folders configured in the client when the server starts.
  # This property is only available if the client supports workspace folders.
  # It can be `null` if the client supports workspace folders but none are
  # configured.
  #
  # @return [WorkspaceFolder[]]
  def workspace_folders; end
end

class LanguageServer::Protocol::Interface::InitializeResult
  # @return [InitializeResult] a new instance of InitializeResult
  def initialize(capabilities:, server_info: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The capabilities the language server provides.
  #
  # @return [ServerCapabilities]
  def capabilities; end

  # Information about the server.
  #
  # @return [{ name: string; version?: string; }]
  def server_info; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializedParams
  # @return [InitializedParams] a new instance of InitializedParams
  def initialize; end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end
end

# A special text edit to provide an insert and a replace operation.
class LanguageServer::Protocol::Interface::InsertReplaceEdit
  # @return [InsertReplaceEdit] a new instance of InsertReplaceEdit
  def initialize(new_text:, insert:, replace:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The range if the insert is requested
  #
  # @return [Range]
  def insert; end

  # The string to be inserted.
  #
  # @return [string]
  def new_text; end

  # The range if the replace is requested.
  #
  # @return [Range]
  def replace; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
  # @return [LinkedEditingRangeClientCapabilities] a new instance of LinkedEditingRangeClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration.
  # If this is set to `true` the client supports the new
  # `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
  # return value for the corresponding server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
  # @return [LinkedEditingRangeOptions] a new instance of LinkedEditingRangeOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
  # @return [LinkedEditingRangeParams] a new instance of LinkedEditingRangeParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
  # @return [LinkedEditingRangeRegistrationOptions] a new instance of LinkedEditingRangeRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
  # @return [LinkedEditingRanges] a new instance of LinkedEditingRanges
  def initialize(ranges:, word_pattern: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A list of ranges that can be renamed together. The ranges must have
  # identical length and contain identical text content. The ranges cannot overlap.
  #
  # @return [Range[]]
  def ranges; end

  def to_hash; end
  def to_json(*args); end

  # An optional word pattern (regular expression) that describes valid contents for
  # the given ranges. If no pattern is provided, the client configuration's word
  # pattern will be used.
  #
  # @return [string]
  def word_pattern; end
end

class LanguageServer::Protocol::Interface::Location
  # @return [Location] a new instance of Location
  def initialize(uri:, range:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end

  # @return [string]
  def uri; end
end

class LanguageServer::Protocol::Interface::LocationLink
  # @return [LocationLink] a new instance of LocationLink
  def initialize(target_uri:, target_range:, target_selection_range:, origin_selection_range: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Span of the origin of this link.
  #
  # Used as the underlined span for mouse interaction. Defaults to the word
  # range at the mouse position.
  #
  # @return [Range]
  def origin_selection_range; end

  # The full target range of this link. If the target for example is a symbol
  # then target range is the range enclosing this symbol not including
  # leading/trailing whitespace but everything else like comments. This
  # information is typically used to highlight the range in the editor.
  #
  # @return [Range]
  def target_range; end

  # The range that should be selected and revealed when this link is being
  # followed, e.g the name of a function. Must be contained by the the
  # `targetRange`. See also `DocumentSymbol#range`
  #
  # @return [Range]
  def target_selection_range; end

  # The target resource identifier of this link.
  #
  # @return [string]
  def target_uri; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LogMessageParams
  # @return [LogMessageParams] a new instance of LogMessageParams
  def initialize(type:, message:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual message
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end

  # The message type. See {@link MessageType}
  #
  # @return [MessageType]
  def type; end
end

class LanguageServer::Protocol::Interface::LogTraceParams
  # @return [LogTraceParams] a new instance of LogTraceParams
  def initialize(message:, verbose: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The message to be logged.
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end

  # Additional information that can be computed if the `trace` configuration
  # is set to `'verbose'`
  #
  # @return [string]
  def verbose; end
end

# Client capabilities specific to the used markdown parser.
class LanguageServer::Protocol::Interface::MarkdownClientCapabilities
  # @return [MarkdownClientCapabilities] a new instance of MarkdownClientCapabilities
  def initialize(parser:, version: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The name of the parser.
  #
  # @return [string]
  def parser; end

  def to_hash; end
  def to_json(*args); end

  # The version of the parser.
  #
  # @return [string]
  def version; end
end

# A `MarkupContent` literal represents a string value which content is
# interpreted base on its kind flag. Currently the protocol supports
# `plaintext` and `markdown` as markup kinds.
#
# If the kind is `markdown` then the value can contain fenced code blocks like
# in GitHub issues.
#
# Here is an example how such a string can be constructed using
# JavaScript / TypeScript:
# ```typescript
# let markdown: MarkdownContent = {
# kind: MarkupKind.Markdown,
# value: [
# '# Header',
# 'Some text',
# '```typescript',
# 'someCode();',
# '```'
# ].join('\n')
# };
# ```
#
# *Please Note* that clients might sanitize the return markdown. A client could
# decide to remove HTML from the markdown to avoid script execution.
class LanguageServer::Protocol::Interface::MarkupContent
  # @return [MarkupContent] a new instance of MarkupContent
  def initialize(kind:, value:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The type of the Markup
  #
  # @return [MarkupKind]
  def kind; end

  def to_hash; end
  def to_json(*args); end

  # The content itself
  #
  # @return [string]
  def value; end
end

class LanguageServer::Protocol::Interface::Message
  # @return [Message] a new instance of Message
  def initialize(jsonrpc:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [string]
  def jsonrpc; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MessageActionItem
  # @return [MessageActionItem] a new instance of MessageActionItem
  def initialize(title:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A short title like 'Retry', 'Open Log' etc.
  #
  # @return [string]
  def title; end

  def to_hash; end
  def to_json(*args); end
end

# Moniker definition to match LSIF 0.5 moniker definition.
class LanguageServer::Protocol::Interface::Moniker
  # @return [Moniker] a new instance of Moniker
  def initialize(scheme:, identifier:, unique:, kind: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The identifier of the moniker. The value is opaque in LSIF however
  # schema owners are allowed to define the structure if they want.
  #
  # @return [string]
  def identifier; end

  # The moniker kind if known.
  #
  # @return [MonikerKind]
  def kind; end

  # The scheme of the moniker. For example tsc or .Net
  #
  # @return [string]
  def scheme; end

  def to_hash; end
  def to_json(*args); end

  # The scope in which the moniker is unique
  #
  # @return [UniquenessLevel]
  def unique; end
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
  # @return [MonikerClientCapabilities] a new instance of MonikerClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration. If this is set to
  # `true` the client supports the new `(TextDocumentRegistrationOptions &
  # StaticRegistrationOptions)` return value for the corresponding server
  # capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MonikerOptions
  # @return [MonikerOptions] a new instance of MonikerOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::MonikerParams
  # @return [MonikerParams] a new instance of MonikerParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
  # @return [MonikerRegistrationOptions] a new instance of MonikerRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::NotificationMessage
  # @return [NotificationMessage] a new instance of NotificationMessage
  def initialize(jsonrpc:, method:, params: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [string]
  def jsonrpc; end

  # The method to be invoked.
  #
  # @return [string]
  def method; end

  # The notification's params.
  #
  # @return [any]
  def params; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
  # @return [OptionalVersionedTextDocumentIdentifier] a new instance of OptionalVersionedTextDocumentIdentifier
  def initialize(uri:, version:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The text document's URI.
  #
  # @return [string]
  def uri; end

  # The version number of this document. If an optional versioned text document
  # identifier is sent from the server to the client and the file is not
  # open in the editor (the server has not received an open notification
  # before) the server can send `null` to indicate that the version is
  # known and the content on disk is the master (as specified with document
  # content ownership).
  #
  # The version number of a document will increase after each change,
  # including undo/redo. The number doesn't need to be consecutive.
  #
  # @return [number]
  def version; end
end

# Represents a parameter of a callable-signature. A parameter can
# have a label and a doc-comment.
class LanguageServer::Protocol::Interface::ParameterInformation
  # @return [ParameterInformation] a new instance of ParameterInformation
  def initialize(label:, documentation: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The human-readable doc-comment of this parameter. Will be shown
  # in the UI but can be omitted.
  #
  # @return [string | MarkupContent]
  def documentation; end

  # The label of this parameter information.
  #
  # Either a string or an inclusive start and exclusive end offsets within
  # its containing signature label. (see SignatureInformation.label). The
  # offsets are based on a UTF-16 string representation as `Position` and
  # `Range` does.
  #
  # *Note*: a label of type string should be a substring of its containing
  # signature label. Its intended use case is to highlight the parameter
  # label part in the `SignatureInformation.label`.
  #
  # @return [string | [number, number]]
  def label; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PartialResultParams
  # @return [PartialResultParams] a new instance of PartialResultParams
  def initialize(partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Position
  # @return [Position] a new instance of Position
  def initialize(line:, character:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Character offset on a line in a document (zero-based). Assuming that
  # the line is represented as a string, the `character` value represents
  # the gap between the `character` and `character + 1`.
  #
  # If the character value is greater than the line length it defaults back
  # to the line length.
  #
  # @return [number]
  def character; end

  # Line position in a document (zero-based).
  #
  # @return [number]
  def line; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
  # @return [PrepareRenameParams] a new instance of PrepareRenameParams
  def initialize(text_document:, position:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ProgressParams
  # @return [ProgressParams] a new instance of ProgressParams
  def initialize(token:, value:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The progress token provided by the client or server.
  #
  # @return [ProgressToken]
  def token; end

  # The progress data.
  #
  # @return [T]
  def value; end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
  # @return [PublishDiagnosticsClientCapabilities] a new instance of PublishDiagnosticsClientCapabilities
  def initialize(related_information: T.unsafe(nil), tag_support: T.unsafe(nil), version_support: T.unsafe(nil), code_description_support: T.unsafe(nil), data_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Client supports a codeDescription property
  #
  # @return [boolean]
  def code_description_support; end

  # Whether code action supports the `data` property which is
  # preserved between a `textDocument/publishDiagnostics` and
  # `textDocument/codeAction` request.
  #
  # @return [boolean]
  def data_support; end

  # Whether the clients accepts diagnostics with related information.
  #
  # @return [boolean]
  def related_information; end

  # Client supports the tag property to provide meta data about a diagnostic.
  # Clients supporting tags have to handle unknown tags gracefully.
  #
  # @return [{ valueSet: DiagnosticTag[]; }]
  def tag_support; end

  def to_hash; end
  def to_json(*args); end

  # Whether the client interprets the version property of the
  # `textDocument/publishDiagnostics` notification's parameter.
  #
  # @return [boolean]
  def version_support; end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
  # @return [PublishDiagnosticsParams] a new instance of PublishDiagnosticsParams
  def initialize(uri:, diagnostics:, version: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An array of diagnostic information items.
  #
  # @return [Diagnostic[]]
  def diagnostics; end

  def to_hash; end
  def to_json(*args); end

  # The URI for which diagnostic information is reported.
  #
  # @return [string]
  def uri; end

  # Optional the version number of the document the diagnostics are published
  # for.
  #
  # @return [number]
  def version; end
end

class LanguageServer::Protocol::Interface::Range
  # @return [Range] a new instance of Range
  def initialize(start:, end:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The range's end position.
  #
  # @return [Position]
  def end; end

  # The range's start position.
  #
  # @return [Position]
  def start; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
  # @return [ReferenceClientCapabilities] a new instance of ReferenceClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether references supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceContext
  # @return [ReferenceContext] a new instance of ReferenceContext
  def initialize(include_declaration:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Include the declaration of the current symbol.
  #
  # @return [boolean]
  def include_declaration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceOptions
  # @return [ReferenceOptions] a new instance of ReferenceOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::ReferenceParams
  # @return [ReferenceParams] a new instance of ReferenceParams
  def initialize(text_document:, position:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [ReferenceContext]
  def context; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
  # @return [ReferenceRegistrationOptions] a new instance of ReferenceRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# General parameters to register for a capability.
class LanguageServer::Protocol::Interface::Registration
  # @return [Registration] a new instance of Registration
  def initialize(id:, method:, register_options: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The id used to register the request. The id can be used to deregister
  # the request again.
  #
  # @return [string]
  def id; end

  # The method / capability to register for.
  #
  # @return [string]
  def method; end

  # Options necessary for the registration.
  #
  # @return [any]
  def register_options; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegistrationParams
  # @return [RegistrationParams] a new instance of RegistrationParams
  def initialize(registrations:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [Registration[]]
  def registrations; end

  def to_hash; end
  def to_json(*args); end
end

# Client capabilities specific to regular expressions.
class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
  # @return [RegularExpressionsClientCapabilities] a new instance of RegularExpressionsClientCapabilities
  def initialize(engine:, version: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The engine's name.
  #
  # @return [string]
  def engine; end

  def to_hash; end
  def to_json(*args); end

  # The engine's version.
  #
  # @return [string]
  def version; end
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
  # @return [RenameClientCapabilities] a new instance of RenameClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), prepare_support: T.unsafe(nil), prepare_support_default_behavior: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether rename supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # Whether th client honors the change annotations in
  # text edits and resource operations returned via the
  # rename request's workspace edit by for example presenting
  # the workspace edit in the user interface and asking
  # for confirmation.
  #
  # @return [boolean]
  def honors_change_annotations; end

  # Client supports testing for validity of rename operations
  # before execution.
  #
  # @return [boolean]
  def prepare_support; end

  # Client supports the default behavior result
  # (`{ defaultBehavior: boolean }`).
  #
  # The value indicates the default behavior used by the
  # client.
  #
  # @return [any]
  def prepare_support_default_behavior; end

  def to_hash; end
  def to_json(*args); end
end

# Rename file operation
class LanguageServer::Protocol::Interface::RenameFile
  # @return [RenameFile] a new instance of RenameFile
  def initialize(kind:, old_uri:, new_uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  # An optional annotation identifer describing the operation.
  #
  # @return [string]
  def annotation_id; end

  # Returns the value of attribute attributes.
  def attributes; end

  # A rename
  #
  # @return ["rename"]
  def kind; end

  # The new location.
  #
  # @return [string]
  def new_uri; end

  # The old (existing) location.
  #
  # @return [string]
  def old_uri; end

  # Rename options.
  #
  # @return [RenameFileOptions]
  def options; end

  def to_hash; end
  def to_json(*args); end
end

# Rename file options
class LanguageServer::Protocol::Interface::RenameFileOptions
  # @return [RenameFileOptions] a new instance of RenameFileOptions
  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Ignores if target exists.
  #
  # @return [boolean]
  def ignore_if_exists; end

  # Overwrite target if existing. Overwrite wins over `ignoreIfExists`
  #
  # @return [boolean]
  def overwrite; end

  def to_hash; end
  def to_json(*args); end
end

# The parameters sent in notifications/requests for user-initiated renames
# of files.
class LanguageServer::Protocol::Interface::RenameFilesParams
  # @return [RenameFilesParams] a new instance of RenameFilesParams
  def initialize(files:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An array of all files/folders renamed in this operation. When a folder
  # is renamed, only the folder will be included, and not its children.
  #
  # @return [FileRename[]]
  def files; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameOptions
  # @return [RenameOptions] a new instance of RenameOptions
  def initialize(work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Renames should be checked and tested before being executed.
  #
  # @return [boolean]
  def prepare_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::RenameParams
  # @return [RenameParams] a new instance of RenameParams
  def initialize(text_document:, position:, new_name:, work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The new name of the symbol. If the given name is not valid the
  # request must return a [ResponseError](#ResponseError) with an
  # appropriate message set.
  #
  # @return [string]
  def new_name; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
  # @return [RenameRegistrationOptions] a new instance of RenameRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # Renames should be checked and tested before being executed.
  #
  # @return [boolean]
  def prepare_provider; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::RequestMessage
  # @return [RequestMessage] a new instance of RequestMessage
  def initialize(jsonrpc:, id:, method:, params: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The request id.
  #
  # @return [string | number]
  def id; end

  # @return [string]
  def jsonrpc; end

  # The method to be invoked.
  #
  # @return [string]
  def method; end

  # The method's params.
  #
  # @return [any]
  def params; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseError
  # @return [ResponseError] a new instance of ResponseError
  def initialize(code:, message:, data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A number indicating the error type that occurred.
  #
  # @return [number]
  def code; end

  # A primitive or structured value that contains additional
  # information about the error. Can be omitted.
  #
  # @return [any]
  def data; end

  # A string providing a short description of the error.
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseMessage
  # @return [ResponseMessage] a new instance of ResponseMessage
  def initialize(jsonrpc:, id:, result: T.unsafe(nil), error: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The error object in case a request fails.
  #
  # @return [ResponseError]
  def error; end

  # The request id.
  #
  # @return [string | number]
  def id; end

  # @return [string]
  def jsonrpc; end

  # The result of a request. This member is REQUIRED on success.
  # This member MUST NOT exist if there was an error invoking the method.
  #
  # @return [string | number | boolean | object]
  def result; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SaveOptions
  # @return [SaveOptions] a new instance of SaveOptions
  def initialize(include_text: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client is supposed to include the content on save.
  #
  # @return [boolean]
  def include_text; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRange
  # @return [SelectionRange] a new instance of SelectionRange
  def initialize(range:, parent: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The parent selection range containing this range. Therefore
  # `parent.range` must contain `this.range`.
  #
  # @return [SelectionRange]
  def parent; end

  # The [range](#Range) of this selection range.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
  # @return [SelectionRangeClientCapabilities] a new instance of SelectionRangeClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration for selection range
  # providers. If this is set to `true` the client supports the new
  # `SelectionRangeRegistrationOptions` return value for the corresponding
  # server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
  # @return [SelectionRangeOptions] a new instance of SelectionRangeOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
  # @return [SelectionRangeParams] a new instance of SelectionRangeParams
  def initialize(text_document:, positions:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The positions inside the text document.
  #
  # @return [Position[]]
  def positions; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
  # @return [SelectionRangeRegistrationOptions] a new instance of SelectionRangeRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::SemanticTokens
  # @return [SemanticTokens] a new instance of SemanticTokens
  def initialize(data:, result_id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual tokens.
  #
  # @return [number[]]
  def data; end

  # An optional result id. If provided and clients support delta updating
  # the client will include the result id in the next semantic token request.
  # A server can then instead of computing all semantic tokens again simply
  # send a delta.
  #
  # @return [string]
  def result_id; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
  # @return [SemanticTokensClientCapabilities] a new instance of SemanticTokensClientCapabilities
  def initialize(requests:, token_types:, token_modifiers:, formats:, dynamic_registration: T.unsafe(nil), overlapping_token_support: T.unsafe(nil), multiline_token_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration. If this is set to
  # `true` the client supports the new `(TextDocumentRegistrationOptions &
  # StaticRegistrationOptions)` return value for the corresponding server
  # capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The formats the clients supports.
  #
  # @return ["relative"[]]
  def formats; end

  # Whether the client supports tokens that can span multiple lines.
  #
  # @return [boolean]
  def multiline_token_support; end

  # Whether the client supports tokens that can overlap each other.
  #
  # @return [boolean]
  def overlapping_token_support; end

  # Which requests the client supports and might send to the server
  # depending on the server's capability. Please note that clients might not
  # show semantic tokens or degrade some of the user experience if a range
  # or full request is advertised by the client but not provided by the
  # server. If for example the client capability `requests.full` and
  # `request.range` are both set to true but the server only provides a
  # range provider the client might not render a minimap correctly or might
  # even decide to not show any semantic tokens at all.
  #
  # @return [{ range?: boolean | {}; full?: boolean | { delta?: boolean; }; }]
  def requests; end

  def to_hash; end
  def to_json(*args); end

  # The token modifiers that the client supports.
  #
  # @return [string[]]
  def token_modifiers; end

  # The token types that the client supports.
  #
  # @return [string[]]
  def token_types; end
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
  # @return [SemanticTokensDelta] a new instance of SemanticTokensDelta
  def initialize(edits:, result_id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The semantic token edits to transform a previous result into a new
  # result.
  #
  # @return [SemanticTokensEdit[]]
  def edits; end

  # @return [string]
  def result_id; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
  # @return [SemanticTokensDeltaParams] a new instance of SemanticTokensDeltaParams
  def initialize(text_document:, previous_result_id:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The result id of a previous response. The result Id can either point to
  # a full response or a delta response depending on what was received last.
  #
  # @return [string]
  def previous_result_id; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
  # @return [SemanticTokensDeltaPartialResult] a new instance of SemanticTokensDeltaPartialResult
  def initialize(edits:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [SemanticTokensEdit[]]
  def edits; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
  # @return [SemanticTokensEdit] a new instance of SemanticTokensEdit
  def initialize(start:, delete_count:, data: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The elements to insert.
  #
  # @return [number[]]
  def data; end

  # The count of elements to remove.
  #
  # @return [number]
  def delete_count; end

  # The start offset of the edit.
  #
  # @return [number]
  def start; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
  # @return [SemanticTokensLegend] a new instance of SemanticTokensLegend
  def initialize(token_types:, token_modifiers:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The token modifiers a server uses.
  #
  # @return [string[]]
  def token_modifiers; end

  # The token types a server uses.
  #
  # @return [string[]]
  def token_types; end
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
  # @return [SemanticTokensOptions] a new instance of SemanticTokensOptions
  def initialize(legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Server supports providing semantic tokens for a full document.
  #
  # @return [boolean | { delta?: boolean; }]
  def full; end

  # The legend used by the server
  #
  # @return [SemanticTokensLegend]
  def legend; end

  # Server supports providing semantic tokens for a specific range
  # of a document.
  #
  # @return [boolean | {}]
  def range; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
  # @return [SemanticTokensParams] a new instance of SemanticTokensParams
  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
  # @return [SemanticTokensPartialResult] a new instance of SemanticTokensPartialResult
  def initialize(data:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return [number[]]
  def data; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
  # @return [SemanticTokensRangeParams] a new instance of SemanticTokensRangeParams
  def initialize(text_document:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The range the semantic tokens are requested for.
  #
  # @return [Range]
  def range; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
  # @return [SemanticTokensRegistrationOptions] a new instance of SemanticTokensRegistrationOptions
  def initialize(document_selector:, legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # Server supports providing semantic tokens for a full document.
  #
  # @return [boolean | { delta?: boolean; }]
  def full; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  # The legend used by the server
  #
  # @return [SemanticTokensLegend]
  def legend; end

  # Server supports providing semantic tokens for a specific range
  # of a document.
  #
  # @return [boolean | {}]
  def range; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
  # @return [SemanticTokensWorkspaceClientCapabilities] a new instance of SemanticTokensWorkspaceClientCapabilities
  def initialize(refresh_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether the client implementation supports a refresh request sent from
  # the server to the client.
  #
  # Note that this event is global and will force the client to refresh all
  # semantic tokens currently shown. It should be used with absolute care
  # and is useful for situation where a server for example detect a project
  # wide change that requires such a calculation.
  #
  # @return [boolean]
  def refresh_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ServerCapabilities
  # @return [ServerCapabilities] a new instance of ServerCapabilities
  def initialize(text_document_sync: T.unsafe(nil), completion_provider: T.unsafe(nil), hover_provider: T.unsafe(nil), signature_help_provider: T.unsafe(nil), declaration_provider: T.unsafe(nil), definition_provider: T.unsafe(nil), type_definition_provider: T.unsafe(nil), implementation_provider: T.unsafe(nil), references_provider: T.unsafe(nil), document_highlight_provider: T.unsafe(nil), document_symbol_provider: T.unsafe(nil), code_action_provider: T.unsafe(nil), code_lens_provider: T.unsafe(nil), document_link_provider: T.unsafe(nil), color_provider: T.unsafe(nil), document_formatting_provider: T.unsafe(nil), document_range_formatting_provider: T.unsafe(nil), document_on_type_formatting_provider: T.unsafe(nil), rename_provider: T.unsafe(nil), folding_range_provider: T.unsafe(nil), execute_command_provider: T.unsafe(nil), selection_range_provider: T.unsafe(nil), linked_editing_range_provider: T.unsafe(nil), call_hierarchy_provider: T.unsafe(nil), semantic_tokens_provider: T.unsafe(nil), moniker_provider: T.unsafe(nil), workspace_symbol_provider: T.unsafe(nil), workspace: T.unsafe(nil), experimental: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The server provides call hierarchy support.
  #
  # @return [boolean | CallHierarchyOptions | CallHierarchyRegistrationOptions]
  def call_hierarchy_provider; end

  # The server provides code actions. The `CodeActionOptions` return type is
  # only valid if the client signals code action literal support via the
  # property `textDocument.codeAction.codeActionLiteralSupport`.
  #
  # @return [boolean | CodeActionOptions]
  def code_action_provider; end

  # The server provides code lens.
  #
  # @return [CodeLensOptions]
  def code_lens_provider; end

  # The server provides color provider support.
  #
  # @return [boolean | DocumentColorOptions | DocumentColorRegistrationOptions]
  def color_provider; end

  # The server provides completion support.
  #
  # @return [CompletionOptions]
  def completion_provider; end

  # The server provides go to declaration support.
  #
  # @return [boolean | DeclarationOptions | DeclarationRegistrationOptions]
  def declaration_provider; end

  # The server provides goto definition support.
  #
  # @return [boolean | DefinitionOptions]
  def definition_provider; end

  # The server provides document formatting.
  #
  # @return [boolean | DocumentFormattingOptions]
  def document_formatting_provider; end

  # The server provides document highlight support.
  #
  # @return [boolean | DocumentHighlightOptions]
  def document_highlight_provider; end

  # The server provides document link support.
  #
  # @return [DocumentLinkOptions]
  def document_link_provider; end

  # The server provides document formatting on typing.
  #
  # @return [DocumentOnTypeFormattingOptions]
  def document_on_type_formatting_provider; end

  # The server provides document range formatting.
  #
  # @return [boolean | DocumentRangeFormattingOptions]
  def document_range_formatting_provider; end

  # The server provides document symbol support.
  #
  # @return [boolean | DocumentSymbolOptions]
  def document_symbol_provider; end

  # The server provides execute command support.
  #
  # @return [ExecuteCommandOptions]
  def execute_command_provider; end

  # Experimental server capabilities.
  #
  # @return [any]
  def experimental; end

  # The server provides folding provider support.
  #
  # @return [boolean | FoldingRangeOptions | FoldingRangeRegistrationOptions]
  def folding_range_provider; end

  # The server provides hover support.
  #
  # @return [boolean | HoverOptions]
  def hover_provider; end

  # The server provides goto implementation support.
  #
  # @return [boolean | ImplementationOptions | ImplementationRegistrationOptions]
  def implementation_provider; end

  # The server provides linked editing range support.
  #
  # @return [boolean | LinkedEditingRangeOptions | LinkedEditingRangeRegistrationOptions]
  def linked_editing_range_provider; end

  # Whether server provides moniker support.
  #
  # @return [boolean | MonikerOptions | MonikerRegistrationOptions]
  def moniker_provider; end

  # The server provides find references support.
  #
  # @return [boolean | ReferenceOptions]
  def references_provider; end

  # The server provides rename support. RenameOptions may only be
  # specified if the client states that it supports
  # `prepareSupport` in its initial `initialize` request.
  #
  # @return [boolean | RenameOptions]
  def rename_provider; end

  # The server provides selection range support.
  #
  # @return [boolean | SelectionRangeOptions | SelectionRangeRegistrationOptions]
  def selection_range_provider; end

  # The server provides semantic tokens support.
  #
  # @return [SemanticTokensOptions | SemanticTokensRegistrationOptions]
  def semantic_tokens_provider; end

  # The server provides signature help support.
  #
  # @return [SignatureHelpOptions]
  def signature_help_provider; end

  # Defines how text documents are synced. Is either a detailed structure
  # defining each notification or for backwards compatibility the
  # TextDocumentSyncKind number. If omitted it defaults to
  # `TextDocumentSyncKind.None`.
  #
  # @return [TextDocumentSyncOptions | TextDocumentSyncKind]
  def text_document_sync; end

  def to_hash; end
  def to_json(*args); end

  # The server provides goto type definition support.
  #
  # @return [boolean | TypeDefinitionOptions | TypeDefinitionRegistrationOptions]
  def type_definition_provider; end

  # Workspace specific server capabilities
  #
  # @return [{ workspaceFolders?: WorkspaceFoldersServerCapabilities; fileOperations?: { didCreate?: FileOperationRegistrationOptions; ... 4 more ...; willDelete?: FileOperationRegistrationOptions; }; }]
  def workspace; end

  # The server provides workspace symbol support.
  #
  # @return [boolean | WorkspaceSymbolOptions]
  def workspace_symbol_provider; end
end

class LanguageServer::Protocol::Interface::SetTraceParams
  # @return [SetTraceParams] a new instance of SetTraceParams
  def initialize(value:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The new value that should be assigned to the trace setting.
  #
  # @return [TraceValue]
  def value; end
end

# Client capabilities for the show document request.
class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
  # @return [ShowDocumentClientCapabilities] a new instance of ShowDocumentClientCapabilities
  def initialize(support:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client has support for the show document
  # request.
  #
  # @return [boolean]
  def support; end

  def to_hash; end
  def to_json(*args); end
end

# Params to show a document.
class LanguageServer::Protocol::Interface::ShowDocumentParams
  # @return [ShowDocumentParams] a new instance of ShowDocumentParams
  def initialize(uri:, external: T.unsafe(nil), take_focus: T.unsafe(nil), selection: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Indicates to show the resource in an external program.
  # To show for example `https://code.visualstudio.com/`
  # in the default WEB browser set `external` to `true`.
  #
  # @return [boolean]
  def external; end

  # An optional selection range if the document is a text
  # document. Clients might ignore the property if an
  # external program is started or the file is not a text
  # file.
  #
  # @return [Range]
  def selection; end

  # An optional property to indicate whether the editor
  # showing the document should take focus or not.
  # Clients might ignore this property if an external
  # program is started.
  #
  # @return [boolean]
  def take_focus; end

  def to_hash; end
  def to_json(*args); end

  # The document uri to show.
  #
  # @return [string]
  def uri; end
end

# The result of an show document request.
class LanguageServer::Protocol::Interface::ShowDocumentResult
  # @return [ShowDocumentResult] a new instance of ShowDocumentResult
  def initialize(success:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A boolean indicating if the show was successful.
  #
  # @return [boolean]
  def success; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageParams
  # @return [ShowMessageParams] a new instance of ShowMessageParams
  def initialize(type:, message:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual message.
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end

  # The message type. See {@link MessageType}.
  #
  # @return [MessageType]
  def type; end
end

# Show message request client capabilities
class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
  # @return [ShowMessageRequestClientCapabilities] a new instance of ShowMessageRequestClientCapabilities
  def initialize(message_action_item: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Capabilities specific to the `MessageActionItem` type.
  #
  # @return [{ additionalPropertiesSupport?: boolean; }]
  def message_action_item; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
  # @return [ShowMessageRequestParams] a new instance of ShowMessageRequestParams
  def initialize(type:, message:, actions: T.unsafe(nil)); end

  # The message action items to present.
  #
  # @return [MessageActionItem[]]
  def actions; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The actual message
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end

  # The message type. See {@link MessageType}
  #
  # @return [MessageType]
  def type; end
end

# Signature help represents the signature of something
# callable. There can be multiple signature but only one
# active and only one active parameter.
class LanguageServer::Protocol::Interface::SignatureHelp
  # @return [SignatureHelp] a new instance of SignatureHelp
  def initialize(signatures:, active_signature: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  # The active parameter of the active signature. If omitted or the value
  # lies outside the range of `signatures[activeSignature].parameters`
  # defaults to 0 if the active signature has parameters. If
  # the active signature has no parameters it is ignored.
  # In future version of the protocol this property might become
  # mandatory to better express the active parameter if the
  # active signature does have any.
  #
  # @return [number]
  def active_parameter; end

  # The active signature. If omitted or the value lies outside the
  # range of `signatures` the value defaults to zero or is ignored if
  # the `SignatureHelp` has no signatures.
  #
  # Whenever possible implementors should make an active decision about
  # the active signature and shouldn't rely on a default value.
  #
  # In future version of the protocol this property might become
  # mandatory to better express this.
  #
  # @return [number]
  def active_signature; end

  # Returns the value of attribute attributes.
  def attributes; end

  # One or more signatures. If no signatures are available the signature help
  # request should return `null`.
  #
  # @return [SignatureInformation[]]
  def signatures; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
  # @return [SignatureHelpClientCapabilities] a new instance of SignatureHelpClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), signature_information: T.unsafe(nil), context_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client supports to send additional context information for a
  # `textDocument/signatureHelp` request. A client that opts into
  # contextSupport will also support the `retriggerCharacters` on
  # `SignatureHelpOptions`.
  #
  # @return [boolean]
  def context_support; end

  # Whether signature help supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports the following `SignatureInformation`
  # specific properties.
  #
  # @return [{ documentationFormat?: MarkupKind[]; parameterInformation?: { labelOffsetSupport?: boolean; }; activeParameterSupport?: boolean; }]
  def signature_information; end

  def to_hash; end
  def to_json(*args); end
end

# Additional information about the context in which a signature help request
# was triggered.
class LanguageServer::Protocol::Interface::SignatureHelpContext
  # @return [SignatureHelpContext] a new instance of SignatureHelpContext
  def initialize(trigger_kind:, is_retrigger:, trigger_character: T.unsafe(nil), active_signature_help: T.unsafe(nil)); end

  # The currently active `SignatureHelp`.
  #
  # The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field
  # updated based on the user navigating through available signatures.
  #
  # @return [SignatureHelp]
  def active_signature_help; end

  # Returns the value of attribute attributes.
  def attributes; end

  # `true` if signature help was already showing when it was triggered.
  #
  # Retriggers occur when the signature help is already active and can be
  # caused by actions such as typing a trigger character, a cursor move, or
  # document content changes.
  #
  # @return [boolean]
  def is_retrigger; end

  def to_hash; end
  def to_json(*args); end

  # Character that caused signature help to be triggered.
  #
  # This is undefined when triggerKind !==
  # SignatureHelpTriggerKind.TriggerCharacter
  #
  # @return [string]
  def trigger_character; end

  # Action that caused signature help to be triggered.
  #
  # @return [SignatureHelpTriggerKind]
  def trigger_kind; end
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
  # @return [SignatureHelpOptions] a new instance of SignatureHelpOptions
  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # List of characters that re-trigger signature help.
  #
  # These trigger characters are only active when signature help is already
  # showing. All trigger characters are also counted as re-trigger
  # characters.
  #
  # @return [string[]]
  def retrigger_characters; end

  def to_hash; end
  def to_json(*args); end

  # The characters that trigger signature help
  # automatically.
  #
  # @return [string[]]
  def trigger_characters; end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
  # @return [SignatureHelpParams] a new instance of SignatureHelpParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The signature help context. This is only available if the client
  # specifies to send this using the client capability
  # `textDocument.signatureHelp.contextSupport === true`
  #
  # @return [SignatureHelpContext]
  def context; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
  # @return [SignatureHelpRegistrationOptions] a new instance of SignatureHelpRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # List of characters that re-trigger signature help.
  #
  # These trigger characters are only active when signature help is already
  # showing. All trigger characters are also counted as re-trigger
  # characters.
  #
  # @return [string[]]
  def retrigger_characters; end

  def to_hash; end
  def to_json(*args); end

  # The characters that trigger signature help
  # automatically.
  #
  # @return [string[]]
  def trigger_characters; end

  # @return [boolean]
  def work_done_progress; end
end

# Represents the signature of something callable. A signature
# can have a label, like a function-name, a doc-comment, and
# a set of parameters.
class LanguageServer::Protocol::Interface::SignatureInformation
  # @return [SignatureInformation] a new instance of SignatureInformation
  def initialize(label:, documentation: T.unsafe(nil), parameters: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  # The index of the active parameter.
  #
  # If provided, this is used in place of `SignatureHelp.activeParameter`.
  #
  # @return [number]
  def active_parameter; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The human-readable doc-comment of this signature. Will be shown
  # in the UI but can be omitted.
  #
  # @return [string | MarkupContent]
  def documentation; end

  # The label of this signature. Will be shown in
  # the UI.
  #
  # @return [string]
  def label; end

  # The parameters of this signature.
  #
  # @return [ParameterInformation[]]
  def parameters; end

  def to_hash; end
  def to_json(*args); end
end

# Static registration options to be returned in the initialize request.
class LanguageServer::Protocol::Interface::StaticRegistrationOptions
  # @return [StaticRegistrationOptions] a new instance of StaticRegistrationOptions
  def initialize(id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end
end

# Represents information about programming constructs like variables, classes,
# interfaces etc.
class LanguageServer::Protocol::Interface::SymbolInformation
  # @return [SymbolInformation] a new instance of SymbolInformation
  def initialize(name:, kind:, location:, tags: T.unsafe(nil), deprecated: T.unsafe(nil), container_name: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The name of the symbol containing this symbol. This information is for
  # user interface purposes (e.g. to render a qualifier in the user interface
  # if necessary). It can't be used to re-infer a hierarchy for the document
  # symbols.
  #
  # @return [string]
  def container_name; end

  # Indicates if this symbol is deprecated.
  #
  # @return [boolean]
  def deprecated; end

  # The kind of this symbol.
  #
  # @return [any]
  def kind; end

  # The location of this symbol. The location's range is used by a tool
  # to reveal the location in the editor. If the symbol is selected in the
  # tool the range's start information is used to position the cursor. So
  # the range usually spans more then the actual symbol's name and does
  # normally include things like visibility modifiers.
  #
  # The range doesn't have to denote a node range in the sense of a abstract
  # syntax tree. It can therefore not be used to re-construct a hierarchy of
  # the symbols.
  #
  # @return [Location]
  def location; end

  # The name of this symbol.
  #
  # @return [string]
  def name; end

  # Tags for this symbol.
  #
  # @return [1[]]
  def tags; end

  def to_hash; end
  def to_json(*args); end
end

# Describe options to be used when registering for text document change events.
class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
  # @return [TextDocumentChangeRegistrationOptions] a new instance of TextDocumentChangeRegistrationOptions
  def initialize(document_selector:, sync_kind:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # How documents are synced to the server. See TextDocumentSyncKind.Full
  # and TextDocumentSyncKind.Incremental.
  #
  # @return [TextDocumentSyncKind]
  def sync_kind; end

  def to_hash; end
  def to_json(*args); end
end

# Text document specific client capabilities.
class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
  # @return [TextDocumentClientCapabilities] a new instance of TextDocumentClientCapabilities
  def initialize(synchronization: T.unsafe(nil), completion: T.unsafe(nil), hover: T.unsafe(nil), signature_help: T.unsafe(nil), declaration: T.unsafe(nil), definition: T.unsafe(nil), type_definition: T.unsafe(nil), implementation: T.unsafe(nil), references: T.unsafe(nil), document_highlight: T.unsafe(nil), document_symbol: T.unsafe(nil), code_action: T.unsafe(nil), code_lens: T.unsafe(nil), document_link: T.unsafe(nil), color_provider: T.unsafe(nil), formatting: T.unsafe(nil), range_formatting: T.unsafe(nil), on_type_formatting: T.unsafe(nil), rename: T.unsafe(nil), publish_diagnostics: T.unsafe(nil), folding_range: T.unsafe(nil), selection_range: T.unsafe(nil), linked_editing_range: T.unsafe(nil), call_hierarchy: T.unsafe(nil), semantic_tokens: T.unsafe(nil), moniker: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Capabilities specific to the various call hierarchy requests.
  #
  # @return [CallHierarchyClientCapabilities]
  def call_hierarchy; end

  # Capabilities specific to the `textDocument/codeAction` request.
  #
  # @return [CodeActionClientCapabilities]
  def code_action; end

  # Capabilities specific to the `textDocument/codeLens` request.
  #
  # @return [CodeLensClientCapabilities]
  def code_lens; end

  # Capabilities specific to the `textDocument/documentColor` and the
  # `textDocument/colorPresentation` request.
  #
  # @return [DocumentColorClientCapabilities]
  def color_provider; end

  # Capabilities specific to the `textDocument/completion` request.
  #
  # @return [CompletionClientCapabilities]
  def completion; end

  # Capabilities specific to the `textDocument/declaration` request.
  #
  # @return [DeclarationClientCapabilities]
  def declaration; end

  # Capabilities specific to the `textDocument/definition` request.
  #
  # @return [DefinitionClientCapabilities]
  def definition; end

  # Capabilities specific to the `textDocument/documentHighlight` request.
  #
  # @return [DocumentHighlightClientCapabilities]
  def document_highlight; end

  # Capabilities specific to the `textDocument/documentLink` request.
  #
  # @return [DocumentLinkClientCapabilities]
  def document_link; end

  # Capabilities specific to the `textDocument/documentSymbol` request.
  #
  # @return [DocumentSymbolClientCapabilities]
  def document_symbol; end

  # Capabilities specific to the `textDocument/foldingRange` request.
  #
  # @return [FoldingRangeClientCapabilities]
  def folding_range; end

  # Capabilities specific to the `textDocument/formatting` request.
  #
  # @return [DocumentFormattingClientCapabilities]
  def formatting; end

  # Capabilities specific to the `textDocument/hover` request.
  #
  # @return [HoverClientCapabilities]
  def hover; end

  # Capabilities specific to the `textDocument/implementation` request.
  #
  # @return [ImplementationClientCapabilities]
  def implementation; end

  # Capabilities specific to the `textDocument/linkedEditingRange` request.
  #
  # @return [LinkedEditingRangeClientCapabilities]
  def linked_editing_range; end

  # Capabilities specific to the `textDocument/moniker` request.
  #
  # @return [MonikerClientCapabilities]
  def moniker; end

  # request.
  # Capabilities specific to the `textDocument/onTypeFormatting` request.
  #
  # @return [DocumentOnTypeFormattingClientCapabilities]
  def on_type_formatting; end

  # Capabilities specific to the `textDocument/publishDiagnostics`
  # notification.
  #
  # @return [PublishDiagnosticsClientCapabilities]
  def publish_diagnostics; end

  # Capabilities specific to the `textDocument/rangeFormatting` request.
  #
  # @return [DocumentRangeFormattingClientCapabilities]
  def range_formatting; end

  # Capabilities specific to the `textDocument/references` request.
  #
  # @return [ReferenceClientCapabilities]
  def references; end

  # Capabilities specific to the `textDocument/rename` request.
  #
  # @return [RenameClientCapabilities]
  def rename; end

  # Capabilities specific to the `textDocument/selectionRange` request.
  #
  # @return [SelectionRangeClientCapabilities]
  def selection_range; end

  # Capabilities specific to the various semantic token requests.
  #
  # @return [SemanticTokensClientCapabilities]
  def semantic_tokens; end

  # Capabilities specific to the `textDocument/signatureHelp` request.
  #
  # @return [SignatureHelpClientCapabilities]
  def signature_help; end

  # @return [TextDocumentSyncClientCapabilities]
  def synchronization; end

  def to_hash; end
  def to_json(*args); end

  # Capabilities specific to the `textDocument/typeDefinition` request.
  #
  # @return [TypeDefinitionClientCapabilities]
  def type_definition; end
end

# An event describing a change to a text document. If range and rangeLength are
# omitted the new text is considered to be the full content of the document.
class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
  # @return [TextDocumentContentChangeEvent] a new instance of TextDocumentContentChangeEvent
  def initialize(text:, range: T.unsafe(nil), range_length: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The range of the document that changed.
  #
  # @return [Range, nil]
  def range; end

  # The optional length of the range that got replaced.
  #
  # @return [number, nil]
  def range_length; end

  # The new text for the provided range.
  #
  # --- OR ---
  #
  # The new text of the whole document.
  #
  # @return [string]
  def text; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
  # @return [TextDocumentEdit] a new instance of TextDocumentEdit
  def initialize(text_document:, edits:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The edits to be applied.
  #
  # @return [(TextEdit | AnnotatedTextEdit)[]]
  def edits; end

  # The text document to change.
  #
  # @return [OptionalVersionedTextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
  # @return [TextDocumentIdentifier] a new instance of TextDocumentIdentifier
  def initialize(uri:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The text document's URI.
  #
  # @return [string]
  def uri; end
end

class LanguageServer::Protocol::Interface::TextDocumentItem
  # @return [TextDocumentItem] a new instance of TextDocumentItem
  def initialize(uri:, language_id:, version:, text:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The text document's language identifier.
  #
  # @return [string]
  def language_id; end

  # The content of the opened text document.
  #
  # @return [string]
  def text; end

  def to_hash; end
  def to_json(*args); end

  # The text document's URI.
  #
  # @return [string]
  def uri; end

  # The version number of this document (it will increase after each
  # change, including undo/redo).
  #
  # @return [number]
  def version; end
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
  # @return [TextDocumentPositionParams] a new instance of TextDocumentPositionParams
  def initialize(text_document:, position:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

# General text document registration options.
class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
  # @return [TextDocumentRegistrationOptions] a new instance of TextDocumentRegistrationOptions
  def initialize(document_selector:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
  # @return [TextDocumentSaveRegistrationOptions] a new instance of TextDocumentSaveRegistrationOptions
  def initialize(document_selector:, include_text: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The client is supposed to include the content on save.
  #
  # @return [boolean]
  def include_text; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
  # @return [TextDocumentSyncClientCapabilities] a new instance of TextDocumentSyncClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), did_save: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The client supports did save notifications.
  #
  # @return [boolean]
  def did_save; end

  # Whether text document synchronization supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  def to_hash; end
  def to_json(*args); end

  # The client supports sending will save notifications.
  #
  # @return [boolean]
  def will_save; end

  # The client supports sending a will save request and
  # waits for a response providing text edits which will
  # be applied to the document before it is saved.
  #
  # @return [boolean]
  def will_save_wait_until; end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
  # @return [TextDocumentSyncOptions] a new instance of TextDocumentSyncOptions
  def initialize(open_close: T.unsafe(nil), change: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), save: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Change notifications are sent to the server. See
  # TextDocumentSyncKind.None, TextDocumentSyncKind.Full and
  # TextDocumentSyncKind.Incremental. If omitted it defaults to
  # TextDocumentSyncKind.None.
  #
  # @return [TextDocumentSyncKind]
  def change; end

  # Open and close notifications are sent to the server. If omitted open
  # close notification should not be sent.
  #
  # @return [boolean]
  def open_close; end

  # If present save notifications are sent to the server. If omitted the
  # notification should not be sent.
  #
  # @return [boolean | SaveOptions]
  def save; end

  def to_hash; end
  def to_json(*args); end

  # If present will save notifications are sent to the server. If omitted
  # the notification should not be sent.
  #
  # @return [boolean]
  def will_save; end

  # If present will save wait until requests are sent to the server. If
  # omitted the request should not be sent.
  #
  # @return [boolean]
  def will_save_wait_until; end
end

class LanguageServer::Protocol::Interface::TextEdit
  # @return [TextEdit] a new instance of TextEdit
  def initialize(range:, new_text:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The string to be inserted. For delete operations use an
  # empty string.
  #
  # @return [string]
  def new_text; end

  # The range of the text document to be manipulated. To insert
  # text into a document create a range where start === end.
  #
  # @return [Range]
  def range; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
  # @return [TypeDefinitionClientCapabilities] a new instance of TypeDefinitionClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether implementation supports dynamic registration. If this is set to
  # `true` the client supports the new `TypeDefinitionRegistrationOptions`
  # return value for the corresponding server capability as well.
  #
  # @return [boolean]
  def dynamic_registration; end

  # The client supports additional metadata in the form of definition links.
  #
  # @return [boolean]
  def link_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
  # @return [TypeDefinitionOptions] a new instance of TypeDefinitionOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
  # @return [TypeDefinitionParams] a new instance of TypeDefinitionParams
  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # The position inside the text document.
  #
  # @return [Position]
  def position; end

  # The text document.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
  # @return [TypeDefinitionRegistrationOptions] a new instance of TypeDefinitionRegistrationOptions
  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A document selector to identify the scope of the registration. If set to
  # null the document selector provided on the client side will be used.
  #
  # @return [DocumentSelector]
  def document_selector; end

  # The id used to register the request. The id can be used to deregister
  # the request again. See also Registration#id.
  #
  # @return [string]
  def id; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# General parameters to unregister a capability.
class LanguageServer::Protocol::Interface::Unregistration
  # @return [Unregistration] a new instance of Unregistration
  def initialize(id:, method:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The id used to unregister the request or notification. Usually an id
  # provided during the register request.
  #
  # @return [string]
  def id; end

  # The method / capability to unregister for.
  #
  # @return [string]
  def method; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::UnregistrationParams
  # @return [UnregistrationParams] a new instance of UnregistrationParams
  def initialize(unregisterations:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [Unregistration[]]
  def unregisterations; end
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
  # @return [VersionedTextDocumentIdentifier] a new instance of VersionedTextDocumentIdentifier
  def initialize(uri:, version:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The text document's URI.
  #
  # @return [string]
  def uri; end

  # The version number of this document.
  #
  # The version number of a document will increase after each change,
  # including undo/redo. The number doesn't need to be consecutive.
  #
  # @return [number]
  def version; end
end

# The parameters send in a will save text document notification.
class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
  # @return [WillSaveTextDocumentParams] a new instance of WillSaveTextDocumentParams
  def initialize(text_document:, reason:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The 'TextDocumentSaveReason'.
  #
  # @return [TextDocumentSaveReason]
  def reason; end

  # The document that will be saved.
  #
  # @return [TextDocumentIdentifier]
  def text_document; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
  # @return [WorkDoneProgressBegin] a new instance of WorkDoneProgressBegin
  def initialize(kind:, title:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Controls if a cancel button should show to allow the user to cancel the
  # long running operation. Clients that don't support cancellation are
  # allowed to ignore the setting.
  #
  # @return [boolean]
  def cancellable; end

  # @return ["begin"]
  def kind; end

  # Optional, more detailed associated progress message. Contains
  # complementary information to the `title`.
  #
  # Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
  # If unset, the previous progress message (if any) is still valid.
  #
  # @return [string]
  def message; end

  # Optional progress percentage to display (value 100 is considered 100%).
  # If not provided infinite progress is assumed and clients are allowed
  # to ignore the `percentage` value in subsequent in report notifications.
  #
  # The value should be steadily rising. Clients are free to ignore values
  # that are not following this rule. The value range is [0, 100]
  #
  # @return [number]
  def percentage; end

  # Mandatory title of the progress operation. Used to briefly inform about
  # the kind of operation being performed.
  #
  # Examples: "Indexing" or "Linking dependencies".
  #
  # @return [string]
  def title; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
  # @return [WorkDoneProgressCancelParams] a new instance of WorkDoneProgressCancelParams
  def initialize(token:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The token to be used to report progress.
  #
  # @return [ProgressToken]
  def token; end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
  # @return [WorkDoneProgressCreateParams] a new instance of WorkDoneProgressCreateParams
  def initialize(token:); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # The token to be used to report progress.
  #
  # @return [ProgressToken]
  def token; end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
  # @return [WorkDoneProgressEnd] a new instance of WorkDoneProgressEnd
  def initialize(kind:, message: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @return ["end"]
  def kind; end

  # Optional, a final message indicating to for example indicate the outcome
  # of the operation.
  #
  # @return [string]
  def message; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
  # @return [WorkDoneProgressOptions] a new instance of WorkDoneProgressOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
  # @return [WorkDoneProgressParams] a new instance of WorkDoneProgressParams
  def initialize(work_done_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
  # @return [WorkDoneProgressReport] a new instance of WorkDoneProgressReport
  def initialize(kind:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Controls enablement state of a cancel button. This property is only valid
  # if a cancel button got requested in the `WorkDoneProgressStart` payload.
  #
  # Clients that don't support cancellation or don't support control the
  # button's enablement state are allowed to ignore the setting.
  #
  # @return [boolean]
  def cancellable; end

  # @return ["report"]
  def kind; end

  # Optional, more detailed associated progress message. Contains
  # complementary information to the `title`.
  #
  # Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
  # If unset, the previous progress message (if any) is still valid.
  #
  # @return [string]
  def message; end

  # Optional progress percentage to display (value 100 is considered 100%).
  # If not provided infinite progress is assumed and clients are allowed
  # to ignore the `percentage` value in subsequent in report notifications.
  #
  # The value should be steadily rising. Clients are free to ignore values
  # that are not following this rule. The value range is [0, 100]
  #
  # @return [number]
  def percentage; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
  # @return [WorkspaceEdit] a new instance of WorkspaceEdit
  def initialize(changes: T.unsafe(nil), document_changes: T.unsafe(nil), change_annotations: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # A map of change annotations that can be referenced in
  # `AnnotatedTextEdit`s or create, rename and delete file / folder
  # operations.
  #
  # Whether clients honor this property depends on the client capability
  # `workspace.changeAnnotationSupport`.
  #
  # @return [{ [id: string]: ChangeAnnotation; }]
  def change_annotations; end

  # Holds changes to existing resources.
  #
  # @return [{}]
  def changes; end

  # Depending on the client capability
  # `workspace.workspaceEdit.resourceOperations` document changes are either
  # an array of `TextDocumentEdit`s to express changes to n different text
  # documents where each text document edit addresses a specific version of
  # a text document. Or it can contain above `TextDocumentEdit`s mixed with
  # create, rename and delete file / folder operations.
  #
  # Whether a client supports versioned document edits is expressed via
  # `workspace.workspaceEdit.documentChanges` client capability.
  #
  # If a client neither supports `documentChanges` nor
  # `workspace.workspaceEdit.resourceOperations` then only plain `TextEdit`s
  # using the `changes` property are supported.
  #
  # @return [TextDocumentEdit[] | (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[]]
  def document_changes; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
  # @return [WorkspaceEditClientCapabilities] a new instance of WorkspaceEditClientCapabilities
  def initialize(document_changes: T.unsafe(nil), resource_operations: T.unsafe(nil), failure_handling: T.unsafe(nil), normalizes_line_endings: T.unsafe(nil), change_annotation_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether the client in general supports change annotations on text edits,
  # create file, rename file and delete file changes.
  #
  # @return [{ groupsOnLabel?: boolean; }]
  def change_annotation_support; end

  # The client supports versioned document changes in `WorkspaceEdit`s
  #
  # @return [boolean]
  def document_changes; end

  # The failure handling strategy of a client if applying the workspace edit
  # fails.
  #
  # @return [FailureHandlingKind]
  def failure_handling; end

  # Whether the client normalizes line endings to the client specific
  # setting.
  # If set to `true` the client will normalize line ending characters
  # in a workspace edit to the client specific new line character(s).
  #
  # @return [boolean]
  def normalizes_line_endings; end

  # The resource operations the client supports. Clients should at least
  # support 'create', 'rename' and 'delete' files and folders.
  #
  # @return [ResourceOperationKind[]]
  def resource_operations; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
  # @return [WorkspaceFolder] a new instance of WorkspaceFolder
  def initialize(uri:, name:); end

  # Returns the value of attribute attributes.
  def attributes; end

  # The name of the workspace folder. Used to refer to this
  # workspace folder in the user interface.
  #
  # @return [string]
  def name; end

  def to_hash; end
  def to_json(*args); end

  # The associated URI for this workspace folder.
  #
  # @return [string]
  def uri; end
end

# The workspace folder change event.
class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
  # @return [WorkspaceFoldersChangeEvent] a new instance of WorkspaceFoldersChangeEvent
  def initialize(added:, removed:); end

  # The array of added workspace folders
  #
  # @return [WorkspaceFolder[]]
  def added; end

  # Returns the value of attribute attributes.
  def attributes; end

  # The array of the removed workspace folders
  #
  # @return [WorkspaceFolder[]]
  def removed; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
  # @return [WorkspaceFoldersServerCapabilities] a new instance of WorkspaceFoldersServerCapabilities
  def initialize(supported: T.unsafe(nil), change_notifications: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Whether the server wants to receive workspace folder
  # change notifications.
  #
  # If a string is provided, the string is treated as an ID
  # under which the notification is registered on the client
  # side. The ID can be used to unregister for these events
  # using the `client/unregisterCapability` request.
  #
  # @return [string | boolean]
  def change_notifications; end

  # The server has support for workspace folders
  #
  # @return [boolean]
  def supported; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
  # @return [WorkspaceSymbolClientCapabilities] a new instance of WorkspaceSymbolClientCapabilities
  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), tag_support: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Symbol request supports dynamic registration.
  #
  # @return [boolean]
  def dynamic_registration; end

  # Specific capabilities for the `SymbolKind` in the `workspace/symbol`
  # request.
  #
  # @return [{ valueSet?: any[]; }]
  def symbol_kind; end

  # The client supports tags on `SymbolInformation`.
  # Clients supporting tags have to handle unknown tags gracefully.
  #
  # @return [{ valueSet: 1[]; }]
  def tag_support; end

  def to_hash; end
  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
  # @return [WorkspaceSymbolOptions] a new instance of WorkspaceSymbolOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

# The parameters of a Workspace Symbol Request.
class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
  # @return [WorkspaceSymbolParams] a new instance of WorkspaceSymbolParams
  def initialize(query:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  # An optional token that a server can use to report partial results (e.g.
  # streaming) to the client.
  #
  # @return [ProgressToken]
  def partial_result_token; end

  # A query string to filter symbols by. Clients may send an empty
  # string here to request all symbols.
  #
  # @return [string]
  def query; end

  def to_hash; end
  def to_json(*args); end

  # An optional token that a server can use to report work done progress.
  #
  # @return [ProgressToken]
  def work_done_token; end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
  # @return [WorkspaceSymbolRegistrationOptions] a new instance of WorkspaceSymbolRegistrationOptions
  def initialize(work_done_progress: T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def to_hash; end
  def to_json(*args); end

  # @return [boolean]
  def work_done_progress; end
end

module LanguageServer::Protocol::Transport; end
module LanguageServer::Protocol::Transport::Io; end

class LanguageServer::Protocol::Transport::Io::Reader
  # @return [Reader] a new instance of Reader
  def initialize(io); end

  def read(&block); end

  private

  # Returns the value of attribute io.
  def io; end
end

class LanguageServer::Protocol::Transport::Io::Writer
  # @return [Writer] a new instance of Writer
  def initialize(io); end

  # Returns the value of attribute io.
  def io; end

  def write(response); end
end

module LanguageServer::Protocol::Transport::Stdio; end

class LanguageServer::Protocol::Transport::Stdio::Reader < ::LanguageServer::Protocol::Transport::Io::Reader
  # @return [Reader] a new instance of Reader
  def initialize; end
end

class LanguageServer::Protocol::Transport::Stdio::Writer < ::LanguageServer::Protocol::Transport::Io::Writer
  # @return [Writer] a new instance of Writer
  def initialize; end
end

LanguageServer::Protocol::VERSION = T.let(T.unsafe(nil), String)
