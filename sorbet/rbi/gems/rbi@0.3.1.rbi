# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbi` gem.
# Please instead update this file by running `bin/tapioca gem rbi`.


# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbi` gem.
# Please instead update this file by running `spoom srb sigs export`.

# source://rbi//lib/rbi.rb#8
module RBI; end

# source://rbi//lib/rbi/model.rb#802
class RBI::Arg < ::RBI::Node
  # : (String value, ?loc: Loc?) -> void
  #
  # @return [Arg] a new instance of Arg
  #
  # source://rbi//lib/rbi/model.rb#807
  sig { params(value: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(value, loc: T.unsafe(nil)); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#813
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#818
  sig { returns(::String) }
  def to_s; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#804
  sig { returns(::String) }
  def value; end
end

# Attributes
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#298
class RBI::Attr < ::RBI::NodeWithComments
  include ::RBI::Indexable

  abstract!

  # : (Symbol name, Array[Symbol] names, ?visibility: Visibility, ?sigs: Array[Sig], ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [Attr] a new instance of Attr
  #
  # source://rbi//lib/rbi/model.rb#314
  sig do
    params(
      name: ::Symbol,
      names: T::Array[::Symbol],
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#394
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # @abstract
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#58
  sig { abstract.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  # @abstract
  #
  # source://rbi//lib/rbi/model.rb#322
  sig { abstract.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#109
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : (Node other) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#403
  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  # : Array[Symbol]
  #
  # source://rbi//lib/rbi/model.rb#305
  sig { returns(T::Array[::Symbol]) }
  def names; end

  # : Array[Sig]
  #
  # source://rbi//lib/rbi/model.rb#311
  sig { returns(T::Array[::RBI::Sig]) }
  def sigs; end

  # : Visibility
  #
  # source://rbi//lib/rbi/model.rb#308
  sig { returns(::RBI::Visibility) }
  def visibility; end

  # : Visibility
  #
  # source://rbi//lib/rbi/model.rb#308
  # @return [Visibility]
  def visibility=(_arg0); end

  private

  # : (String name, Sig? sig, Visibility visibility, Loc? loc, Array[Comment] comments) -> Method
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#79
  sig do
    params(
      name: ::String,
      sig: T.nilable(::RBI::Sig),
      visibility: ::RBI::Visibility,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).returns(::RBI::Method)
  end
  def create_getter_method(name, sig, visibility, loc, comments); end

  # : (String name, Sig? sig, (Type | String)? attribute_type, Visibility visibility, Loc? loc, Array[Comment] comments) -> Method
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#91
  sig do
    params(
      name: ::String,
      sig: T.nilable(::RBI::Sig),
      attribute_type: T.nilable(T.any(::RBI::Type, ::String)),
      visibility: ::RBI::Visibility,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).returns(::RBI::Method)
  end
  def create_setter_method(name, sig, attribute_type, visibility, loc, comments); end

  # : -> [Sig?, (Type | String)?]
  #
  # @raise [UnexpectedMultipleSigsError]
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#64
  sig(:final) { returns([T.nilable(::RBI::Sig), T.nilable(T.any(::RBI::Type, ::String))]) }
  def parse_sig; end
end

# source://rbi//lib/rbi/model.rb#325
class RBI::AttrAccessor < ::RBI::Attr
  # : (Symbol name, *Symbol names, ?visibility: Visibility, ?sigs: Array[Sig], ?loc: Loc?, ?comments: Array[Comment]) ?{ (AttrAccessor node) -> void } -> void
  #
  # @return [AttrAccessor] a new instance of AttrAccessor
  #
  # source://rbi//lib/rbi/model.rb#327
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrAccessor).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#432
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[Method]
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#122
  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#334
  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#341
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#347
class RBI::AttrReader < ::RBI::Attr
  # : (Symbol name, *Symbol names, ?visibility: Visibility, ?sigs: Array[Sig], ?loc: Loc?, ?comments: Array[Comment]) ?{ (AttrReader node) -> void } -> void
  #
  # @return [AttrReader] a new instance of AttrReader
  #
  # source://rbi//lib/rbi/model.rb#349
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrReader).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#416
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[Method]
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#137
  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#356
  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#363
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#369
class RBI::AttrWriter < ::RBI::Attr
  # : (Symbol name, *Symbol names, ?visibility: Visibility, ?sigs: Array[Sig], ?loc: Loc?, ?comments: Array[Comment]) ?{ (AttrWriter node) -> void } -> void
  #
  # @return [AttrWriter] a new instance of AttrWriter
  #
  # source://rbi//lib/rbi/model.rb#371
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrWriter).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#424
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[Method]
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#147
  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#378
  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#385
  sig { override.returns(::String) }
  def to_s; end
end

# An arbitrary blank line that can be added both in trees and comments
#
# source://rbi//lib/rbi/model.rb#73
class RBI::BlankLine < ::RBI::Comment
  # : (?loc: Loc?) -> void
  #
  # @return [BlankLine] a new instance of BlankLine
  #
  # source://rbi//lib/rbi/model.rb#75
  sig { params(loc: T.nilable(::RBI::Loc)).void }
  def initialize(loc: T.unsafe(nil)); end
end

# source://rbi//lib/rbi/model.rb#642
class RBI::BlockParam < ::RBI::Param
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (BlockParam node) -> void } -> void
  #
  # @return [BlockParam] a new instance of BlockParam
  #
  # source://rbi//lib/rbi/model.rb#644
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::BlockParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#656
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#651
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#202
class RBI::Class < ::RBI::Scope
  # : (String name, ?superclass_name: String?, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Class node) -> void } -> void
  #
  # @return [Class] a new instance of Class
  #
  # source://rbi//lib/rbi/model.rb#210
  sig do
    params(
      name: ::String,
      superclass_name: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Class).void)
    ).void
  end
  def initialize(name, superclass_name: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#362
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#219
  sig { override.returns(::String) }
  def fully_qualified_name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#204
  sig { returns(::String) }
  def name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#204
  # @return [String]
  def name=(_arg0); end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#207
  sig { returns(T.nilable(::String)) }
  def superclass_name; end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#207
  # @return [String, nil]
  def superclass_name=(_arg0); end
end

# source://rbi//lib/rbi/model.rb#54
class RBI::Comment < ::RBI::Node
  # : (String text, ?loc: Loc?) -> void
  #
  # @return [Comment] a new instance of Comment
  #
  # source://rbi//lib/rbi/model.rb#59
  sig { params(text: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(text, loc: T.unsafe(nil)); end

  # : (Object other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#65
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#56
  sig { returns(::String) }
  def text; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#56
  # @return [String]
  def text=(_arg0); end
end

# A tree showing incompatibles nodes
#
# Is rendered as a merge conflict between `left` and` right`:
# ~~~rb
# class Foo
#   <<<<<<< left
#   def m1; end
#   def m2(a); end
#   =======
#   def m1(a); end
#   def m2; end
#   >>>>>>> right
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#546
# A tree showing incompatibles nodes
# Is rendered as a merge conflict between `left` and` right`:
# ~~~rb
# class Foo
#   <<<<<<< left
#   def m1; end
#   def m2(a); end
#   =======
#   def m1(a); end
#   def m2; end
#   >>>>>>> right
# end
class RBI::ConflictTree < ::RBI::Tree
  # : (?left_name: String, ?right_name: String) -> void
  #
  # @return [ConflictTree] a new instance of ConflictTree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#554
  sig { params(left_name: ::String, right_name: ::String).void }
  def initialize(left_name: T.unsafe(nil), right_name: T.unsafe(nil)); end

  # : Tree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#548
  sig { returns(::RBI::Tree) }
  def left; end

  # : String
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#551
  sig { returns(::String) }
  def left_name; end

  # : Tree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#548
  # @return [Tree]
  def right; end

  # : String
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#551
  # @return [String]
  def right_name; end
end

# Consts
#
# source://rbi//lib/rbi/model.rb#270
class RBI::Const < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String name, String value, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Const node) -> void } -> void
  #
  # @return [Const] a new instance of Const
  #
  # source://rbi//lib/rbi/model.rb#275
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Const).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#386
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#283
  sig { returns(::String) }
  def fully_qualified_name; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#99
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#272
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#291
  sig { override.returns(::String) }
  def to_s; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#272
  # @return [String]
  def value; end
end

# source://rbi//lib/rbi/rewriters/merge_trees.rb#332
class RBI::DuplicateNodeError < ::RBI::Error; end

# source://rbi//lib/rbi.rb#9
class RBI::Error < ::StandardError; end

# source://rbi//lib/rbi/model.rb#692
class RBI::Extend < ::RBI::Mixin
  include ::RBI::Indexable

  # : (String name, *String names, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Extend node) -> void } -> void
  #
  # @return [Extend] a new instance of Extend
  #
  # source://rbi//lib/rbi/model.rb#694
  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Extend).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#479
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#139
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#701
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#135
class RBI::File
  # : (?strictness: String?, ?comments: Array[Comment]) ?{ (File file) -> void } -> void
  #
  # @return [File] a new instance of File
  #
  # source://rbi//lib/rbi/model.rb#146
  sig do
    params(
      strictness: T.nilable(::String),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(file: ::RBI::File).void)
    ).void
  end
  def initialize(strictness: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/model.rb#154
  sig { params(node: ::RBI::Node).void }
  def <<(node); end

  # : Array[Comment]
  #
  # source://rbi//lib/rbi/model.rb#143
  sig { returns(T::Array[::RBI::Comment]) }
  def comments; end

  # : Array[Comment]
  #
  # source://rbi//lib/rbi/model.rb#143
  # @return [Array<Comment>]
  def comments=(_arg0); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/model.rb#159
  sig { returns(T::Boolean) }
  def empty?; end

  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool, ?max_line_length: Integer?) -> void
  #
  # source://rbi//lib/rbi/printer.rb#794
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1106
  sig { params(out: T.any(::IO, ::StringIO), indent: ::Integer, print_locs: T::Boolean).void }
  def rbs_print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil)); end

  # : (?indent: Integer, ?print_locs: bool) -> String
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1112
  sig { params(indent: ::Integer, print_locs: T::Boolean).returns(::String) }
  def rbs_string(indent: T.unsafe(nil), print_locs: T.unsafe(nil)); end

  # : Tree
  #
  # source://rbi//lib/rbi/model.rb#137
  sig { returns(::RBI::Tree) }
  def root; end

  # : Tree
  #
  # source://rbi//lib/rbi/model.rb#137
  # @return [Tree]
  def root=(_arg0); end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#140
  sig { returns(T.nilable(::String)) }
  def strictness; end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#140
  # @return [String, nil]
  def strictness=(_arg0); end

  # : (?indent: Integer, ?print_locs: bool, ?max_line_length: Integer?) -> String
  #
  # source://rbi//lib/rbi/printer.rb#800
  sig { params(indent: ::Integer, print_locs: T::Boolean, max_line_length: T.nilable(::Integer)).returns(::String) }
  def string(indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end
end

# source://rbi//lib/rbi/formatter.rb#5
class RBI::Formatter
  # : (?add_sig_templates: bool, ?group_nodes: bool, ?max_line_length: Integer?, ?nest_singleton_methods: bool, ?nest_non_public_members: bool, ?sort_nodes: bool) -> void
  #
  # @return [Formatter] a new instance of Formatter
  #
  # source://rbi//lib/rbi/formatter.rb#10
  sig do
    params(
      add_sig_templates: T::Boolean,
      group_nodes: T::Boolean,
      max_line_length: T.nilable(::Integer),
      nest_singleton_methods: T::Boolean,
      nest_non_public_members: T::Boolean,
      sort_nodes: T::Boolean
    ).void
  end
  def initialize(add_sig_templates: T.unsafe(nil), group_nodes: T.unsafe(nil), max_line_length: T.unsafe(nil), nest_singleton_methods: T.unsafe(nil), nest_non_public_members: T.unsafe(nil), sort_nodes: T.unsafe(nil)); end

  # : (RBI::File file) -> void
  #
  # source://rbi//lib/rbi/formatter.rb#33
  sig { params(file: ::RBI::File).void }
  def format_file(file); end

  # : (RBI::Tree tree) -> void
  #
  # source://rbi//lib/rbi/formatter.rb#38
  sig { params(tree: ::RBI::Tree).void }
  def format_tree(tree); end

  # : Integer?
  #
  # source://rbi//lib/rbi/formatter.rb#7
  sig { returns(T.nilable(::Integer)) }
  def max_line_length; end

  # : Integer?
  #
  # source://rbi//lib/rbi/formatter.rb#7
  # @return [Integer, nil]
  def max_line_length=(_arg0); end

  # : (RBI::File file) -> String
  #
  # source://rbi//lib/rbi/formatter.rb#27
  sig { params(file: ::RBI::File).returns(::String) }
  def print_file(file); end
end

# source://rbi//lib/rbi/rewriters/group_nodes.rb#84
class RBI::Group < ::RBI::Tree
  # : (Kind kind) -> void
  #
  # @return [Group] a new instance of Group
  #
  # source://rbi//lib/rbi/rewriters/group_nodes.rb#89
  sig { params(kind: ::RBI::Group::Kind).void }
  def initialize(kind); end

  # : Kind
  #
  # source://rbi//lib/rbi/rewriters/group_nodes.rb#86
  sig { returns(::RBI::Group::Kind) }
  def kind; end
end

# source://rbi//lib/rbi/rewriters/group_nodes.rb#94
class RBI::Group::Kind < ::T::Enum
  enums do
    Attrs = new
    Consts = new
    Helpers = new
    Inits = new
    Methods = new
    MixesInClassMethods = new
    Mixins = new
    RequiredAncestors = new
    Sends = new
    SingletonClasses = new
    TEnums = new
    TStructFields = new
    TypeMembers = new
  end
end

# source://rbi//lib/rbi/rewriters/group_nodes.rb#5
class RBI::GroupNodesError < ::RBI::Error; end

# Sorbet's misc.
#
# source://rbi//lib/rbi/model.rb#1042
class RBI::Helper < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Helper node) -> void } -> void
  #
  # @return [Helper] a new instance of Helper
  #
  # source://rbi//lib/rbi/model.rb#1047
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Helper).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#495
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#169
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#1044
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1055
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#678
class RBI::Include < ::RBI::Mixin
  include ::RBI::Indexable

  # : (String name, *String names, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Include node) -> void } -> void
  #
  # @return [Include] a new instance of Include
  #
  # source://rbi//lib/rbi/model.rb#680
  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Include).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#471
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#129
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#687
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/index.rb#5
class RBI::Index < ::RBI::Visitor
  # : -> void
  #
  # @return [Index] a new instance of Index
  #
  # source://rbi//lib/rbi/index.rb#18
  sig { void }
  def initialize; end

  # : (String id) -> Array[Node]
  #
  # source://rbi//lib/rbi/index.rb#29
  sig { params(id: ::String).returns(T::Array[::RBI::Node]) }
  def [](id); end

  # : (*Node nodes) -> void
  #
  # source://rbi//lib/rbi/index.rb#34
  sig { params(nodes: ::RBI::Node).void }
  def index(*nodes); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#24
  sig { returns(T::Array[::String]) }
  def keys; end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/index.rb#40
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : ((Indexable & Node) node) -> void
  #
  # source://rbi//lib/rbi/index.rb#57
  sig { params(node: T.all(::RBI::Indexable, ::RBI::Node)).void }
  def index_node(node); end

  class << self
    # : (*Node node) -> Index
    #
    # source://rbi//lib/rbi/index.rb#10
    sig { params(node: ::RBI::Node).returns(::RBI::Index) }
    def index(*node); end
  end
end

# A Node that can be referred to by a unique ID inside an index
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/index.rb#70
module RBI::Indexable
  interface!

  # Unique IDs that refer to this node.
  #
  # Some nodes can have multiple ids, for example an attribute accessor matches the ID of the
  # getter and the setter.
  #
  # @abstract
  #
  # source://rbi//lib/rbi/index.rb#81
  # Unique IDs that refer to this node.
  # Some nodes can have multiple ids, for example an attribute accessor matches the ID of the
  sig { abstract.returns(T::Array[::String]) }
  def index_ids; end
end

# source://rbi//lib/rbi/model.rb#823
class RBI::KwArg < ::RBI::Arg
  # : (String keyword, String value, ?loc: Loc?) -> void
  #
  # @return [KwArg] a new instance of KwArg
  #
  # source://rbi//lib/rbi/model.rb#828
  sig { params(keyword: ::String, value: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(keyword, value, loc: T.unsafe(nil)); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#834
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#825
  sig { returns(::String) }
  def keyword; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#839
  sig { returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#600
class RBI::KwOptParam < ::RBI::Param
  # : (String name, String value, ?loc: Loc?, ?comments: Array[Comment]) ?{ (KwOptParam node) -> void } -> void
  #
  # @return [KwOptParam] a new instance of KwOptParam
  #
  # source://rbi//lib/rbi/model.rb#605
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwOptParam).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#618
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#613
  sig { override.returns(::String) }
  def to_s; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#602
  sig { returns(::String) }
  def value; end
end

# source://rbi//lib/rbi/model.rb#581
class RBI::KwParam < ::RBI::Param
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (KwParam node) -> void } -> void
  #
  # @return [KwParam] a new instance of KwParam
  #
  # source://rbi//lib/rbi/model.rb#583
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#595
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#590
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#623
class RBI::KwRestParam < ::RBI::Param
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (KwRestParam node) -> void } -> void
  #
  # @return [KwRestParam] a new instance of KwRestParam
  #
  # source://rbi//lib/rbi/model.rb#625
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwRestParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#637
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#632
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/loc.rb#5
class RBI::Loc
  # : (?file: String?, ?begin_line: Integer?, ?end_line: Integer?, ?begin_column: Integer?, ?end_column: Integer?) -> void
  #
  # @return [Loc] a new instance of Loc
  #
  # source://rbi//lib/rbi/loc.rb#26
  sig do
    params(
      file: T.nilable(::String),
      begin_line: T.nilable(::Integer),
      end_line: T.nilable(::Integer),
      begin_column: T.nilable(::Integer),
      end_column: T.nilable(::Integer)
    ).void
  end
  def initialize(file: T.unsafe(nil), begin_line: T.unsafe(nil), end_line: T.unsafe(nil), begin_column: T.unsafe(nil), end_column: T.unsafe(nil)); end

  # : Integer?
  #
  # source://rbi//lib/rbi/loc.rb#23
  # @return [Integer, nil]
  def begin_column; end

  # : Integer?
  #
  # source://rbi//lib/rbi/loc.rb#23
  sig { returns(T.nilable(::Integer)) }
  def begin_line; end

  # : Integer?
  #
  # source://rbi//lib/rbi/loc.rb#23
  # @return [Integer, nil]
  def end_column; end

  # : Integer?
  #
  # source://rbi//lib/rbi/loc.rb#23
  # @return [Integer, nil]
  def end_line; end

  # : String?
  #
  # source://rbi//lib/rbi/loc.rb#20
  sig { returns(T.nilable(::String)) }
  def file; end

  # : -> String?
  #
  # source://rbi//lib/rbi/loc.rb#44
  sig { returns(T.nilable(::String)) }
  def source; end

  # : -> String
  #
  # source://rbi//lib/rbi/loc.rb#35
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (String file, Prism::Location prism_location) -> Loc
    #
    # source://rbi//lib/rbi/loc.rb#8
    sig { params(file: ::String, prism_location: ::Prism::Location).returns(::RBI::Loc) }
    def from_prism(file, prism_location); end
  end
end

# A tree that _might_ contain conflicts
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#320
class RBI::MergeTree < ::RBI::Tree
  # : (?loc: Loc?, ?comments: Array[Comment], ?conflicts: Array[Rewriters::Merge::Conflict]) ?{ (Tree node) -> void } -> void
  #
  # @return [MergeTree] a new instance of MergeTree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#325
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      conflicts: T::Array[::RBI::Rewriters::Merge::Conflict],
      block: T.nilable(T.proc.params(node: ::RBI::Tree).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), conflicts: T.unsafe(nil), &block); end

  # : Array[Rewriters::Merge::Conflict]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#322
  sig { returns(T::Array[::RBI::Rewriters::Merge::Conflict]) }
  def conflicts; end
end

# Methods and args
#
# source://rbi//lib/rbi/model.rb#393
class RBI::Method < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String name, ?params: Array[Param], ?is_singleton: bool, ?visibility: Visibility, ?sigs: Array[Sig], ?loc: Loc?, ?comments: Array[Comment]) ?{ (Method node) -> void } -> void
  #
  # @return [Method] a new instance of Method
  #
  # source://rbi//lib/rbi/model.rb#410
  sig do
    params(
      name: ::String,
      params: T::Array[::RBI::Param],
      is_singleton: T::Boolean,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Method).void)
    ).void
  end
  def initialize(name, params: T.unsafe(nil), is_singleton: T.unsafe(nil), visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Param param) -> void
  #
  # source://rbi//lib/rbi/model.rb#430
  sig { params(param: ::RBI::Param).void }
  def <<(param); end

  # : (String name) -> void
  #
  # source://rbi//lib/rbi/model.rb#465
  sig { params(name: ::String).void }
  def add_block_param(name); end

  # : (String name, String default_value) -> void
  #
  # source://rbi//lib/rbi/model.rb#455
  sig { params(name: ::String, default_value: ::String).void }
  def add_kw_opt_param(name, default_value); end

  # : (String name) -> void
  #
  # source://rbi//lib/rbi/model.rb#450
  sig { params(name: ::String).void }
  def add_kw_param(name); end

  # : (String name) -> void
  #
  # source://rbi//lib/rbi/model.rb#460
  sig { params(name: ::String).void }
  def add_kw_rest_param(name); end

  # : (String name, String default_value) -> void
  #
  # source://rbi//lib/rbi/model.rb#440
  sig { params(name: ::String, default_value: ::String).void }
  def add_opt_param(name, default_value); end

  # : (String name) -> void
  #
  # source://rbi//lib/rbi/model.rb#435
  sig { params(name: ::String).void }
  def add_param(name); end

  # : (String name) -> void
  #
  # source://rbi//lib/rbi/model.rb#445
  sig { params(name: ::String).void }
  def add_rest_param(name); end

  # : (?params: Array[SigParam], ?return_type: (String | Type), ?is_abstract: bool, ?is_override: bool, ?is_overridable: bool, ?is_final: bool, ?type_params: Array[String], ?checked: Symbol?) ?{ (Sig node) -> void } -> void
  #
  # source://rbi//lib/rbi/model.rb#470
  sig do
    params(
      params: T::Array[::RBI::SigParam],
      return_type: T.any(::RBI::Type, ::String),
      is_abstract: T::Boolean,
      is_override: T::Boolean,
      is_overridable: T::Boolean,
      is_final: T::Boolean,
      type_params: T::Array[::String],
      checked: T.nilable(::Symbol),
      block: T.nilable(T.proc.params(node: ::RBI::Sig).void)
    ).void
  end
  def add_sig(params: T.unsafe(nil), return_type: T.unsafe(nil), is_abstract: T.unsafe(nil), is_override: T.unsafe(nil), is_overridable: T.unsafe(nil), is_final: T.unsafe(nil), type_params: T.unsafe(nil), checked: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#440
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#496
  sig { returns(::String) }
  def fully_qualified_name; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#119
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#401
  sig { returns(T::Boolean) }
  def is_singleton; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#401
  # @return [Boolean]
  def is_singleton=(_arg0); end

  # : (Node other) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#450
  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#395
  sig { returns(::String) }
  def name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#395
  # @return [String]
  def name=(_arg0); end

  # : Array[Param]
  #
  # source://rbi//lib/rbi/model.rb#398
  sig { returns(T::Array[::RBI::Param]) }
  def params; end

  # : Array[Sig]
  #
  # source://rbi//lib/rbi/model.rb#407
  sig { returns(T::Array[::RBI::Sig]) }
  def sigs; end

  # : Array[Sig]
  #
  # source://rbi//lib/rbi/model.rb#407
  # @return [Array<Sig>]
  def sigs=(_arg0); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#506
  sig { override.returns(::String) }
  def to_s; end

  # : Visibility
  #
  # source://rbi//lib/rbi/model.rb#404
  sig { returns(::RBI::Visibility) }
  def visibility; end

  # : Visibility
  #
  # source://rbi//lib/rbi/model.rb#404
  # @return [Visibility]
  def visibility=(_arg0); end
end

# source://rbi//lib/rbi/model.rb#1086
class RBI::MixesInClassMethods < ::RBI::Mixin
  include ::RBI::Indexable

  # : (String name, *String names, ?loc: Loc?, ?comments: Array[Comment]) ?{ (MixesInClassMethods node) -> void } -> void
  #
  # @return [MixesInClassMethods] a new instance of MixesInClassMethods
  #
  # source://rbi//lib/rbi/model.rb#1088
  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::MixesInClassMethods).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#487
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#149
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1095
  sig { override.returns(::String) }
  def to_s; end
end

# Mixins
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#663
class RBI::Mixin < ::RBI::NodeWithComments
  abstract!

  # : (String name, Array[String] names, ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [Mixin] a new instance of Mixin
  #
  # source://rbi//lib/rbi/model.rb#672
  sig do
    params(
      name: ::String,
      names: T::Array[::String],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, names, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#463
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : Array[String]
  #
  # source://rbi//lib/rbi/model.rb#669
  sig { returns(T::Array[::String]) }
  def names; end
end

# source://rbi//lib/rbi/model.rb#182
class RBI::Module < ::RBI::Scope
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Module node) -> void } -> void
  #
  # @return [Module] a new instance of Module
  #
  # source://rbi//lib/rbi/model.rb#187
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Module).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#370
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#195
  sig { override.returns(::String) }
  def fully_qualified_name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#184
  sig { returns(::String) }
  def name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#184
  # @return [String]
  def name=(_arg0); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#7
class RBI::Node
  abstract!

  # : (?loc: Loc?) -> void
  #
  # @return [Node] a new instance of Node
  #
  # source://rbi//lib/rbi/model.rb#19
  sig { params(loc: T.nilable(::RBI::Loc)).void }
  def initialize(loc: T.unsafe(nil)); end

  # Can `self` and `_other` be merged into a single definition?
  # : (Node _other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#280
  # Can `self` and `_other` be merged into a single definition?
  sig { params(_other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(_other); end

  # : -> void
  #
  # source://rbi//lib/rbi/model.rb#25
  sig { void }
  def detach; end

  # : Loc?
  #
  # source://rbi//lib/rbi/model.rb#16
  sig { returns(T.nilable(::RBI::Loc)) }
  def loc; end

  # : Loc?
  #
  # source://rbi//lib/rbi/model.rb#16
  # @return [Loc, nil]
  def loc=(_arg0); end

  # Merge `self` and `other` into a single definition
  # : (Node other) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#286
  # Merge `self` and `other` into a single definition
  sig { params(other: ::RBI::Node).void }
  def merge_with(other); end

  # : -> ConflictTree?
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#289
  sig { returns(T.nilable(::RBI::ConflictTree)) }
  def parent_conflict_tree; end

  # : -> Scope?
  #
  # source://rbi//lib/rbi/model.rb#47
  sig { returns(T.nilable(::RBI::Scope)) }
  def parent_scope; end

  # : Tree?
  #
  # source://rbi//lib/rbi/model.rb#13
  sig { returns(T.nilable(::RBI::Tree)) }
  def parent_tree; end

  # : Tree?
  #
  # source://rbi//lib/rbi/model.rb#13
  # @return [Tree, nil]
  def parent_tree=(_arg0); end

  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool, ?max_line_length: Integer?) -> void
  #
  # source://rbi//lib/rbi/printer.rb#809
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool, ?positional_names: bool) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1121
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      positional_names: T::Boolean
    ).void
  end
  def rbs_print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), positional_names: T.unsafe(nil)); end

  # : (?indent: Integer, ?print_locs: bool, ?positional_names: bool) -> String
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1127
  sig { params(indent: ::Integer, print_locs: T::Boolean, positional_names: T::Boolean).returns(::String) }
  def rbs_string(indent: T.unsafe(nil), print_locs: T.unsafe(nil), positional_names: T.unsafe(nil)); end

  # : (Node node) -> void
  #
  # @raise [ReplaceNodeError]
  #
  # source://rbi//lib/rbi/model.rb#34
  sig { params(node: ::RBI::Node).void }
  def replace(node); end

  # : (Gem::Version version) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/filter_versions.rb#91
  sig { params(version: ::Gem::Version).returns(T::Boolean) }
  def satisfies_version?(version); end

  # : (?indent: Integer, ?print_locs: bool, ?max_line_length: Integer?) -> String
  #
  # source://rbi//lib/rbi/printer.rb#815
  sig { params(indent: ::Integer, print_locs: T::Boolean, max_line_length: T.nilable(::Integer)).returns(::String) }
  def string(indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#90
class RBI::NodeWithComments < ::RBI::Node
  abstract!

  # : (?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [NodeWithComments] a new instance of NodeWithComments
  #
  # source://rbi//lib/rbi/model.rb#99
  sig { params(loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#105
  sig { returns(T::Array[::String]) }
  def annotations; end

  # : Array[Comment]
  #
  # source://rbi//lib/rbi/model.rb#96
  sig { returns(T::Array[::RBI::Comment]) }
  def comments; end

  # : Array[Comment]
  #
  # source://rbi//lib/rbi/model.rb#96
  # @return [Array<Comment>]
  def comments=(_arg0); end

  # : (Node other) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#303
  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  # : -> Array[Gem::Requirement]
  #
  # source://rbi//lib/rbi/rewriters/filter_versions.rb#101
  sig { returns(T::Array[::Gem::Requirement]) }
  def version_requirements; end
end

# source://rbi//lib/rbi/model.rb#545
class RBI::OptParam < ::RBI::Param
  # : (String name, String value, ?loc: Loc?, ?comments: Array[Comment]) ?{ (OptParam node) -> void } -> void
  #
  # @return [OptParam] a new instance of OptParam
  #
  # source://rbi//lib/rbi/model.rb#550
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::OptParam).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#557
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#547
  sig { returns(::String) }
  def value; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#511
class RBI::Param < ::RBI::NodeWithComments
  abstract!

  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [Param] a new instance of Param
  #
  # source://rbi//lib/rbi/model.rb#520
  sig { params(name: ::String, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#517
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#527
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/parser.rb#7
class RBI::ParseError < ::RBI::Error
  # : (String message, Loc location) -> void
  #
  # @return [ParseError] a new instance of ParseError
  #
  # source://rbi//lib/rbi/parser.rb#12
  sig { params(message: ::String, location: ::RBI::Loc).void }
  def initialize(message, location); end

  # : Loc
  #
  # source://rbi//lib/rbi/parser.rb#9
  sig { returns(::RBI::Loc) }
  def location; end
end

# source://rbi//lib/rbi/parser.rb#49
class RBI::Parser
  # : (String path) -> Tree
  #
  # source://rbi//lib/rbi/parser.rb#80
  sig { params(path: ::String).returns(::RBI::Tree) }
  def parse_file(path); end

  # : (String string) -> Tree
  #
  # source://rbi//lib/rbi/parser.rb#75
  sig { params(string: ::String).returns(::RBI::Tree) }
  def parse_string(string); end

  private

  # : (String source, file: String) -> Tree
  #
  # source://rbi//lib/rbi/parser.rb#87
  sig { params(source: ::String, file: ::String).returns(::RBI::Tree) }
  def parse(source, file:); end

  class << self
    # : (String path) -> Tree
    #
    # source://rbi//lib/rbi/parser.rb#57
    sig { params(path: ::String).returns(::RBI::Tree) }
    def parse_file(path); end

    # : (Array[String] paths) -> Array[Tree]
    #
    # source://rbi//lib/rbi/parser.rb#62
    sig { params(paths: T::Array[::String]).returns(T::Array[::RBI::Tree]) }
    def parse_files(paths); end

    # : (String string) -> Tree
    #
    # source://rbi//lib/rbi/parser.rb#52
    sig { params(string: ::String).returns(::RBI::Tree) }
    def parse_string(string); end

    # : (Array[String] strings) -> Array[Tree]
    #
    # source://rbi//lib/rbi/parser.rb#68
    sig { params(strings: T::Array[::String]).returns(T::Array[::RBI::Tree]) }
    def parse_strings(strings); end
  end
end

# source://rbi//lib/rbi/parser.rb#824
class RBI::Parser::SigBuilder < ::RBI::Parser::Visitor
  # : (String content, file: String) -> void
  #
  # @return [SigBuilder] a new instance of SigBuilder
  #
  # source://rbi//lib/rbi/parser.rb#829
  sig { params(content: ::String, file: ::String).void }
  def initialize(content, file:); end

  # : Sig
  #
  # source://rbi//lib/rbi/parser.rb#826
  sig { returns(::RBI::Sig) }
  def current; end

  # : (Prism::AssocNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#899
  sig { override.params(node: ::Prism::AssocNode).void }
  def visit_assoc_node(node); end

  # : (Prism::CallNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#837
  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end
end

# source://rbi//lib/rbi/parser.rb#143
class RBI::Parser::TreeBuilder < ::RBI::Parser::Visitor
  # : (String source, comments: Array[Prism::Comment], file: String) -> void
  #
  # @return [TreeBuilder] a new instance of TreeBuilder
  #
  # source://rbi//lib/rbi/parser.rb#151
  sig { params(source: ::String, comments: T::Array[::Prism::Comment], file: ::String).void }
  def initialize(source, comments:, file:); end

  # : Prism::Node?
  #
  # source://rbi//lib/rbi/parser.rb#148
  sig { returns(T.nilable(::Prism::Node)) }
  def last_node; end

  # : Tree
  #
  # source://rbi//lib/rbi/parser.rb#145
  sig { returns(::RBI::Tree) }
  def tree; end

  # : (Prism::CallNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#319
  sig { params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end

  # : (Prism::ClassNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#164
  sig { override.params(node: ::Prism::ClassNode).void }
  def visit_class_node(node); end

  # : ((Prism::ConstantWriteNode | Prism::ConstantPathWriteNode) node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#215
  sig { params(node: T.any(::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode)).void }
  def visit_constant_assign(node); end

  # : (Prism::ConstantPathWriteNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#208
  sig { override.params(node: ::Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # : (Prism::ConstantWriteNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#200
  sig { override.params(node: ::Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # : (Prism::DefNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#249
  sig { override.params(node: ::Prism::DefNode).void }
  def visit_def_node(node); end

  # : (Prism::ModuleNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#271
  sig { override.params(node: ::Prism::ModuleNode).void }
  def visit_module_node(node); end

  # : (Prism::ProgramNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#290
  sig { override.params(node: ::Prism::ProgramNode).void }
  def visit_program_node(node); end

  # : (Prism::SingletonClassNode node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#302
  sig { override.params(node: ::Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  private

  # Collect all the remaining comments within a node
  # : (Prism::Node node) -> void
  #
  # source://rbi//lib/rbi/parser.rb#493
  # Collect all the remaining comments within a node
  sig { params(node: ::Prism::Node).void }
  def collect_dangling_comments(node); end

  # Collect all the remaining comments after visiting the tree
  # : -> void
  #
  # source://rbi//lib/rbi/parser.rb#511
  # Collect all the remaining comments after visiting the tree
  sig { void }
  def collect_orphan_comments; end

  # : -> Tree
  #
  # source://rbi//lib/rbi/parser.rb#534
  sig { returns(::RBI::Tree) }
  def current_scope; end

  # : -> Array[Sig]
  #
  # source://rbi//lib/rbi/parser.rb#539
  sig { returns(T::Array[::RBI::Sig]) }
  def current_sigs; end

  # : (Array[Sig] sigs) -> Array[Comment]
  #
  # source://rbi//lib/rbi/parser.rb#546
  sig { params(sigs: T::Array[::RBI::Sig]).returns(T::Array[::RBI::Comment]) }
  def detach_comments_from_sigs(sigs); end

  # : (Prism::Node node) -> Array[Comment]
  #
  # source://rbi//lib/rbi/parser.rb#558
  sig { params(node: ::Prism::Node).returns(T::Array[::RBI::Comment]) }
  def node_comments(node); end

  # : (Prism::Comment node) -> Comment
  #
  # source://rbi//lib/rbi/parser.rb#576
  sig { params(node: ::Prism::Comment).returns(::RBI::Comment) }
  def parse_comment(node); end

  # : (Prism::Node? node) -> Array[Param]
  #
  # source://rbi//lib/rbi/parser.rb#613
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Array[::RBI::Param]) }
  def parse_params(node); end

  # : (Prism::Node? node) -> Array[Arg]
  #
  # source://rbi//lib/rbi/parser.rb#589
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Array[::RBI::Arg]) }
  def parse_send_args(node); end

  # : (Prism::CallNode node) -> Sig
  #
  # source://rbi//lib/rbi/parser.rb#687
  sig { params(node: ::Prism::CallNode).returns(::RBI::Sig) }
  def parse_sig(node); end

  # : ((Prism::ConstantWriteNode | Prism::ConstantPathWriteNode) node) -> Struct?
  #
  # source://rbi//lib/rbi/parser.rb#696
  sig do
    params(
      node: T.any(::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode)
    ).returns(T.nilable(::RBI::Struct))
  end
  def parse_struct(node); end

  # : (Prism::CallNode send) -> void
  #
  # source://rbi//lib/rbi/parser.rb#744
  sig { params(send: ::Prism::CallNode).void }
  def parse_tstruct_field(send); end

  # : (String name, Prism::Node node) -> Visibility
  #
  # source://rbi//lib/rbi/parser.rb#781
  sig { params(name: ::String, node: ::Prism::Node).returns(::RBI::Visibility) }
  def parse_visibility(name, node); end

  # : -> void
  #
  # source://rbi//lib/rbi/parser.rb#795
  sig { void }
  def separate_header_comments; end

  # : -> void
  #
  # source://rbi//lib/rbi/parser.rb#805
  sig { void }
  def set_root_tree_loc; end

  # : (Prism::Node? node) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/parser.rb#819
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
  def type_variable_definition?(node); end
end

# source://rbi//lib/rbi/parser.rb#114
class RBI::Parser::Visitor < ::Prism::Visitor
  # : (String source, file: String) -> void
  #
  # @return [Visitor] a new instance of Visitor
  #
  # source://rbi//lib/rbi/parser.rb#116
  sig { params(source: ::String, file: ::String).void }
  def initialize(source, file:); end

  private

  # : (Prism::Node node) -> Loc
  #
  # source://rbi//lib/rbi/parser.rb#126
  sig { params(node: ::Prism::Node).returns(::RBI::Loc) }
  def node_loc(node); end

  # : (Prism::Node? node) -> String?
  #
  # source://rbi//lib/rbi/parser.rb#131
  sig { params(node: T.nilable(::Prism::Node)).returns(T.nilable(::String)) }
  def node_string(node); end

  # : (Prism::Node node) -> String
  #
  # source://rbi//lib/rbi/parser.rb#138
  sig { params(node: ::Prism::Node).returns(::String) }
  def node_string!(node); end
end

# source://rbi//lib/rbi/printer.rb#7
class RBI::Printer < ::RBI::Visitor
  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool, ?max_line_length: Integer?) -> void
  #
  # @return [Printer] a new instance of Printer
  #
  # source://rbi//lib/rbi/printer.rb#21
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def initialize(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  # : Integer
  #
  # source://rbi//lib/rbi/printer.rb#15
  sig { returns(::Integer) }
  def current_indent; end

  # : -> void
  #
  # source://rbi//lib/rbi/printer.rb#39
  sig { void }
  def dedent; end

  # : bool
  #
  # source://rbi//lib/rbi/printer.rb#9
  # @return [Boolean]
  def in_visibility_group; end

  # : bool
  #
  # source://rbi//lib/rbi/printer.rb#9
  # @return [Boolean]
  def in_visibility_group=(_arg0); end

  # : -> void
  #
  # source://rbi//lib/rbi/printer.rb#34
  # Printing
  sig { void }
  def indent; end

  # : Integer?
  #
  # source://rbi//lib/rbi/printer.rb#18
  sig { returns(T.nilable(::Integer)) }
  def max_line_length; end

  # : Node?
  #
  # source://rbi//lib/rbi/printer.rb#12
  sig { returns(T.nilable(::RBI::Node)) }
  def previous_node; end

  # Print a string without indentation nor `\n` at the end.
  # : (String string) -> void
  #
  # source://rbi//lib/rbi/printer.rb#45
  # Print a string without indentation nor `\n` at the end.
  sig { params(string: ::String).void }
  def print(string); end

  # : bool
  #
  # source://rbi//lib/rbi/printer.rb#9
  sig { returns(T::Boolean) }
  def print_locs; end

  # : bool
  #
  # source://rbi//lib/rbi/printer.rb#9
  # @return [Boolean]
  def print_locs=(_arg0); end

  # Print a string with indentation and `\n` at the end.
  # : (String string) -> void
  #
  # source://rbi//lib/rbi/printer.rb#65
  # Print a string with indentation and `\n` at the end.
  sig { params(string: ::String).void }
  def printl(string); end

  # Print a string without indentation but with a `\n` at the end.
  # : (?String? string) -> void
  #
  # source://rbi//lib/rbi/printer.rb#51
  # Print a string without indentation but with a `\n` at the end.
  sig { params(string: T.nilable(::String)).void }
  def printn(string = T.unsafe(nil)); end

  # Print a string with indentation but without a `\n` at the end.
  # : (?String? string) -> void
  #
  # source://rbi//lib/rbi/printer.rb#58
  # Print a string with indentation but without a `\n` at the end.
  sig { params(string: T.nilable(::String)).void }
  def printt(string = T.unsafe(nil)); end

  # : (Array[Node] nodes) -> void
  #
  # source://rbi//lib/rbi/printer.rb#72
  sig { override.params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  # : (File file) -> void
  #
  # source://rbi//lib/rbi/printer.rb#84
  sig { override.params(file: ::RBI::File).void }
  def visit_file(file); end

  private

  # : (Node node) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/printer.rb#670
  sig { params(node: ::RBI::Node).returns(T::Boolean) }
  def oneline?(node); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#628
  sig { params(node: ::RBI::Node).void }
  def print_blank_line_before(node); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#638
  sig { params(node: ::RBI::Node).void }
  def print_loc(node); end

  # : (Param node, last: bool) -> void
  #
  # source://rbi//lib/rbi/printer.rb#644
  sig { params(node: ::RBI::Param, last: T::Boolean).void }
  def print_param_comment_leading_space(node, last:); end

  # : (Sig node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#717
  sig { params(node: ::RBI::Sig).void }
  def print_sig_as_block(node); end

  # : (Sig node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#692
  sig { params(node: ::RBI::Sig).void }
  def print_sig_as_line(node); end

  # : (SigParam node, last: bool) -> void
  #
  # source://rbi//lib/rbi/printer.rb#662
  sig { params(node: ::RBI::SigParam, last: T::Boolean).void }
  def print_sig_param_comment_leading_space(node, last:); end

  # : (Sig node) -> Array[String]
  #
  # source://rbi//lib/rbi/printer.rb#773
  sig { params(node: ::RBI::Sig).returns(T::Array[::String]) }
  def sig_modifiers(node); end

  # : (Arg node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#453
  sig { override.params(node: ::RBI::Arg).void }
  def visit_arg(node); end

  # : (Attr node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#258
  sig { params(node: ::RBI::Attr).void }
  def visit_attr(node); end

  # : (AttrAccessor node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#241
  sig { override.params(node: ::RBI::AttrAccessor).void }
  def visit_attr_accessor(node); end

  # : (AttrReader node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#247
  sig { override.params(node: ::RBI::AttrReader).void }
  def visit_attr_reader(node); end

  # : (AttrWriter node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#253
  sig { override.params(node: ::RBI::AttrWriter).void }
  def visit_attr_writer(node); end

  # : (BlankLine node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#138
  sig { override.params(node: ::RBI::BlankLine).void }
  def visit_blank_line(node); end

  # : (BlockParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#373
  sig { override.params(node: ::RBI::BlockParam).void }
  def visit_block_param(node); end

  # : (Class node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#158
  sig { override.params(node: ::RBI::Class).void }
  def visit_class(node); end

  # : (Comment node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#121
  sig { override.params(node: ::RBI::Comment).void }
  def visit_comment(node); end

  # : (ConflictTree node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#604
  sig { override.params(node: ::RBI::ConflictTree).void }
  def visit_conflict_tree(node); end

  # : (Const node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#231
  sig { override.params(node: ::RBI::Const).void }
  def visit_const(node); end

  # : (Extend node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#385
  sig { override.params(node: ::RBI::Extend).void }
  def visit_extend(node); end

  # : (Group node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#573
  sig { override.params(node: ::RBI::Group).void }
  def visit_group(node); end

  # : (Helper node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#557
  sig { override.params(node: ::RBI::Helper).void }
  def visit_helper(node); end

  # : (Include node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#379
  sig { override.params(node: ::RBI::Include).void }
  def visit_include(node); end

  # : (KwArg node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#459
  sig { override.params(node: ::RBI::KwArg).void }
  def visit_kw_arg(node); end

  # : (KwOptParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#361
  sig { override.params(node: ::RBI::KwOptParam).void }
  def visit_kw_opt_param(node); end

  # : (KwParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#355
  sig { override.params(node: ::RBI::KwParam).void }
  def visit_kw_param(node); end

  # : (KwRestParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#367
  sig { override.params(node: ::RBI::KwRestParam).void }
  def visit_kw_rest_param(node); end

  # : (Method node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#287
  sig { override.params(node: ::RBI::Method).void }
  def visit_method(node); end

  # : (MixesInClassMethods node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#567
  sig { override.params(node: ::RBI::MixesInClassMethods).void }
  def visit_mixes_in_class_methods(node); end

  # : (Mixin node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#390
  sig { params(node: ::RBI::Mixin).void }
  def visit_mixin(node); end

  # : (Module node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#152
  sig { override.params(node: ::RBI::Module).void }
  def visit_module(node); end

  # : (OptParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#343
  sig { override.params(node: ::RBI::OptParam).void }
  def visit_opt_param(node); end

  # : (Private node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#420
  sig { override.params(node: ::RBI::Private).void }
  def visit_private(node); end

  # : (Protected node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#414
  sig { override.params(node: ::RBI::Protected).void }
  def visit_protected(node); end

  # : (Public node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#408
  sig { override.params(node: ::RBI::Public).void }
  def visit_public(node); end

  # : (RBSComment node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#104
  sig { override.params(node: ::RBI::RBSComment).void }
  def visit_rbs_comment(node); end

  # : (ReqParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#337
  sig { override.params(node: ::RBI::ReqParam).void }
  def visit_req_param(node); end

  # : (RequiresAncestor node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#594
  sig { override.params(node: ::RBI::RequiresAncestor).void }
  def visit_requires_ancestor(node); end

  # : (RestParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#349
  sig { override.params(node: ::RBI::RestParam).void }
  def visit_rest_param(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#175
  sig { params(node: ::RBI::Scope).void }
  def visit_scope(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#220
  sig { params(node: ::RBI::Scope).void }
  def visit_scope_body(node); end

  # : (ScopeConflict node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#614
  sig { override.params(node: ::RBI::ScopeConflict).void }
  def visit_scope_conflict(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#185
  sig { params(node: ::RBI::Scope).void }
  def visit_scope_header(node); end

  # : (Send node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#435
  sig { override.params(node: ::RBI::Send).void }
  def visit_send(node); end

  # : (Sig node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#465
  sig { override.params(node: ::RBI::Sig).void }
  def visit_sig(node); end

  # : (SigParam node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#486
  sig { override.params(node: ::RBI::SigParam).void }
  def visit_sig_param(node); end

  # : (SingletonClass node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#170
  sig { override.params(node: ::RBI::SingletonClass).void }
  def visit_singleton_class(node); end

  # : (Struct node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#164
  sig { override.params(node: ::RBI::Struct).void }
  def visit_struct(node); end

  # : (TStructField node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#509
  sig { params(node: ::RBI::TStructField).void }
  def visit_t_struct_field(node); end

  # : (TEnum node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#528
  sig { override.params(node: ::RBI::TEnum).void }
  def visit_tenum(node); end

  # : (TEnumBlock node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#534
  sig { override.params(node: ::RBI::TEnumBlock).void }
  def visit_tenum_block(node); end

  # : (Tree node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#144
  sig { override.params(node: ::RBI::Tree).void }
  def visit_tree(node); end

  # : (TStruct node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#492
  sig { override.params(node: ::RBI::TStruct).void }
  def visit_tstruct(node); end

  # : (TStructConst node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#498
  sig { override.params(node: ::RBI::TStructConst).void }
  def visit_tstruct_const(node); end

  # : (TStructProp node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#504
  sig { override.params(node: ::RBI::TStructProp).void }
  def visit_tstruct_prop(node); end

  # : (TypeMember node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#547
  sig { override.params(node: ::RBI::TypeMember).void }
  def visit_type_member(node); end

  # : (Visibility node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#425
  sig { params(node: ::RBI::Visibility).void }
  def visit_visibility(node); end

  # : (VisibilityGroup node) -> void
  #
  # source://rbi//lib/rbi/printer.rb#580
  sig { override.params(node: ::RBI::VisibilityGroup).void }
  def visit_visibility_group(node); end
end

# source://rbi//lib/rbi/printer.rb#5
class RBI::PrinterError < ::RBI::Error; end

# source://rbi//lib/rbi/model.rb#761
class RBI::Private < ::RBI::Visibility
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (Private node) -> void } -> void
  #
  # @return [Private] a new instance of Private
  #
  # source://rbi//lib/rbi/model.rb#763
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Private).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

# source://rbi//lib/rbi/model.rb#753
class RBI::Protected < ::RBI::Visibility
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (Protected node) -> void } -> void
  #
  # @return [Protected] a new instance of Protected
  #
  # source://rbi//lib/rbi/model.rb#755
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Protected).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

# source://rbi//lib/rbi/model.rb#745
class RBI::Public < ::RBI::Visibility
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (Public node) -> void } -> void
  #
  # @return [Public] a new instance of Public
  #
  # source://rbi//lib/rbi/model.rb#747
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Public).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

# source://rbi//lib/rbi/rbs/method_type_translator.rb#5
module RBI::RBS; end

# source://rbi//lib/rbi/rbs/method_type_translator.rb#6
class RBI::RBS::MethodTypeTranslator
  # : (Method) -> void
  #
  # @return [MethodTypeTranslator] a new instance of MethodTypeTranslator
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#22
  sig { params(method: ::RBI::Method).void }
  def initialize(method); end

  # : Sig
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#19
  sig { returns(::RBI::Sig) }
  def result; end

  # : (::RBS::MethodType) -> void
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#28
  sig { params(type: ::RBS::MethodType).void }
  def visit(type); end

  private

  # : (::RBS::Types::Function::Param, Integer) -> SigParam
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#100
  sig { params(param: ::RBS::Types::Function::Param, index: ::Integer).returns(::RBI::SigParam) }
  def translate_function_param(param, index); end

  # : (untyped) -> Type
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#115
  sig { params(type: T.untyped).returns(::RBI::Type) }
  def translate_type(type); end

  # : (::RBS::Types::Block) -> void
  #
  # @raise [Error]
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#42
  sig { params(type: ::RBS::Types::Block).void }
  def visit_block_type(type); end

  # : (::RBS::Types::Function) -> void
  #
  # source://rbi//lib/rbi/rbs/method_type_translator.rb#57
  sig { params(type: ::RBS::Types::Function).void }
  def visit_function_type(type); end

  class << self
    # : (Method, ::RBS::MethodType) -> Sig
    #
    # source://rbi//lib/rbi/rbs/method_type_translator.rb#11
    sig { params(method: ::RBI::Method, type: ::RBS::MethodType).returns(::RBI::Sig) }
    def translate(method, type); end
  end
end

# source://rbi//lib/rbi/rbs/method_type_translator.rb#7
class RBI::RBS::MethodTypeTranslator::Error < ::RBI::Error; end

# source://rbi//lib/rbi/rbs/type_translator.rb#6
class RBI::RBS::TypeTranslator
  class << self
    # : (NodeType) -> Type
    #
    # source://rbi//lib/rbi/rbs/type_translator.rb#37
    sig do
      params(
        type: T.any(::RBS::Types::Alias, ::RBS::Types::Bases::Any, ::RBS::Types::Bases::Bool, ::RBS::Types::Bases::Bottom, ::RBS::Types::Bases::Class, ::RBS::Types::Bases::Instance, ::RBS::Types::Bases::Nil, ::RBS::Types::Bases::Self, ::RBS::Types::Bases::Top, ::RBS::Types::Bases::Void, ::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Function, ::RBS::Types::Interface, ::RBS::Types::Intersection, ::RBS::Types::Literal, ::RBS::Types::Optional, ::RBS::Types::Proc, ::RBS::Types::Record, ::RBS::Types::Tuple, ::RBS::Types::Union, ::RBS::Types::UntypedFunction, ::RBS::Types::Variable)
      ).returns(::RBI::Type)
    end
    def translate(type); end

    private

    # : (::RBS::Types::ClassInstance) -> Type
    #
    # source://rbi//lib/rbi/rbs/type_translator.rb#99
    sig { params(type: ::RBS::Types::ClassInstance).returns(::RBI::Type) }
    def translate_class_instance(type); end

    # : (::RBS::Types::Function) -> Type
    #
    # source://rbi//lib/rbi/rbs/type_translator.rb#107
    sig { params(type: ::RBS::Types::Function).returns(::RBI::Type) }
    def translate_function(type); end

    # : (String type_name) -> String
    #
    # source://rbi//lib/rbi/rbs/type_translator.rb#154
    sig { params(type_name: ::String).returns(::String) }
    def translate_t_generic_type(type_name); end
  end
end

# A comment representing a RBS type prefixed with `#:`
#
# source://rbi//lib/rbi/model.rb#81
class RBI::RBSComment < ::RBI::Comment
  # : (Object other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#83
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end
end

# source://rbi//lib/rbi/rbs_printer.rb#5
class RBI::RBSPrinter < ::RBI::Visitor
  # : (?out: (IO | StringIO), ?indent: Integer, ?print_locs: bool, ?positional_names: bool) -> void
  #
  # @return [RBSPrinter] a new instance of RBSPrinter
  #
  # source://rbi//lib/rbi/rbs_printer.rb#21
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      positional_names: T::Boolean
    ).void
  end
  def initialize(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), positional_names: T.unsafe(nil)); end

  # : Integer
  #
  # source://rbi//lib/rbi/rbs_printer.rb#15
  sig { returns(::Integer) }
  def current_indent; end

  # : -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#39
  sig { void }
  def dedent; end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#9
  # @return [Boolean]
  def in_visibility_group; end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#9
  # @return [Boolean]
  def in_visibility_group=(_arg0); end

  # : -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#34
  # Printing
  sig { void }
  def indent; end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#18
  sig { returns(T::Boolean) }
  def positional_names; end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#18
  # @return [Boolean]
  def positional_names=(_arg0); end

  # : Node?
  #
  # source://rbi//lib/rbi/rbs_printer.rb#12
  sig { returns(T.nilable(::RBI::Node)) }
  def previous_node; end

  # Print a string without indentation nor `\n` at the end.
  # : (String string) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#45
  # Print a string without indentation nor `\n` at the end.
  sig { params(string: ::String).void }
  def print(string); end

  # : (RBI::Attr node, Sig sig) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#292
  sig { params(node: ::RBI::Attr, sig: ::RBI::Sig).void }
  def print_attr_sig(node, sig); end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#9
  sig { returns(T::Boolean) }
  def print_locs; end

  # : bool
  #
  # source://rbi//lib/rbi/rbs_printer.rb#9
  # @return [Boolean]
  def print_locs=(_arg0); end

  # : (RBI::Method node, Sig sig) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#381
  sig { params(node: ::RBI::Method, sig: ::RBI::Sig).void }
  def print_method_sig(node, sig); end

  # Print a string with indentation and `\n` at the end.
  # : (String string) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#65
  # Print a string with indentation and `\n` at the end.
  sig { params(string: ::String).void }
  def printl(string); end

  # Print a string without indentation but with a `\n` at the end.
  # : (?String? string) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#51
  # Print a string without indentation but with a `\n` at the end.
  sig { params(string: T.nilable(::String)).void }
  def printn(string = T.unsafe(nil)); end

  # Print a string with indentation but without a `\n` at the end.
  # : (?String? string) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#58
  # Print a string with indentation but without a `\n` at the end.
  sig { params(string: T.nilable(::String)).void }
  def printt(string = T.unsafe(nil)); end

  # : (Array[Node] nodes) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#72
  sig { override.params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  # : (Arg node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#578
  sig { override.params(node: ::RBI::Arg).void }
  def visit_arg(node); end

  # : (Attr node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#260
  sig { params(node: ::RBI::Attr).void }
  def visit_attr(node); end

  # : (AttrAccessor node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#243
  sig { override.params(node: ::RBI::AttrAccessor).void }
  def visit_attr_accessor(node); end

  # : (AttrReader node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#249
  sig { override.params(node: ::RBI::AttrReader).void }
  def visit_attr_reader(node); end

  # : (AttrWriter node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#255
  sig { override.params(node: ::RBI::AttrWriter).void }
  def visit_attr_writer(node); end

  # : (BlankLine node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#114
  sig { override.params(node: ::RBI::BlankLine).void }
  def visit_blank_line(node); end

  # : (BlockParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#510
  sig { override.params(node: ::RBI::BlockParam).void }
  def visit_block_param(node); end

  # : (Class node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#134
  sig { override.params(node: ::RBI::Class).void }
  def visit_class(node); end

  # : (Comment node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#97
  sig { override.params(node: ::RBI::Comment).void }
  def visit_comment(node); end

  # : (ConflictTree node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#711
  sig { override.params(node: ::RBI::ConflictTree).void }
  def visit_conflict_tree(node); end

  # : (Const node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#227
  sig { override.params(node: ::RBI::Const).void }
  def visit_const(node); end

  # : (Extend node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#522
  sig { override.params(node: ::RBI::Extend).void }
  def visit_extend(node); end

  # : (File file) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#84
  sig { override.params(file: ::RBI::File).void }
  def visit_file(file); end

  # : (Group node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#684
  sig { override.params(node: ::RBI::Group).void }
  def visit_group(node); end

  # : (Helper node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#672
  sig { override.params(node: ::RBI::Helper).void }
  def visit_helper(node); end

  # : (Include node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#516
  sig { override.params(node: ::RBI::Include).void }
  def visit_include(node); end

  # : (KwArg node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#584
  sig { override.params(node: ::RBI::KwArg).void }
  def visit_kw_arg(node); end

  # : (KwOptParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#498
  sig { override.params(node: ::RBI::KwOptParam).void }
  def visit_kw_opt_param(node); end

  # : (KwParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#492
  sig { override.params(node: ::RBI::KwParam).void }
  def visit_kw_param(node); end

  # : (KwRestParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#504
  sig { override.params(node: ::RBI::KwRestParam).void }
  def visit_kw_rest_param(node); end

  # : (Method node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#315
  sig { override.params(node: ::RBI::Method).void }
  def visit_method(node); end

  # : (MixesInClassMethods node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#678
  sig { override.params(node: ::RBI::MixesInClassMethods).void }
  def visit_mixes_in_class_methods(node); end

  # : (Mixin node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#527
  sig { params(node: ::RBI::Mixin).void }
  def visit_mixin(node); end

  # : (Module node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#128
  sig { override.params(node: ::RBI::Module).void }
  def visit_module(node); end

  # : (OptParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#472
  sig { override.params(node: ::RBI::OptParam).void }
  def visit_opt_param(node); end

  # : (Private node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#557
  sig { override.params(node: ::RBI::Private).void }
  def visit_private(node); end

  # : (Protected node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#551
  sig { override.params(node: ::RBI::Protected).void }
  def visit_protected(node); end

  # : (Public node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#545
  sig { override.params(node: ::RBI::Public).void }
  def visit_public(node); end

  # : (ReqParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#462
  sig { override.params(node: ::RBI::ReqParam).void }
  def visit_req_param(node); end

  # : (RequiresAncestor node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#705
  sig { override.params(node: ::RBI::RequiresAncestor).void }
  def visit_requires_ancestor(node); end

  # : (RestParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#482
  sig { override.params(node: ::RBI::RestParam).void }
  def visit_rest_param(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#151
  sig { params(node: ::RBI::Scope).void }
  def visit_scope(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#214
  sig { params(node: ::RBI::Scope).void }
  def visit_scope_body(node); end

  # : (ScopeConflict node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#721
  sig { override.params(node: ::RBI::ScopeConflict).void }
  def visit_scope_conflict(node); end

  # : (Scope node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#161
  sig { params(node: ::RBI::Scope).void }
  def visit_scope_header(node); end

  # : (Send node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#572
  sig { override.params(node: ::RBI::Send).void }
  def visit_send(node); end

  # : (Sig node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#443
  sig { params(node: ::RBI::Sig).void }
  def visit_sig(node); end

  # : (SigParam node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#456
  sig { params(node: ::RBI::SigParam).void }
  def visit_sig_param(node); end

  # : (SingletonClass node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#146
  sig { override.params(node: ::RBI::SingletonClass).void }
  def visit_singleton_class(node); end

  # : (Struct node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#140
  sig { override.params(node: ::RBI::Struct).void }
  def visit_struct(node); end

  # : (TEnum node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#641
  sig { override.params(node: ::RBI::TEnum).void }
  def visit_tenum(node); end

  # : (TEnumBlock node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#647
  sig { override.params(node: ::RBI::TEnumBlock).void }
  def visit_tenum_block(node); end

  # : (Tree node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#120
  sig { override.params(node: ::RBI::Tree).void }
  def visit_tree(node); end

  # : (TStruct node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#590
  sig { override.params(node: ::RBI::TStruct).void }
  def visit_tstruct(node); end

  # : (TStructConst node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#625
  sig { override.params(node: ::RBI::TStructConst).void }
  def visit_tstruct_const(node); end

  # : (TStructProp node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#633
  sig { override.params(node: ::RBI::TStructProp).void }
  def visit_tstruct_prop(node); end

  # : (TypeMember node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#666
  sig { override.params(node: ::RBI::TypeMember).void }
  def visit_type_member(node); end

  # : (Visibility node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#562
  sig { params(node: ::RBI::Visibility).void }
  def visit_visibility(node); end

  # : (VisibilityGroup node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#691
  sig { override.params(node: ::RBI::VisibilityGroup).void }
  def visit_visibility_group(node); end

  private

  # : (Node node) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rbs_printer.rb#824
  sig { params(node: ::RBI::Node).returns(T::Boolean) }
  def oneline?(node); end

  # Parse a string containing a `T.let(x, X)` and extract the type
  #
  # Returns `nil` is the string is not a `T.let`.
  # : (String? code) -> String?
  #
  # source://rbi//lib/rbi/rbs_printer.rb#858
  # Parse a string containing a `T.let(x, X)` and extract the type
  # Returns `nil` is the string is not a `T.let`.
  sig { params(code: T.nilable(::String)).returns(T.nilable(::String)) }
  def parse_t_let(code); end

  # : ((Type | String) type) -> Type
  #
  # source://rbi//lib/rbi/rbs_printer.rb#846
  sig { params(type: T.any(::RBI::Type, ::String)).returns(::RBI::Type) }
  def parse_type(type); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#737
  sig { params(node: ::RBI::Node).void }
  def print_blank_line_before(node); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#756
  sig { params(node: ::RBI::Node).void }
  def print_loc(node); end

  # : (Param node, last: bool) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#798
  sig { params(node: ::RBI::Param, last: T::Boolean).void }
  def print_param_comment_leading_space(node, last:); end

  # : (Method node, SigParam param) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#762
  sig { params(node: ::RBI::Method, param: ::RBI::SigParam).void }
  def print_sig_param(node, param); end

  # : (SigParam node, last: bool) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#816
  sig { params(node: ::RBI::SigParam, last: T::Boolean).void }
  def print_sig_param_comment_leading_space(node, last:); end
end

# source://rbi//lib/rbi/rbs_printer.rb#6
class RBI::RBSPrinter::Error < ::RBI::Error; end

# source://rbi//lib/rbi/model.rb#5
class RBI::ReplaceNodeError < ::RBI::Error; end

# source://rbi//lib/rbi/model.rb#532
class RBI::ReqParam < ::RBI::Param
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (ReqParam node) -> void } -> void
  #
  # @return [ReqParam] a new instance of ReqParam
  #
  # source://rbi//lib/rbi/model.rb#534
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::ReqParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#540
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end
end

# source://rbi//lib/rbi/model.rb#1100
class RBI::RequiresAncestor < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [RequiresAncestor] a new instance of RequiresAncestor
  #
  # source://rbi//lib/rbi/model.rb#1105
  sig { params(name: ::String, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#159
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#1102
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1112
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#562
class RBI::RestParam < ::RBI::Param
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (RestParam node) -> void } -> void
  #
  # @return [RestParam] a new instance of RestParam
  #
  # source://rbi//lib/rbi/model.rb#564
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::RestParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#576
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#571
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/rewriters/add_sig_templates.rb#5
module RBI::Rewriters; end

# source://rbi//lib/rbi/rewriters/add_sig_templates.rb#6
class RBI::Rewriters::AddSigTemplates < ::RBI::Visitor
  # : (?with_todo_comment: bool) -> void
  #
  # @return [AddSigTemplates] a new instance of AddSigTemplates
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#8
  sig { params(with_todo_comment: T::Boolean).void }
  def initialize(with_todo_comment: T.unsafe(nil)); end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#15
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (Attr attr) -> void
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#29
  sig { params(attr: ::RBI::Attr).void }
  def add_attr_sig(attr); end

  # : (Method method) -> void
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#44
  sig { params(method: ::RBI::Method).void }
  def add_method_sig(method); end

  # : (NodeWithComments node) -> void
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#55
  sig { params(node: ::RBI::NodeWithComments).void }
  def add_todo_comment(node); end
end

# source://rbi//lib/rbi/rewriters/annotate.rb#6
class RBI::Rewriters::Annotate < ::RBI::Visitor
  # : (String annotation, ?annotate_scopes: bool, ?annotate_properties: bool) -> void
  #
  # @return [Annotate] a new instance of Annotate
  #
  # source://rbi//lib/rbi/rewriters/annotate.rb#8
  sig { params(annotation: ::String, annotate_scopes: T::Boolean, annotate_properties: T::Boolean).void }
  def initialize(annotation, annotate_scopes: T.unsafe(nil), annotate_properties: T.unsafe(nil)); end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/annotate.rb#17
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (NodeWithComments node) -> void
  #
  # source://rbi//lib/rbi/rewriters/annotate.rb#30
  sig { params(node: ::RBI::NodeWithComments).void }
  def annotate_node(node); end

  # : (Node node) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/annotate.rb#37
  sig { params(node: ::RBI::Node).returns(T::Boolean) }
  def root?(node); end
end

# source://rbi//lib/rbi/rewriters/attr_to_methods.rb#22
class RBI::Rewriters::AttrToMethods < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#25
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (Node node, with: Array[Node]) -> void
  #
  # @raise [ReplaceNodeError]
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#38
  sig { params(node: ::RBI::Node, with: T::Array[::RBI::Node]).void }
  def replace(node, with:); end
end

# source://rbi//lib/rbi/rewriters/deannotate.rb#6
class RBI::Rewriters::Deannotate < ::RBI::Visitor
  # : (String annotation) -> void
  #
  # @return [Deannotate] a new instance of Deannotate
  #
  # source://rbi//lib/rbi/rewriters/deannotate.rb#8
  sig { params(annotation: ::String).void }
  def initialize(annotation); end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/deannotate.rb#15
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (NodeWithComments node) -> void
  #
  # source://rbi//lib/rbi/rewriters/deannotate.rb#26
  sig { params(node: ::RBI::NodeWithComments).void }
  def deannotate_node(node); end
end

# Take a gem version and filter out all RBI that is not relevant to that version based on @version annotations
# in comments. As an example:
#
# ~~~rb
# tree = Parser.parse_string(<<~RBI)
#   class Foo
#     # @version > 0.3.0
#     def bar
#     end
#
#     # @version <= 0.3.0
#     def bar(arg1)
#     end
#   end
# RBI
#
# Rewriters::FilterVersions.filter(tree, Gem::Version.new("0.3.1"))
#
# assert_equal(<<~RBI, tree.string)
#   class Foo
#     # @version > 0.3.0
#     def bar
#     end
#   end
# RBI
# ~~~
#
# Supported operators:
# - equals `=`
# - not equals `!=`
# - greater than `>`
# - greater than or equal to `>=`
# - less than `<`
# - less than or equal to `<=`
# - pessimistic or twiddle-wakka`~>`
#
# And/or logic:
# - "And" logic: put multiple versions on the same line
#   - e.g. `@version > 0.3.0, <1.0.0` means version must be greater than 0.3.0 AND less than 1.0.0
# - "Or" logic: put multiple versions on subsequent lines
#   - e.g. the following means version must be less than 0.3.0 OR greater than 1.0.0
#       ```
#       # @version < 0.3.0
#       # @version > 1.0.0
#       ```
# Prerelease versions:
# - Prerelease versions are considered less than their non-prerelease counterparts
#   - e.g. `0.4.0-prerelease` is less than `0.4.0`
#
# RBI with no versions:
# - RBI with no version annotations are automatically counted towards ALL versions
#
# source://rbi//lib/rbi/rewriters/filter_versions.rb#57
# Take a gem version and filter out all RBI that is not relevant to that version based on @version annotations
# in comments. As an example:
# ~~~rb
# tree = Parser.parse_string(<<~RBI)
#   class Foo
#     # @version > 0.3.0
#     def bar
#     end
#     # @version <= 0.3.0
#     def bar(arg1)
#   end
# RBI
# Rewriters::FilterVersions.filter(tree, Gem::Version.new("0.3.1"))
# assert_equal(<<~RBI, tree.string)
# ~~~
# Supported operators:
# - equals `=`
# - not equals `!=`
# - greater than `>`
# - greater than or equal to `>=`
# - less than `<`
# - less than or equal to `<=`
# - pessimistic or twiddle-wakka`~>`
# And/or logic:
# - "And" logic: put multiple versions on the same line
#   - e.g. `@version > 0.3.0, <1.0.0` means version must be greater than 0.3.0 AND less than 1.0.0
# - "Or" logic: put multiple versions on subsequent lines
#   - e.g. the following means version must be less than 0.3.0 OR greater than 1.0.0
#       ```
#       # @version < 0.3.0
#       # @version > 1.0.0
# Prerelease versions:
# - Prerelease versions are considered less than their non-prerelease counterparts
#   - e.g. `0.4.0-prerelease` is less than `0.4.0`
# RBI with no versions:
class RBI::Rewriters::FilterVersions < ::RBI::Visitor
  # : (Gem::Version version) -> void
  #
  # @return [FilterVersions] a new instance of FilterVersions
  #
  # source://rbi//lib/rbi/rewriters/filter_versions.rb#69
  sig { params(version: ::Gem::Version).void }
  def initialize(version); end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/filter_versions.rb#76
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  class << self
    # : (Tree tree, Gem::Version version) -> void
    #
    # source://rbi//lib/rbi/rewriters/filter_versions.rb#62
    sig { params(tree: ::RBI::Tree, version: ::Gem::Version).void }
    def filter(tree, version); end
  end
end

# source://rbi//lib/rbi/rewriters/filter_versions.rb#58
RBI::Rewriters::FilterVersions::VERSION_PREFIX = T.let(T.unsafe(nil), String)

# Rewrite non-singleton methods inside singleton classes to singleton methods
#
# Example:
# ~~~rb
# class << self
#  def m1; end
#  def self.m2; end
#
#  class << self
#    def m3; end
#  end
# end
# ~~~
#
# will be rewritten to:
#
# ~~~rb
# def self.m1; end
#
# class << self
#   def self.m2; end
#   def self.m3; end
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/flatten_singleton_methods.rb#30
# Rewrite non-singleton methods inside singleton classes to singleton methods
# Example:
# ~~~rb
# class << self
#  def m1; end
#  def self.m2; end
#  class << self
#    def m3; end
#  end
# end
# will be rewritten to:
# def self.m1; end
#   def self.m2; end
#   def self.m3; end
class RBI::Rewriters::FlattenSingletonMethods < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/flatten_singleton_methods.rb#33
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# Flattens visibility nodes into method nodes
#
# Example:
# ~~~rb
# class A
#   def m1; end
#   private
#   def m2; end
#   def m3; end
# end
# ~~~
#
# will be transformed into:
#
# ~~~rb
# class A
#   def m1; end
#   private def m2; end
#   private def m3; end
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/flatten_visibilities.rb#27
# Flattens visibility nodes into method nodes
# Example:
# ~~~rb
# class A
#   def m1; end
#   private
#   def m2; end
#   def m3; end
# end
# will be transformed into:
#   private def m2; end
#   private def m3; end
class RBI::Rewriters::FlattenVisibilities < ::RBI::Visitor
  # : -> void
  #
  # @return [FlattenVisibilities] a new instance of FlattenVisibilities
  #
  # source://rbi//lib/rbi/rewriters/flatten_visibilities.rb#29
  sig { void }
  def initialize; end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/flatten_visibilities.rb#37
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# source://rbi//lib/rbi/rewriters/group_nodes.rb#8
class RBI::Rewriters::GroupNodes < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/group_nodes.rb#11
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (Node node) -> Group::Kind
  #
  # source://rbi//lib/rbi/rewriters/group_nodes.rb#35
  sig { params(node: ::RBI::Node).returns(::RBI::Group::Kind) }
  def group_kind(node); end
end

# Merge two RBI trees together
#
# Be this `Tree`:
# ~~~rb
# class Foo
#   attr_accessor :a
#   def m; end
#   C = 10
# end
# ~~~
#
# Merged with this one:
# ~~~rb
# class Foo
#   attr_reader :a
#   def m(x); end
#   C = 10
# end
# ~~~
#
# Compatible definitions are merged together while incompatible definitions are moved into a `ConflictTree`:
# ~~~rb
# class Foo
#   <<<<<<< left
#   attr_accessor :a
#   def m; end
#   =======
#   attr_reader :a
#   def m(x); end
#   >>>>>>> right
#   C = 10
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#39
# Merge two RBI trees together
# Be this `Tree`:
# ~~~rb
# class Foo
#   attr_accessor :a
#   def m; end
#   C = 10
# end
# Merged with this one:
#   attr_reader :a
#   def m(x); end
# Compatible definitions are merged together while incompatible definitions are moved into a `ConflictTree`:
#   <<<<<<< left
#   =======
#   >>>>>>> right
class RBI::Rewriters::Merge
  # : (?left_name: String, ?right_name: String, ?keep: Keep) -> void
  #
  # @return [Merge] a new instance of Merge
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#66
  sig { params(left_name: ::String, right_name: ::String, keep: ::RBI::Rewriters::Merge::Keep).void }
  def initialize(left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  # : (Tree tree) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#75
  sig { params(tree: ::RBI::Tree).void }
  def merge(tree); end

  # : MergeTree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#63
  sig { returns(::RBI::MergeTree) }
  def tree; end

  class << self
    # : (Tree left, Tree right, ?left_name: String, ?right_name: String, ?keep: Keep) -> MergeTree
    #
    # source://rbi//lib/rbi/rewriters/merge_trees.rb#50
    sig do
      params(
        left: ::RBI::Tree,
        right: ::RBI::Tree,
        left_name: ::String,
        right_name: ::String,
        keep: ::RBI::Rewriters::Merge::Keep
      ).returns(::RBI::MergeTree)
    end
    def merge_trees(left, right, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end
  end
end

# Used for logging / error displaying purpose
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#82
class RBI::Rewriters::Merge::Conflict < ::T::Struct
  const :left, ::RBI::Node
  const :right, ::RBI::Node
  const :left_name, ::String
  const :right_name, ::String

  # : -> String
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#89
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://sorbet-runtime/0.5.11945/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Merge adjacent conflict trees
#
# Transform this:
# ~~~rb
# class Foo
#   <<<<<<< left
#   def m1; end
#   =======
#   def m1(a); end
#   >>>>>>> right
#   <<<<<<< left
#   def m2(a); end
#   =======
#   def m2; end
#   >>>>>>> right
# end
# ~~~
#
# Into this:
# ~~~rb
# class Foo
#   <<<<<<< left
#   def m1; end
#   def m2(a); end
#   =======
#   def m1(a); end
#   def m2; end
#   >>>>>>> right
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#238
# Merge adjacent conflict trees
# Transform this:
# ~~~rb
# class Foo
#   <<<<<<< left
#   def m1; end
#   =======
#   def m1(a); end
#   >>>>>>> right
#   def m2(a); end
#   def m2; end
# end
# Into this:
class RBI::Rewriters::Merge::ConflictTreeMerger < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#241
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  # : (Array[Node] nodes) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#247
  sig { override.params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  private

  # : (Tree left, Tree right) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#268
  sig { params(left: ::RBI::Tree, right: ::RBI::Tree).void }
  def merge_conflict_trees(left, right); end
end

# source://rbi//lib/rbi/rewriters/merge_trees.rb#40
class RBI::Rewriters::Merge::Keep < ::T::Enum
  enums do
    LEFT = new
    NONE = new
    RIGHT = new
  end
end

# source://rbi//lib/rbi/rewriters/merge_trees.rb#94
class RBI::Rewriters::Merge::TreeMerger < ::RBI::Visitor
  # : (Tree output, ?left_name: String, ?right_name: String, ?keep: Keep) -> void
  #
  # @return [TreeMerger] a new instance of TreeMerger
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#99
  sig do
    params(
      output: ::RBI::Tree,
      left_name: ::String,
      right_name: ::String,
      keep: ::RBI::Rewriters::Merge::Keep
    ).void
  end
  def initialize(output, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  # : Array[Conflict]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#96
  sig { returns(T::Array[::RBI::Rewriters::Merge::Conflict]) }
  def conflicts; end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#112
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : -> Tree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#161
  sig { returns(::RBI::Tree) }
  def current_scope; end

  # : (Scope left, Scope right) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#178
  sig { params(left: ::RBI::Scope, right: ::RBI::Scope).void }
  def make_conflict_scope(left, right); end

  # : (Node left, Node right) -> void
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#185
  sig { params(left: ::RBI::Node, right: ::RBI::Node).void }
  def make_conflict_tree(left, right); end

  # : (Node node) -> Node?
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#166
  sig { params(node: ::RBI::Node).returns(T.nilable(::RBI::Node)) }
  def previous_definition(node); end

  # : (Scope left, Scope right) -> Scope
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#197
  sig { params(left: ::RBI::Scope, right: ::RBI::Scope).returns(::RBI::Scope) }
  def replace_scope_header(left, right); end
end

# source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#6
class RBI::Rewriters::NestNonPublicMembers < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#9
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# source://rbi//lib/rbi/rewriters/nest_singleton_methods.rb#6
class RBI::Rewriters::NestSingletonMethods < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_singleton_methods.rb#9
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# This rewriter moves top-level members into a top-level Object class
#
# Example:
# ~~~rb
# def foo; end
# attr_reader :bar
# ~~~
#
# will be rewritten to:
#
# ~~~rb
# class Object
#  def foo; end
#  attr_reader :bar
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/nest_top_level_members.rb#22
# This rewriter moves top-level members into a top-level Object class
# Example:
# ~~~rb
# def foo; end
# attr_reader :bar
# will be rewritten to:
# class Object
#  def foo; end
#  attr_reader :bar
# end
class RBI::Rewriters::NestTopLevelMembers < ::RBI::Visitor
  # : -> void
  #
  # @return [NestTopLevelMembers] a new instance of NestTopLevelMembers
  #
  # source://rbi//lib/rbi/rewriters/nest_top_level_members.rb#24
  sig { void }
  def initialize; end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_top_level_members.rb#32
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# Remove all definitions existing in the index from the current tree
#
# Let's create an `Index` from two different `Tree`s:
# ~~~rb
# tree1 = Parse.parse_string(<<~RBI)
#   class Foo
#     def foo; end
#   end
# RBI
#
# tree2 = Parse.parse_string(<<~RBI)
#   FOO = 10
# RBI
#
# index = Index.index(tree1, tree2)
# ~~~
#
# We can use `RemoveKnownDefinitions` to remove the definitions found in the `index` from the `Tree` to clean:
# ~~~rb
# tree_to_clean = Parser.parse_string(<<~RBI)
#   class Foo
#     def foo; end
#     def bar; end
#   end
#   FOO = 10
#   BAR = 42
# RBI
#
# cleaned_tree, operations = RemoveKnownDefinitions.remove(tree_to_clean, index)
#
# assert_equal(<<~RBI, cleaned_tree)
#   class Foo
#     def bar; end
#   end
#   BAR = 42
# RBI
#
# assert_equal(<<~OPERATIONS, operations.join("\n"))
#   Deleted ::Foo#foo at -:2:2-2-16 (duplicate from -:2:2-2:16)
#   Deleted ::FOO at -:5:0-5:8 (duplicate from -:1:0-1:8)
# OPERATIONS
# ~~~
#
# source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#48
# Remove all definitions existing in the index from the current tree
# Let's create an `Index` from two different `Tree`s:
# ~~~rb
# tree1 = Parse.parse_string(<<~RBI)
#   class Foo
#     def foo; end
#   end
# RBI
# tree2 = Parse.parse_string(<<~RBI)
#   FOO = 10
# index = Index.index(tree1, tree2)
# We can use `RemoveKnownDefinitions` to remove the definitions found in the `index` from the `Tree` to clean:
# tree_to_clean = Parser.parse_string(<<~RBI)
#     def bar; end
#   BAR = 42
# cleaned_tree, operations = RemoveKnownDefinitions.remove(tree_to_clean, index)
# assert_equal(<<~RBI, cleaned_tree)
# assert_equal(<<~OPERATIONS, operations.join("\n"))
#   Deleted ::Foo#foo at -:2:2-2-16 (duplicate from -:2:2-2:16)
#   Deleted ::FOO at -:5:0-5:8 (duplicate from -:1:0-1:8)
# OPERATIONS
class RBI::Rewriters::RemoveKnownDefinitions < ::RBI::Visitor
  # : (Index index) -> void
  #
  # @return [RemoveKnownDefinitions] a new instance of RemoveKnownDefinitions
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#53
  sig { params(index: ::RBI::Index).void }
  def initialize(index); end

  # : Array[Operation]
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#50
  sig { returns(T::Array[::RBI::Rewriters::RemoveKnownDefinitions::Operation]) }
  def operations; end

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#75
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  # : (Array[Node] nodes) -> void
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#69
  sig { params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  private

  # : (Node node, Node previous) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#103
  sig { params(node: ::RBI::Node, previous: ::RBI::Node).returns(T::Boolean) }
  def can_delete_node?(node, previous); end

  # : (Node node, Node previous) -> void
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#121
  sig { params(node: ::RBI::Node, previous: ::RBI::Node).void }
  def delete_node(node, previous); end

  # : (Indexable node) -> Node?
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#94
  sig { params(node: ::RBI::Indexable).returns(T.nilable(::RBI::Node)) }
  def previous_definition_for(node); end

  class << self
    # : (Tree tree, Index index) -> [Tree, Array[Operation]]
    #
    # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#61
    sig do
      params(
        tree: ::RBI::Tree,
        index: ::RBI::Index
      ).returns([::RBI::Tree, T::Array[::RBI::Rewriters::RemoveKnownDefinitions::Operation]])
    end
    def remove(tree, index); end
  end
end

# source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#126
class RBI::Rewriters::RemoveKnownDefinitions::Operation < ::T::Struct
  const :deleted_node, ::RBI::Node
  const :duplicate_of, ::RBI::Node

  # : -> String
  #
  # source://rbi//lib/rbi/rewriters/remove_known_definitions.rb#131
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://sorbet-runtime/0.5.11945/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://rbi//lib/rbi/rewriters/sort_nodes.rb#6
class RBI::Rewriters::SortNodes < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#9
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (Group::Kind kind) -> Integer
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#72
  sig { params(kind: ::RBI::Group::Kind).returns(::Integer) }
  def group_rank(kind); end

  # : (Node node) -> String?
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#93
  sig { params(node: ::RBI::Node).returns(T.nilable(::String)) }
  def node_name(node); end

  # : (Node node) -> Integer
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#44
  sig { params(node: ::RBI::Node).returns(::Integer) }
  def node_rank(node); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#105
  sig { params(node: ::RBI::Node).void }
  def sort_node_names!(node); end
end

# Translate all RBS signature comments to Sorbet RBI signatures
#
# source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#7
class RBI::Rewriters::TranslateRBSSigs < ::RBI::Visitor
  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#12
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  # : (Method | Attr) -> Array[RBSComment]
  #
  # source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#34
  sig { params(node: T.any(::RBI::Attr, ::RBI::Method)).returns(T::Array[::RBI::RBSComment]) }
  def extract_rbs_comments(node); end

  # : (Attr, RBSComment) -> Sig
  #
  # source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#61
  sig { params(node: ::RBI::Attr, comment: ::RBI::RBSComment).returns(::RBI::Sig) }
  def translate_rbs_attr_type(node, comment); end

  # : (Method, RBSComment) -> Sig
  #
  # source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#53
  sig { params(node: ::RBI::Method, comment: ::RBI::RBSComment).returns(::RBI::Sig) }
  def translate_rbs_method_type(node, comment); end
end

# source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#8
class RBI::Rewriters::TranslateRBSSigs::Error < ::RBI::Error; end

# Scopes
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#166
class RBI::Scope < ::RBI::Tree
  include ::RBI::Indexable

  abstract!

  # Duplicate `self` scope without its body
  # : -> self
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#337
  # Duplicate `self` scope without its body
  sig { returns(T.self_type) }
  def dup_empty; end

  # @abstract
  #
  # source://rbi//lib/rbi/model.rb#173
  sig { abstract.returns(::String) }
  def fully_qualified_name; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#89
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#177
  sig { override.returns(::String) }
  def to_s; end
end

# A conflict between two scope headers
#
# Is rendered as a merge conflict between `left` and` right` for scope definitions:
# ~~~rb
# <<<<<<< left
# class Foo
# =======
# module Foo
# >>>>>>> right
#   def m1; end
# end
# ~~~
#
# source://rbi//lib/rbi/rewriters/merge_trees.rb#577
# A conflict between two scope headers
# Is rendered as a merge conflict between `left` and` right` for scope definitions:
# ~~~rb
# <<<<<<< left
# class Foo
# =======
# module Foo
# >>>>>>> right
#   def m1; end
# end
class RBI::ScopeConflict < ::RBI::Tree
  # : (left: Scope, right: Scope, ?left_name: String, ?right_name: String) -> void
  #
  # @return [ScopeConflict] a new instance of ScopeConflict
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#585
  sig { params(left: ::RBI::Scope, right: ::RBI::Scope, left_name: ::String, right_name: ::String).void }
  def initialize(left:, right:, left_name: T.unsafe(nil), right_name: T.unsafe(nil)); end

  # : Scope
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#579
  sig { returns(::RBI::Scope) }
  def left; end

  # : String
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#582
  sig { returns(::String) }
  def left_name; end

  # : Scope
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#579
  # @return [Scope]
  def right; end

  # : String
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#582
  # @return [String]
  def right_name; end
end

# Sends
#
# source://rbi//lib/rbi/model.rb#771
class RBI::Send < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String method, ?Array[Arg] args, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Send node) -> void } -> void
  #
  # @return [Send] a new instance of Send
  #
  # source://rbi//lib/rbi/model.rb#779
  sig do
    params(
      method: ::String,
      args: T::Array[::RBI::Arg],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Send).void)
    ).void
  end
  def initialize(method, args = T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Arg arg) -> void
  #
  # source://rbi//lib/rbi/model.rb#787
  sig { params(arg: ::RBI::Arg).void }
  def <<(arg); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#792
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : Array[Arg]
  #
  # source://rbi//lib/rbi/model.rb#776
  sig { returns(T::Array[::RBI::Arg]) }
  def args; end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#503
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#189
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#773
  sig { returns(::String) }
  def method; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#797
  sig { returns(::String) }
  def to_s; end
end

# Sorbet's sigs
#
# source://rbi//lib/rbi/model.rb#846
class RBI::Sig < ::RBI::NodeWithComments
  # : (?params: Array[SigParam], ?return_type: (Type | String), ?is_abstract: bool, ?is_override: bool, ?is_overridable: bool, ?is_final: bool, ?allow_incompatible_override: bool, ?type_params: Array[String], ?checked: Symbol?, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Sig node) -> void } -> void
  #
  # @return [Sig] a new instance of Sig
  #
  # source://rbi//lib/rbi/model.rb#863
  sig do
    params(
      params: T::Array[::RBI::SigParam],
      return_type: T.any(::RBI::Type, ::String),
      is_abstract: T::Boolean,
      is_override: T::Boolean,
      is_overridable: T::Boolean,
      is_final: T::Boolean,
      allow_incompatible_override: T::Boolean,
      type_params: T::Array[::String],
      checked: T.nilable(::Symbol),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Sig).void)
    ).void
  end
  def initialize(params: T.unsafe(nil), return_type: T.unsafe(nil), is_abstract: T.unsafe(nil), is_override: T.unsafe(nil), is_overridable: T.unsafe(nil), is_final: T.unsafe(nil), allow_incompatible_override: T.unsafe(nil), type_params: T.unsafe(nil), checked: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (SigParam param) -> void
  #
  # source://rbi//lib/rbi/model.rb#891
  sig { params(param: ::RBI::SigParam).void }
  def <<(param); end

  # : (Object other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#901
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # : (String name, (Type | String) type) -> void
  #
  # source://rbi//lib/rbi/model.rb#896
  sig { params(name: ::String, type: T.any(::RBI::Type, ::String)).void }
  def add_param(name, type); end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def allow_incompatible_override; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def allow_incompatible_override=(_arg0); end

  # : Symbol?
  #
  # source://rbi//lib/rbi/model.rb#860
  sig { returns(T.nilable(::Symbol)) }
  def checked; end

  # : Symbol?
  #
  # source://rbi//lib/rbi/model.rb#860
  # @return [Symbol, nil]
  def checked=(_arg0); end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  sig { returns(T::Boolean) }
  def is_abstract; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_abstract=(_arg0); end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_final; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_final=(_arg0); end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_overridable; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_overridable=(_arg0); end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_override; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#854
  # @return [Boolean]
  def is_override=(_arg0); end

  # : Array[SigParam]
  #
  # source://rbi//lib/rbi/model.rb#848
  sig { returns(T::Array[::RBI::SigParam]) }
  def params; end

  # : (Type | String)
  #
  # source://rbi//lib/rbi/model.rb#851
  sig { returns(T.any(::RBI::Type, ::String)) }
  def return_type; end

  # : (Type | String)
  #
  # source://rbi//lib/rbi/model.rb#851
  # @return [Type, String]
  def return_type=(_arg0); end

  # : Array[String]
  #
  # source://rbi//lib/rbi/model.rb#857
  sig { returns(T::Array[::String]) }
  def type_params; end
end

# source://rbi//lib/rbi/model.rb#910
class RBI::SigParam < ::RBI::NodeWithComments
  # : (String name, (Type | String) type, ?loc: Loc?, ?comments: Array[Comment]) ?{ (SigParam node) -> void } -> void
  #
  # @return [SigParam] a new instance of SigParam
  #
  # source://rbi//lib/rbi/model.rb#918
  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::SigParam).void)
    ).void
  end
  def initialize(name, type, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Object other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#926
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#912
  sig { returns(::String) }
  def name; end

  # : (Type | String)
  #
  # source://rbi//lib/rbi/model.rb#915
  sig { returns(T.any(::RBI::Type, ::String)) }
  def type; end
end

# source://rbi//lib/rbi/model.rb#226
class RBI::SingletonClass < ::RBI::Scope
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (SingletonClass node) -> void } -> void
  #
  # @return [SingletonClass] a new instance of SingletonClass
  #
  # source://rbi//lib/rbi/model.rb#228
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::SingletonClass).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#235
  sig { override.returns(::String) }
  def fully_qualified_name; end
end

# source://rbi//lib/rbi/model.rb#240
class RBI::Struct < ::RBI::Scope
  # : (String name, ?members: Array[Symbol], ?keyword_init: bool, ?loc: Loc?, ?comments: Array[Comment]) ?{ (Struct struct) -> void } -> void
  #
  # @return [Struct] a new instance of Struct
  #
  # source://rbi//lib/rbi/model.rb#251
  sig do
    params(
      name: ::String,
      members: T::Array[::Symbol],
      keyword_init: T::Boolean,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(struct: ::RBI::Struct).void)
    ).void
  end
  def initialize(name, members: T.unsafe(nil), keyword_init: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#378
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#261
  sig { override.returns(::String) }
  def fully_qualified_name; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#248
  sig { returns(T::Boolean) }
  def keyword_init; end

  # : bool
  #
  # source://rbi//lib/rbi/model.rb#248
  # @return [Boolean]
  def keyword_init=(_arg0); end

  # : Array[Symbol]
  #
  # source://rbi//lib/rbi/model.rb#245
  sig { returns(T::Array[::Symbol]) }
  def members; end

  # : Array[Symbol]
  #
  # source://rbi//lib/rbi/model.rb#245
  # @return [Array<Symbol>]
  def members=(_arg0); end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#242
  sig { returns(::String) }
  def name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#242
  # @return [String]
  def name=(_arg0); end
end

# Sorbet's T::Enum
#
# source://rbi//lib/rbi/model.rb#1012
class RBI::TEnum < ::RBI::Class
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (TEnum klass) -> void } -> void
  #
  # @return [TEnum] a new instance of TEnum
  #
  # source://rbi//lib/rbi/model.rb#1014
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(klass: ::RBI::TEnum).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

# source://rbi//lib/rbi/model.rb#1020
class RBI::TEnumBlock < ::RBI::Scope
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (TEnumBlock node) -> void } -> void
  #
  # @return [TEnumBlock] a new instance of TEnumBlock
  #
  # source://rbi//lib/rbi/model.rb#1022
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TEnumBlock).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1029
  sig { override.returns(::String) }
  def fully_qualified_name; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#219
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1035
  sig { override.returns(::String) }
  def to_s; end
end

# Sorbet's T::Struct
#
# source://rbi//lib/rbi/model.rb#933
class RBI::TStruct < ::RBI::Class
  # : (String name, ?loc: Loc?, ?comments: Array[Comment]) ?{ (TStruct klass) -> void } -> void
  #
  # @return [TStruct] a new instance of TStruct
  #
  # source://rbi//lib/rbi/model.rb#935
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(klass: ::RBI::TStruct).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

# source://rbi//lib/rbi/model.rb#968
class RBI::TStructConst < ::RBI::TStructField
  include ::RBI::Indexable

  # : (String name, (Type | String) type, ?default: String?, ?loc: Loc?, ?comments: Array[Comment]) ?{ (TStructConst node) -> void } -> void
  #
  # @return [TStructConst] a new instance of TStructConst
  #
  # source://rbi//lib/rbi/model.rb#970
  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TStructConst).void)
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#519
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#977
  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#199
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#984
  sig { override.returns(::String) }
  def to_s; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#941
class RBI::TStructField < ::RBI::NodeWithComments
  abstract!

  # : (String name, (Type | String) type, ?default: String?, ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [TStructField] a new instance of TStructField
  #
  # source://rbi//lib/rbi/model.rb#957
  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#511
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#954
  sig { returns(T.nilable(::String)) }
  def default; end

  # : String?
  #
  # source://rbi//lib/rbi/model.rb#954
  # @return [String, nil]
  def default=(_arg0); end

  # @abstract
  #
  # source://rbi//lib/rbi/model.rb#965
  sig { abstract.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#948
  sig { returns(::String) }
  def name; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#948
  # @return [String]
  def name=(_arg0); end

  # : (Type | String)
  #
  # source://rbi//lib/rbi/model.rb#951
  sig { returns(T.any(::RBI::Type, ::String)) }
  def type; end

  # : (Type | String)
  #
  # source://rbi//lib/rbi/model.rb#951
  # @return [Type, String]
  def type=(_arg0); end
end

# source://rbi//lib/rbi/model.rb#989
class RBI::TStructProp < ::RBI::TStructField
  include ::RBI::Indexable

  # : (String name, (Type | String) type, ?default: String?, ?loc: Loc?, ?comments: Array[Comment]) ?{ (TStructProp node) -> void } -> void
  #
  # @return [TStructProp] a new instance of TStructProp
  #
  # source://rbi//lib/rbi/model.rb#991
  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TStructProp).void)
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#527
  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/model.rb#998
  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#209
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1005
  sig { override.returns(::String) }
  def to_s; end
end

# source://rbi//lib/rbi/model.rb#112
class RBI::Tree < ::RBI::NodeWithComments
  # : (?loc: Loc?, ?comments: Array[Comment]) ?{ (Tree node) -> void } -> void
  #
  # @return [Tree] a new instance of Tree
  #
  # source://rbi//lib/rbi/model.rb#117
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Tree).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : (Node node) -> void
  #
  # source://rbi//lib/rbi/model.rb#124
  sig { params(node: ::RBI::Node).void }
  def <<(node); end

  # : (?with_todo_comment: bool) -> void
  #
  # source://rbi//lib/rbi/rewriters/add_sig_templates.rb#63
  sig { params(with_todo_comment: T::Boolean).void }
  def add_sig_templates!(with_todo_comment: T.unsafe(nil)); end

  # : (String annotation, ?annotate_scopes: bool, ?annotate_properties: bool) -> void
  #
  # source://rbi//lib/rbi/rewriters/annotate.rb#46
  sig { params(annotation: ::String, annotate_scopes: T::Boolean, annotate_properties: T::Boolean).void }
  def annotate!(annotation, annotate_scopes: T.unsafe(nil), annotate_properties: T.unsafe(nil)); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#38
  sig do
    params(
      name: ::String,
      superclass_name: T.nilable(::String),
      block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)
    ).returns(::RBI::Scope)
  end
  def create_class(name, superclass_name: T.unsafe(nil), &block); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#45
  sig { params(name: ::String, value: ::String).void }
  def create_constant(name, value:); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#55
  sig { params(name: ::String).void }
  def create_extend(name); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#50
  sig { params(name: ::String).void }
  def create_include(name); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#90
  sig do
    params(
      name: ::String,
      parameters: T::Array[::RBI::TypedParam],
      return_type: T.nilable(::String),
      class_method: T::Boolean,
      visibility: ::RBI::Visibility,
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Method).void)
    ).void
  end
  def create_method(name, parameters: T.unsafe(nil), return_type: T.unsafe(nil), class_method: T.unsafe(nil), visibility: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#60
  sig { params(name: ::String).void }
  def create_mixes_in_class_methods(name); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#25
  sig { params(name: ::String, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_module(name, &block); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#9
  sig { params(constant: ::Module, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_path(constant, &block); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#74
  sig do
    params(
      name: ::String,
      type: ::String,
      variance: ::Symbol,
      fixed: T.nilable(::String),
      upper: T.nilable(::String),
      lower: T.nilable(::String)
    ).void
  end
  def create_type_variable(name, type:, variance: T.unsafe(nil), fixed: T.unsafe(nil), upper: T.unsafe(nil), lower: T.unsafe(nil)); end

  # : (String annotation) -> void
  #
  # source://rbi//lib/rbi/rewriters/deannotate.rb#38
  sig { params(annotation: ::String).void }
  def deannotate!(annotation); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/model.rb#130
  sig { returns(T::Boolean) }
  def empty?; end

  # : (Gem::Version version) -> void
  #
  # source://rbi//lib/rbi/rewriters/filter_versions.rb#113
  sig { params(version: ::Gem::Version).void }
  def filter_versions!(version); end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/flatten_singleton_methods.rb#57
  sig { void }
  def flatten_singleton_methods!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/flatten_visibilities.rb#57
  sig { void }
  def flatten_visibilities!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/group_nodes.rb#78
  sig { void }
  def group_nodes!; end

  # : -> Index
  #
  # source://rbi//lib/rbi/index.rb#64
  sig { returns(::RBI::Index) }
  def index; end

  # : (Tree other, ?left_name: String, ?right_name: String, ?keep: Rewriters::Merge::Keep) -> MergeTree
  #
  # source://rbi//lib/rbi/rewriters/merge_trees.rb#314
  sig do
    params(
      other: ::RBI::Tree,
      left_name: ::String,
      right_name: ::String,
      keep: ::RBI::Rewriters::Merge::Keep
    ).returns(::RBI::MergeTree)
  end
  def merge(other, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#43
  sig { void }
  def nest_non_public_members!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_singleton_methods.rb#33
  sig { void }
  def nest_singleton_methods!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/nest_top_level_members.rb#60
  sig { void }
  def nest_top_level_members!; end

  # : Array[Node]
  #
  # source://rbi//lib/rbi/model.rb#114
  sig { returns(T::Array[::RBI::Node]) }
  def nodes; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#50
  sig { void }
  def replace_attributes_with_methods!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/sort_nodes.rb#116
  sig { void }
  def sort_nodes!; end

  # : -> void
  #
  # source://rbi//lib/rbi/rewriters/translate_rbs_sigs.rb#82
  sig { void }
  def translate_rbs_sigs!; end

  private

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#123
  sig { params(node: ::RBI::Node).returns(::RBI::Node) }
  def create_node(node); end

  # source://tapioca/0.16.7/lib/tapioca/rbi_ext/model.rb#118
  sig { returns(T::Hash[::String, ::RBI::Node]) }
  def nodes_cache; end
end

# The base class for all RBI types.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/type.rb#6
class RBI::Type
  abstract!

  # : -> void
  #
  # @return [Type] a new instance of Type
  #
  # source://rbi//lib/rbi/type.rb#695
  sig { void }
  def initialize; end

  # @abstract
  #
  # source://rbi//lib/rbi/type.rb#741
  sig { abstract.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : (BasicObject other) -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/type.rb#744
  sig { params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  # : -> Integer
  #
  # source://rbi//lib/rbi/type.rb#750
  sig { override.returns(::Integer) }
  def hash; end

  # Returns a new type that is `nilable` if it is not already.
  #
  # If the type is already nilable, it returns itself.
  # ```ruby
  # type = RBI::Type.simple("String")
  # type.to_rbi # => "String"
  # type.nilable.to_rbi # => "T.nilable(String)"
  # type.nilable.nilable.to_rbi # => "T.nilable(String)"
  # ```
  # : -> Type
  #
  # source://rbi//lib/rbi/type.rb#709
  # Returns a new type that is `nilable` if it is not already.
  # If the type is already nilable, it returns itself.
  # ```ruby
  # type = RBI::Type.simple("String")
  # type.to_rbi # => "String"
  # type.nilable.to_rbi # => "T.nilable(String)"
  # type.nilable.nilable.to_rbi # => "T.nilable(String)"
  # ```
  sig { returns(::RBI::Type) }
  def nilable; end

  # Returns whether the type is nilable.
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/type.rb#736
  # Returns whether the type is nilable.
  sig { returns(T::Boolean) }
  def nilable?; end

  # Returns the non-nilable version of the type.
  # If the type is already non-nilable, it returns itself.
  # If the type is nilable, it returns the inner type.
  #
  # ```ruby
  # type = RBI::Type.nilable(RBI::Type.simple("String"))
  # type.to_rbi # => "T.nilable(String)"
  # type.non_nilable.to_rbi # => "String"
  # type.non_nilable.non_nilable.to_rbi # => "String"
  # ```
  # : -> Type
  #
  # source://rbi//lib/rbi/type.rb#724
  # Returns the non-nilable version of the type.
  # If the type is already non-nilable, it returns itself.
  # If the type is nilable, it returns the inner type.
  # ```ruby
  # type = RBI::Type.nilable(RBI::Type.simple("String"))
  # type.to_rbi # => "T.nilable(String)"
  # type.non_nilable.to_rbi # => "String"
  # type.non_nilable.non_nilable.to_rbi # => "String"
  # ```
  sig { returns(::RBI::Type) }
  def non_nilable; end

  # : -> String
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1136
  sig { returns(::String) }
  def rbs_string; end

  # @abstract
  #
  # source://rbi//lib/rbi/type.rb#755
  sig { abstract.returns(::String) }
  def to_rbi; end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#759
  sig { override.returns(::String) }
  def to_s; end

  class << self
    # Builds a type that represents an intersection of multiple types like `T.all(String, Integer)`.
    #
    # Note that this method transforms types such as `T.all(String, String)` into `String`, so
    # it may return something other than a `All`.
    # : (Type type1, Type type2, *Type types) -> Type
    #
    # source://rbi//lib/rbi/type.rb#559
    # Builds a type that represents an intersection of multiple types like `T.all(String, Integer)`.
    # Note that this method transforms types such as `T.all(String, String)` into `String`, so
    # it may return something other than a `All`.
    sig { params(type1: ::RBI::Type, type2: ::RBI::Type, types: ::RBI::Type).returns(::RBI::Type) }
    def all(type1, type2, *types); end

    # Builds a type that represents a union of multiple types like `T.any(String, Integer)`.
    #
    # Note that this method transforms types such as `T.any(String, NilClass)` into `T.nilable(String)`, so
    # it may return something other than a `Any`.
    # : (Type type1, Type type2, *Type types) -> Type
    #
    # source://rbi//lib/rbi/type.rb#586
    # Builds a type that represents a union of multiple types like `T.any(String, Integer)`.
    # Note that this method transforms types such as `T.any(String, NilClass)` into `T.nilable(String)`, so
    # it may return something other than a `Any`.
    sig { params(type1: ::RBI::Type, type2: ::RBI::Type, types: ::RBI::Type).returns(::RBI::Type) }
    def any(type1, type2, *types); end

    # Builds a type that represents `T.anything`.
    # : -> Anything
    #
    # source://rbi//lib/rbi/type.rb#484
    # Builds a type that represents `T.anything`.
    sig { returns(::RBI::Type::Anything) }
    def anything; end

    # Builds a type that represents `T.attached_class`.
    # : -> AttachedClass
    #
    # source://rbi//lib/rbi/type.rb#490
    # Builds a type that represents `T.attached_class`.
    sig { returns(::RBI::Type::AttachedClass) }
    def attached_class; end

    # Builds a type that represents `T::Boolean`.
    # : -> Boolean
    #
    # source://rbi//lib/rbi/type.rb#496
    # Builds a type that represents `T::Boolean`.
    sig { returns(::RBI::Type::Boolean) }
    def boolean; end

    # Builds a type that represents the singleton class of another type like `T.class_of(Foo)`.
    # : (Simple type, ?Type? type_parameter) -> ClassOf
    #
    # source://rbi//lib/rbi/type.rb#534
    # Builds a type that represents the singleton class of another type like `T.class_of(Foo)`.
    sig { params(type: ::RBI::Type::Simple, type_parameter: T.nilable(::RBI::Type)).returns(::RBI::Type::ClassOf) }
    def class_of(type, type_parameter = T.unsafe(nil)); end

    # Builds a type that represents a generic type like `T::Array[String]` or `T::Hash[Symbol, Integer]`.
    # : (String name, *(Type | Array[Type]) params) -> Generic
    #
    # source://rbi//lib/rbi/type.rb#651
    # Builds a type that represents a generic type like `T::Array[String]` or `T::Hash[Symbol, Integer]`.
    sig { params(name: ::String, params: T.any(::RBI::Type, T::Array[::RBI::Type])).returns(::RBI::Type::Generic) }
    def generic(name, *params); end

    # Builds a type that represents a nilable of another type like `T.nilable(String)`.
    #
    # Note that this method transforms types such as `T.nilable(T.untyped)` into `T.untyped`, so
    # it may return something other than a `RBI::Type::Nilable`.
    # : (Type type) -> Type
    #
    # source://rbi//lib/rbi/type.rb#543
    # Builds a type that represents a nilable of another type like `T.nilable(String)`.
    # Note that this method transforms types such as `T.nilable(T.untyped)` into `T.untyped`, so
    # it may return something other than a `RBI::Type::Nilable`.
    sig { params(type: ::RBI::Type).returns(::RBI::Type) }
    def nilable(type); end

    # Builds a type that represents `T.noreturn`.
    # : -> NoReturn
    #
    # source://rbi//lib/rbi/type.rb#502
    # Builds a type that represents `T.noreturn`.
    sig { returns(::RBI::Type::NoReturn) }
    def noreturn; end

    # : (Prism::Node node) -> Type
    #
    # source://rbi//lib/rbi/type_parser.rb#26
    sig { params(node: ::Prism::Node).returns(::RBI::Type) }
    def parse_node(node); end

    # : (String string) -> Type
    #
    # @raise [Error]
    #
    # source://rbi//lib/rbi/type_parser.rb#10
    sig { params(string: ::String).returns(::RBI::Type) }
    def parse_string(string); end

    # Builds a type that represents a proc type like `T.proc.void`.
    # : -> Proc
    #
    # source://rbi//lib/rbi/type.rb#679
    # Builds a type that represents a proc type like `T.proc.void`.
    sig { returns(::RBI::Type::Proc) }
    def proc; end

    # Builds a type that represents `T.self_type`.
    # : -> SelfType
    #
    # source://rbi//lib/rbi/type.rb#508
    # Builds a type that represents `T.self_type`.
    sig { returns(::RBI::Type::SelfType) }
    def self_type; end

    # Builds a type that represents a shape type like `{name: String, age: Integer}`.
    # : (?Hash[(String | Symbol), Type] types) -> Shape
    #
    # source://rbi//lib/rbi/type.rb#671
    # Builds a type that represents a shape type like `{name: String, age: Integer}`.
    sig { params(types: T::Hash[T.any(::String, ::Symbol), ::RBI::Type]).returns(::RBI::Type::Shape) }
    def shape(types = T.unsafe(nil)); end

    # Builds a simple type like `String` or `::Foo::Bar`.
    #
    # It raises a `NameError` if the name is not a valid Ruby class identifier.
    # : (String name) -> Simple
    #
    # @raise [NameError]
    #
    # source://rbi//lib/rbi/type.rb#473
    # Builds a simple type like `String` or `::Foo::Bar`.
    # It raises a `NameError` if the name is not a valid Ruby class identifier.
    sig { params(name: ::String).returns(::RBI::Type::Simple) }
    def simple(name); end

    # Builds a type that represents the class of another type like `T::Class[Foo]`.
    # : (Type type) -> Class
    #
    # source://rbi//lib/rbi/type.rb#528
    # Builds a type that represents the class of another type like `T::Class[Foo]`.
    sig { params(type: ::RBI::Type).returns(::RBI::Type::Class) }
    def t_class(type); end

    # Builds a type that represents a tuple type like `[String, Integer]`.
    # : (*(Type | Array[Type]) types) -> Tuple
    #
    # source://rbi//lib/rbi/type.rb#665
    # Builds a type that represents a tuple type like `[String, Integer]`.
    sig { params(types: T.any(::RBI::Type, T::Array[::RBI::Type])).returns(::RBI::Type::Tuple) }
    def tuple(*types); end

    # Builds a type that represents a type parameter like `T.type_parameter(:U)`.
    # : (Symbol name) -> TypeParameter
    #
    # source://rbi//lib/rbi/type.rb#657
    # Builds a type that represents a type parameter like `T.type_parameter(:U)`.
    sig { params(name: ::Symbol).returns(::RBI::Type::TypeParameter) }
    def type_parameter(name); end

    # Builds a type that represents `T.untyped`.
    # : -> Untyped
    #
    # source://rbi//lib/rbi/type.rb#514
    # Builds a type that represents `T.untyped`.
    sig { returns(::RBI::Type::Untyped) }
    def untyped; end

    # Builds a type that represents `void`.
    # : -> Void
    #
    # source://rbi//lib/rbi/type.rb#520
    # Builds a type that represents `void`.
    sig { returns(::RBI::Type::Void) }
    def void; end

    private

    # : (Prism::CallNode node) -> Array[Prism::Node]
    #
    # source://rbi//lib/rbi/type_parser.rb#263
    sig { params(node: ::Prism::CallNode).returns(T::Array[::Prism::Node]) }
    def call_chain(node); end

    # : (Prism::CallNode node, Integer count) -> Array[Prism::Node]
    #
    # source://rbi//lib/rbi/type_parser.rb#250
    sig { params(node: ::Prism::CallNode, count: ::Integer).returns(T::Array[::Prism::Node]) }
    def check_arguments_at_least!(node, count); end

    # : (Prism::CallNode node, Integer count) -> Array[Prism::Node]
    #
    # source://rbi//lib/rbi/type_parser.rb#235
    sig { params(node: ::Prism::CallNode, count: ::Integer).returns(T::Array[::Prism::Node]) }
    def check_arguments_exactly!(node, count); end

    # : (Prism::CallNode node) -> Type
    #
    # @raise [Error]
    #
    # source://rbi//lib/rbi/type_parser.rb#69
    sig { params(node: ::Prism::CallNode).returns(::RBI::Type) }
    def parse_call(node); end

    # : ((Prism::ConstantReadNode | Prism::ConstantPathNode) node) -> Type
    #
    # source://rbi//lib/rbi/type_parser.rb#52
    sig { params(node: T.any(::Prism::ConstantPathNode, ::Prism::ConstantReadNode)).returns(::RBI::Type) }
    def parse_constant(node); end

    # : (Prism::CallNode node) -> Type
    #
    # @raise [Error]
    #
    # source://rbi//lib/rbi/type_parser.rb#195
    sig { params(node: ::Prism::CallNode).returns(::RBI::Type) }
    def parse_proc(node); end

    # : ((Prism::HashNode | Prism::KeywordHashNode) node) -> Type
    #
    # source://rbi//lib/rbi/type_parser.rb#176
    sig { params(node: T.any(::Prism::HashNode, ::Prism::KeywordHashNode)).returns(::RBI::Type) }
    def parse_shape(node); end

    # : (Prism::ArrayNode node) -> Type
    #
    # source://rbi//lib/rbi/type_parser.rb#171
    sig { params(node: ::Prism::ArrayNode).returns(::RBI::Type) }
    def parse_tuple(node); end

    # : (Prism::Node? node) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type_parser.rb#276
    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t?(node); end

    # : (Prism::Node? node) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type_parser.rb#288
    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t_boolean?(node); end

    # : (Prism::ConstantPathNode node) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type_parser.rb#295
    sig { params(node: ::Prism::ConstantPathNode).returns(T::Boolean) }
    def t_class?(node); end

    # : (Prism::Node? node) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type_parser.rb#300
    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t_class_of?(node); end

    # : (Prism::CallNode node) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type_parser.rb#307
    sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
    def t_proc?(node); end

    # : (String name) -> bool
    #
    # @return [Boolean]
    #
    # source://rbi//lib/rbi/type.rb#689
    sig { params(name: ::String).returns(T::Boolean) }
    def valid_identifier?(name); end
  end
end

# A type that is intersection of multiple types like `T.all(String, Integer)`.
#
# source://rbi//lib/rbi/type.rb#252
class RBI::Type::All < ::RBI::Type::Composite
  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#255
  sig { override.returns(::String) }
  def to_rbi; end
end

# A type that is union of multiple types like `T.any(String, Integer)`.
#
# source://rbi//lib/rbi/type.rb#261
class RBI::Type::Any < ::RBI::Type::Composite
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/type.rb#269
  sig { returns(T::Boolean) }
  def nilable?; end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#264
  sig { override.returns(::String) }
  def to_rbi; end
end

# `T.anything`.
#
# source://rbi//lib/rbi/type.rb#43
class RBI::Type::Anything < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#46
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#52
  sig { override.returns(::String) }
  def to_rbi; end
end

# `T.attached_class`.
#
# source://rbi//lib/rbi/type.rb#58
class RBI::Type::AttachedClass < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#61
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#67
  sig { override.returns(::String) }
  def to_rbi; end
end

# `T::Boolean`.
#
# source://rbi//lib/rbi/type.rb#73
class RBI::Type::Boolean < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#76
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#82
  sig { override.returns(::String) }
  def to_rbi; end
end

# The class of another type like `T::Class[Foo]`.
#
# source://rbi//lib/rbi/type.rb#150
class RBI::Type::Class < ::RBI::Type
  # : (Type type) -> void
  #
  # @return [Class] a new instance of Class
  #
  # source://rbi//lib/rbi/type.rb#155
  sig { params(type: ::RBI::Type).void }
  def initialize(type); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#162
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#168
  sig { override.returns(::String) }
  def to_rbi; end

  # : Type
  #
  # source://rbi//lib/rbi/type.rb#152
  sig { returns(::RBI::Type) }
  def type; end
end

# The singleton class of another type like `T.class_of(Foo)`.
#
# source://rbi//lib/rbi/type.rb#174
class RBI::Type::ClassOf < ::RBI::Type
  # : (Simple type, ?Type? type_parameter) -> void
  #
  # @return [ClassOf] a new instance of ClassOf
  #
  # source://rbi//lib/rbi/type.rb#182
  sig { params(type: ::RBI::Type::Simple, type_parameter: T.nilable(::RBI::Type)).void }
  def initialize(type, type_parameter = T.unsafe(nil)); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#190
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#196
  sig { override.returns(::String) }
  def to_rbi; end

  # : Simple
  #
  # source://rbi//lib/rbi/type.rb#176
  sig { returns(::RBI::Type::Simple) }
  def type; end

  # : Type?
  #
  # source://rbi//lib/rbi/type.rb#179
  sig { returns(T.nilable(::RBI::Type)) }
  def type_parameter; end
end

# A type that is composed of multiple types like `T.all(String, Integer)`.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/type.rb#230
class RBI::Type::Composite < ::RBI::Type
  abstract!

  # : (Array[Type] types) -> void
  #
  # @return [Composite] a new instance of Composite
  #
  # source://rbi//lib/rbi/type.rb#239
  sig { params(types: T::Array[::RBI::Type]).void }
  def initialize(types); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#246
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : Array[Type]
  #
  # source://rbi//lib/rbi/type.rb#236
  sig { returns(T::Array[::RBI::Type]) }
  def types; end
end

# source://rbi//lib/rbi/type_parser.rb#6
class RBI::Type::Error < ::RBI::Error; end

# A generic type like `T::Array[String]` or `T::Hash[Symbol, Integer]`.
#
# source://rbi//lib/rbi/type.rb#277
class RBI::Type::Generic < ::RBI::Type
  # : (String name, *Type params) -> void
  #
  # @return [Generic] a new instance of Generic
  #
  # source://rbi//lib/rbi/type.rb#285
  sig { params(name: ::String, params: ::RBI::Type).void }
  def initialize(name, *params); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#293
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/type.rb#279
  sig { returns(::String) }
  def name; end

  # : Array[Type]
  #
  # source://rbi//lib/rbi/type.rb#282
  sig { returns(T::Array[::RBI::Type]) }
  def params; end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#299
  sig { override.returns(::String) }
  def to_rbi; end
end

# A type that can be `nil` like `T.nilable(String)`.
#
# source://rbi//lib/rbi/type.rb#206
class RBI::Type::Nilable < ::RBI::Type
  # : (Type type) -> void
  #
  # @return [Nilable] a new instance of Nilable
  #
  # source://rbi//lib/rbi/type.rb#211
  sig { params(type: ::RBI::Type).void }
  def initialize(type); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#218
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#224
  sig { override.returns(::String) }
  def to_rbi; end

  # : Type
  #
  # source://rbi//lib/rbi/type.rb#208
  sig { returns(::RBI::Type) }
  def type; end
end

# `T.noreturn`.
#
# source://rbi//lib/rbi/type.rb#88
class RBI::Type::NoReturn < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#91
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#97
  sig { override.returns(::String) }
  def to_rbi; end
end

# A proc type like `T.proc.void`.
#
# source://rbi//lib/rbi/type.rb#385
class RBI::Type::Proc < ::RBI::Type
  # : -> void
  #
  # @return [Proc] a new instance of Proc
  #
  # source://rbi//lib/rbi/type.rb#396
  sig { void }
  def initialize; end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#405
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : (untyped type) -> self
  #
  # source://rbi//lib/rbi/type.rb#433
  sig { params(type: T.untyped).returns(T.self_type) }
  def bind(type); end

  # : (**Type params) -> self
  #
  # source://rbi//lib/rbi/type.rb#415
  sig { params(params: ::RBI::Type).returns(T.self_type) }
  def params(**params); end

  # : Type?
  #
  # source://rbi//lib/rbi/type.rb#393
  sig { returns(T.nilable(::RBI::Type)) }
  def proc_bind; end

  # : Hash[Symbol, Type]
  #
  # source://rbi//lib/rbi/type.rb#387
  sig { returns(T::Hash[::Symbol, ::RBI::Type]) }
  def proc_params; end

  # : Type
  #
  # source://rbi//lib/rbi/type.rb#390
  sig { returns(::RBI::Type) }
  def proc_returns; end

  # : (untyped type) -> self
  #
  # source://rbi//lib/rbi/type.rb#421
  sig { params(type: T.untyped).returns(T.self_type) }
  def returns(type); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#440
  sig { override.returns(::String) }
  def to_rbi; end

  # : -> self
  #
  # source://rbi//lib/rbi/type.rb#427
  sig { returns(T.self_type) }
  def void; end
end

# `T.self_type`.
#
# source://rbi//lib/rbi/type.rb#103
class RBI::Type::SelfType < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#106
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#112
  sig { override.returns(::String) }
  def to_rbi; end
end

# A shape type like `{name: String, age: Integer}`.
#
# source://rbi//lib/rbi/type.rb#355
class RBI::Type::Shape < ::RBI::Type
  # : (Hash[(String | Symbol), Type] types) -> void
  #
  # @return [Shape] a new instance of Shape
  #
  # source://rbi//lib/rbi/type.rb#360
  sig { params(types: T::Hash[T.any(::String, ::Symbol), ::RBI::Type]).void }
  def initialize(types); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#367
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#373
  sig { override.returns(::String) }
  def to_rbi; end

  # : Hash[(String | Symbol), Type]
  #
  # source://rbi//lib/rbi/type.rb#357
  sig { returns(T::Hash[T.any(::String, ::Symbol), ::RBI::Type]) }
  def types; end
end

# A type that represents a simple class name like `String` or `Foo`.
#
# It can also be a qualified name like `::Foo` or `Foo::Bar`.
#
# source://rbi//lib/rbi/type.rb#17
# A type that represents a simple class name like `String` or `Foo`.
class RBI::Type::Simple < ::RBI::Type
  # : (String name) -> void
  #
  # @return [Simple] a new instance of Simple
  #
  # source://rbi//lib/rbi/type.rb#22
  sig { params(name: ::String).void }
  def initialize(name); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#29
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : String
  #
  # source://rbi//lib/rbi/type.rb#19
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#35
  sig { override.returns(::String) }
  def to_rbi; end
end

# A tuple type like `[String, Integer]`.
#
# source://rbi//lib/rbi/type.rb#331
class RBI::Type::Tuple < ::RBI::Type
  # : (Array[Type] types) -> void
  #
  # @return [Tuple] a new instance of Tuple
  #
  # source://rbi//lib/rbi/type.rb#336
  sig { params(types: T::Array[::RBI::Type]).void }
  def initialize(types); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#343
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#349
  sig { override.returns(::String) }
  def to_rbi; end

  # : Array[Type]
  #
  # source://rbi//lib/rbi/type.rb#333
  sig { returns(T::Array[::RBI::Type]) }
  def types; end
end

# A type parameter like `T.type_parameter(:U)`.
#
# source://rbi//lib/rbi/type.rb#305
class RBI::Type::TypeParameter < ::RBI::Type
  # : (Symbol name) -> void
  #
  # @return [TypeParameter] a new instance of TypeParameter
  #
  # source://rbi//lib/rbi/type.rb#310
  sig { params(name: ::Symbol).void }
  def initialize(name); end

  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#317
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : Symbol
  #
  # source://rbi//lib/rbi/type.rb#307
  sig { returns(::Symbol) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#323
  sig { override.returns(::String) }
  def to_rbi; end
end

# `T.untyped`.
#
# source://rbi//lib/rbi/type.rb#118
class RBI::Type::Untyped < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#121
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#127
  sig { override.returns(::String) }
  def to_rbi; end
end

# source://rbi//lib/rbi/type_visitor.rb#6
class RBI::Type::Visitor
  # : (Type node) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#10
  sig { params(node: ::RBI::Type).void }
  def visit(node); end

  private

  # : (Type::All type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#56
  sig { params(type: ::RBI::Type::All).void }
  def visit_all(type); end

  # : (Type::Any type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#59
  sig { params(type: ::RBI::Type::Any).void }
  def visit_any(type); end

  # : (Type::Anything type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#62
  sig { params(type: ::RBI::Type::Anything).void }
  def visit_anything(type); end

  # : (Type::AttachedClass type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#65
  sig { params(type: ::RBI::Type::AttachedClass).void }
  def visit_attached_class(type); end

  # : (Type::Boolean type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#68
  sig { params(type: ::RBI::Type::Boolean).void }
  def visit_boolean(type); end

  # : (Type::Class type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#71
  sig { params(type: ::RBI::Type::Class).void }
  def visit_class(type); end

  # : (Type::ClassOf type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#74
  sig { params(type: ::RBI::Type::ClassOf).void }
  def visit_class_of(type); end

  # : (Type::Generic type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#77
  sig { params(type: ::RBI::Type::Generic).void }
  def visit_generic(type); end

  # : (Type::Nilable type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#80
  sig { params(type: ::RBI::Type::Nilable).void }
  def visit_nilable(type); end

  # : (Type::NoReturn type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#86
  sig { params(type: ::RBI::Type::NoReturn).void }
  def visit_no_return(type); end

  # : (Type::Proc type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#89
  sig { params(type: ::RBI::Type::Proc).void }
  def visit_proc(type); end

  # : (Type::SelfType type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#92
  sig { params(type: ::RBI::Type::SelfType).void }
  def visit_self_type(type); end

  # : (Type::Shape type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#98
  sig { params(type: ::RBI::Type::Shape).void }
  def visit_shape(type); end

  # : (Type::Simple type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#83
  sig { params(type: ::RBI::Type::Simple).void }
  def visit_simple(type); end

  # : (Type::Tuple type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#101
  sig { params(type: ::RBI::Type::Tuple).void }
  def visit_tuple(type); end

  # : (Type::TypeParameter type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#104
  sig { params(type: ::RBI::Type::TypeParameter).void }
  def visit_type_parameter(type); end

  # : (Type::Untyped type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#107
  sig { params(type: ::RBI::Type::Untyped).void }
  def visit_untyped(type); end

  # : (Type::Void type) -> void
  #
  # source://rbi//lib/rbi/type_visitor.rb#95
  sig { params(type: ::RBI::Type::Void).void }
  def visit_void(type); end
end

# source://rbi//lib/rbi/type_visitor.rb#7
class RBI::Type::Visitor::Error < ::RBI::Error; end

# `void`.
#
# source://rbi//lib/rbi/type.rb#133
class RBI::Type::Void < ::RBI::Type
  # : (BasicObject other) -> bool
  #
  # source://rbi//lib/rbi/type.rb#136
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # : -> String
  #
  # source://rbi//lib/rbi/type.rb#142
  sig { override.returns(::String) }
  def to_rbi; end
end

# source://rbi//lib/rbi/model.rb#1060
class RBI::TypeMember < ::RBI::NodeWithComments
  include ::RBI::Indexable

  # : (String name, String value, ?loc: Loc?, ?comments: Array[Comment]) ?{ (TypeMember node) -> void } -> void
  #
  # @return [TypeMember] a new instance of TypeMember
  #
  # source://rbi//lib/rbi/model.rb#1065
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TypeMember).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1073
  sig { returns(::String) }
  def fully_qualified_name; end

  # : -> Array[String]
  #
  # source://rbi//lib/rbi/index.rb#179
  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#1062
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://rbi//lib/rbi/model.rb#1081
  sig { override.returns(::String) }
  def to_s; end

  # : String
  #
  # source://rbi//lib/rbi/model.rb#1062
  # @return [String]
  def value; end
end

# source://rbi//lib/rbi/rbs_printer.rb#879
class RBI::TypePrinter
  # : -> void
  #
  # @return [TypePrinter] a new instance of TypePrinter
  #
  # source://rbi//lib/rbi/rbs_printer.rb#884
  sig { void }
  def initialize; end

  # : String
  #
  # source://rbi//lib/rbi/rbs_printer.rb#881
  sig { returns(::String) }
  def string; end

  # : (Type node) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#889
  sig { params(node: ::RBI::Type).void }
  def visit(node); end

  # : (Type::All type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1004
  sig { params(type: ::RBI::Type::All).void }
  def visit_all(type); end

  # : (Type::Any type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1014
  sig { params(type: ::RBI::Type::Any).void }
  def visit_any(type); end

  # : (Type::Anything type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#954
  sig { params(type: ::RBI::Type::Anything).void }
  def visit_anything(type); end

  # : (Type::AttachedClass type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#979
  sig { params(type: ::RBI::Type::AttachedClass).void }
  def visit_attached_class(type); end

  # : (Type::Boolean type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#938
  sig { params(type: ::RBI::Type::Boolean).void }
  def visit_boolean(type); end

  # : (Type::Class type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1081
  sig { params(type: ::RBI::Type::Class).void }
  def visit_class(type); end

  # : (Type::ClassOf type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#997
  sig { params(type: ::RBI::Type::ClassOf).void }
  def visit_class_of(type); end

  # : (Type::Generic type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#943
  sig { params(type: ::RBI::Type::Generic).void }
  def visit_generic(type); end

  # : (Type::Nilable type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#984
  sig { params(type: ::RBI::Type::Nilable).void }
  def visit_nilable(type); end

  # : (Type::NoReturn type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#964
  sig { params(type: ::RBI::Type::NoReturn).void }
  def visit_no_return(type); end

  # : (Type::Proc type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1054
  sig { params(type: ::RBI::Type::Proc).void }
  def visit_proc(type); end

  # : (Type::SelfType type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#974
  sig { params(type: ::RBI::Type::SelfType).void }
  def visit_self_type(type); end

  # : (Type::Shape type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1034
  sig { params(type: ::RBI::Type::Shape).void }
  def visit_shape(type); end

  # : (Type::Simple type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#933
  sig { params(type: ::RBI::Type::Simple).void }
  def visit_simple(type); end

  # : (Type::Tuple type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1024
  sig { params(type: ::RBI::Type::Tuple).void }
  def visit_tuple(type); end

  # : (Type::TypeParameter type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1076
  sig { params(type: ::RBI::Type::TypeParameter).void }
  def visit_type_parameter(type); end

  # : (Type::Untyped type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#969
  sig { params(type: ::RBI::Type::Untyped).void }
  def visit_untyped(type); end

  # : (Type::Void type) -> void
  #
  # source://rbi//lib/rbi/rbs_printer.rb#959
  sig { params(type: ::RBI::Type::Void).void }
  def visit_void(type); end

  private

  # : (String type_name) -> String
  #
  # source://rbi//lib/rbi/rbs_printer.rb#1090
  sig { params(type_name: ::String).returns(::String) }
  def translate_t_type(type_name); end
end

# source://rbi//lib/rbi/rewriters/attr_to_methods.rb#5
class RBI::UnexpectedMultipleSigsError < ::RBI::Error
  # : (Node node) -> void
  #
  # @return [UnexpectedMultipleSigsError] a new instance of UnexpectedMultipleSigsError
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#10
  sig { params(node: ::RBI::Node).void }
  def initialize(node); end

  # : Node
  #
  # source://rbi//lib/rbi/rewriters/attr_to_methods.rb#7
  sig { returns(::RBI::Node) }
  def node; end
end

# source://rbi//lib/rbi/parser.rb#18
class RBI::UnexpectedParserError < ::RBI::Error
  # : (Exception parent_exception, Loc last_location) -> void
  #
  # @return [UnexpectedParserError] a new instance of UnexpectedParserError
  #
  # source://rbi//lib/rbi/parser.rb#23
  sig { params(parent_exception: ::Exception, last_location: ::RBI::Loc).void }
  def initialize(parent_exception, last_location); end

  # : Loc
  #
  # source://rbi//lib/rbi/parser.rb#20
  sig { returns(::RBI::Loc) }
  def last_location; end

  # : (?io: (IO | StringIO)) -> void
  #
  # source://rbi//lib/rbi/parser.rb#30
  sig { params(io: T.any(::IO, ::StringIO)).void }
  def print_debug(io: T.unsafe(nil)); end
end

# source://rbi//lib/rbi/version.rb#5
RBI::VERSION = T.let(T.unsafe(nil), String)

# Visibility
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/model.rb#708
class RBI::Visibility < ::RBI::NodeWithComments
  abstract!

  # : (Symbol visibility, ?loc: Loc?, ?comments: Array[Comment]) -> void
  #
  # @return [Visibility] a new instance of Visibility
  #
  # source://rbi//lib/rbi/model.rb#717
  sig { params(visibility: ::Symbol, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(visibility, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : (Object? other) -> bool
  #
  # source://rbi//lib/rbi/model.rb#723
  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/model.rb#740
  sig { returns(T::Boolean) }
  def private?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/model.rb#735
  sig { returns(T::Boolean) }
  def protected?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://rbi//lib/rbi/model.rb#730
  sig { returns(T::Boolean) }
  def public?; end

  # : Symbol
  #
  # source://rbi//lib/rbi/model.rb#714
  sig { returns(::Symbol) }
  def visibility; end
end

# source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#49
class RBI::VisibilityGroup < ::RBI::Tree
  # : (Visibility visibility) -> void
  #
  # @return [VisibilityGroup] a new instance of VisibilityGroup
  #
  # source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#54
  sig { params(visibility: ::RBI::Visibility).void }
  def initialize(visibility); end

  # : Visibility
  #
  # source://rbi//lib/rbi/rewriters/nest_non_public_members.rb#51
  sig { returns(::RBI::Visibility) }
  def visibility; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://rbi//lib/rbi/visitor.rb#7
class RBI::Visitor
  abstract!

  # : (Node? node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#13
  sig { params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  # : (Array[Node] nodes) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#109
  sig { params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  # : (File file) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#114
  sig { params(file: ::RBI::File).void }
  def visit_file(file); end

  private

  # : (Arg node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#199
  sig { params(node: ::RBI::Arg).void }
  def visit_arg(node); end

  # : (AttrAccessor node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#148
  sig { params(node: ::RBI::AttrAccessor).void }
  def visit_attr_accessor(node); end

  # : (AttrReader node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#151
  sig { params(node: ::RBI::AttrReader).void }
  def visit_attr_reader(node); end

  # : (AttrWriter node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#154
  sig { params(node: ::RBI::AttrWriter).void }
  def visit_attr_writer(node); end

  # : (BlankLine node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#127
  sig { params(node: ::RBI::BlankLine).void }
  def visit_blank_line(node); end

  # : (BlockParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#178
  sig { params(node: ::RBI::BlockParam).void }
  def visit_block_param(node); end

  # : (Class node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#133
  sig { params(node: ::RBI::Class).void }
  def visit_class(node); end

  # : (Comment node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#121
  sig { params(node: ::RBI::Comment).void }
  def visit_comment(node); end

  # : (ConflictTree node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#244
  sig { params(node: ::RBI::ConflictTree).void }
  def visit_conflict_tree(node); end

  # : (Const node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#145
  sig { params(node: ::RBI::Const).void }
  def visit_const(node); end

  # : (Extend node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#184
  sig { params(node: ::RBI::Extend).void }
  def visit_extend(node); end

  # : (Group node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#238
  sig { params(node: ::RBI::Group).void }
  def visit_group(node); end

  # : (Helper node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#226
  sig { params(node: ::RBI::Helper).void }
  def visit_helper(node); end

  # : (Include node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#181
  sig { params(node: ::RBI::Include).void }
  def visit_include(node); end

  # : (KwArg node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#202
  sig { params(node: ::RBI::KwArg).void }
  def visit_kw_arg(node); end

  # : (KwOptParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#172
  sig { params(node: ::RBI::KwOptParam).void }
  def visit_kw_opt_param(node); end

  # : (KwParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#169
  sig { params(node: ::RBI::KwParam).void }
  def visit_kw_param(node); end

  # : (KwRestParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#175
  sig { params(node: ::RBI::KwRestParam).void }
  def visit_kw_rest_param(node); end

  # : (Method node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#157
  sig { params(node: ::RBI::Method).void }
  def visit_method(node); end

  # : (MixesInClassMethods node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#232
  sig { params(node: ::RBI::MixesInClassMethods).void }
  def visit_mixes_in_class_methods(node); end

  # : (Module node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#130
  sig { params(node: ::RBI::Module).void }
  def visit_module(node); end

  # : (OptParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#163
  sig { params(node: ::RBI::OptParam).void }
  def visit_opt_param(node); end

  # : (Private node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#193
  sig { params(node: ::RBI::Private).void }
  def visit_private(node); end

  # : (Protected node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#190
  sig { params(node: ::RBI::Protected).void }
  def visit_protected(node); end

  # : (Public node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#187
  sig { params(node: ::RBI::Public).void }
  def visit_public(node); end

  # : (RBSComment node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#124
  sig { params(node: ::RBI::RBSComment).void }
  def visit_rbs_comment(node); end

  # : (ReqParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#160
  sig { params(node: ::RBI::ReqParam).void }
  def visit_req_param(node); end

  # : (RequiresAncestor node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#235
  sig { params(node: ::RBI::RequiresAncestor).void }
  def visit_requires_ancestor(node); end

  # : (RestParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#166
  sig { params(node: ::RBI::RestParam).void }
  def visit_rest_param(node); end

  # : (ScopeConflict node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#247
  sig { params(node: ::RBI::ScopeConflict).void }
  def visit_scope_conflict(node); end

  # : (Send node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#196
  sig { params(node: ::RBI::Send).void }
  def visit_send(node); end

  # : (Sig node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#205
  sig { params(node: ::RBI::Sig).void }
  def visit_sig(node); end

  # : (SigParam node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#208
  sig { params(node: ::RBI::SigParam).void }
  def visit_sig_param(node); end

  # : (SingletonClass node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#136
  sig { params(node: ::RBI::SingletonClass).void }
  def visit_singleton_class(node); end

  # : (Struct node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#139
  sig { params(node: ::RBI::Struct).void }
  def visit_struct(node); end

  # : (TEnum node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#220
  sig { params(node: ::RBI::TEnum).void }
  def visit_tenum(node); end

  # : (TEnumBlock node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#223
  sig { params(node: ::RBI::TEnumBlock).void }
  def visit_tenum_block(node); end

  # : (Tree node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#142
  sig { params(node: ::RBI::Tree).void }
  def visit_tree(node); end

  # : (TStruct node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#211
  sig { params(node: ::RBI::TStruct).void }
  def visit_tstruct(node); end

  # : (TStructConst node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#214
  sig { params(node: ::RBI::TStructConst).void }
  def visit_tstruct_const(node); end

  # : (TStructProp node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#217
  sig { params(node: ::RBI::TStructProp).void }
  def visit_tstruct_prop(node); end

  # : (TypeMember node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#229
  sig { params(node: ::RBI::TypeMember).void }
  def visit_type_member(node); end

  # : (VisibilityGroup node) -> void
  #
  # source://rbi//lib/rbi/visitor.rb#241
  sig { params(node: ::RBI::VisibilityGroup).void }
  def visit_visibility_group(node); end
end

# source://rbi//lib/rbi/visitor.rb#5
class RBI::VisitorError < ::RBI::Error; end
