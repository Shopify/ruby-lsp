# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.

# The Prism Ruby parser.
#
# "Parsing Ruby is suddenly manageable!"
#   - You, hopefully
#
# source://prism//lib/prism.rb#8
module Prism
  class << self
    # Mirror the Prism.dump API by using the serialization API.
    def dump(*_arg0); end

    # Mirror the Prism.dump_file API by using the serialization API.
    def dump_file(*_arg0); end

    # Mirror the Prism.lex API by using the serialization API.
    def lex(*_arg0); end

    # :call-seq:
    #   Prism::lex_compat(source, **options) -> ParseResult
    #
    # Returns a parse result whose value is an array of tokens that closely
    # resembles the return value of Ripper::lex. The main difference is that the
    # `:on_sp` token is not emitted.
    #
    # For supported options, see Prism::parse.
    #
    # source://prism//lib/prism.rb#46
    def lex_compat(source, **options); end

    # Mirror the Prism.lex_file API by using the serialization API.
    def lex_file(*_arg0); end

    # :call-seq:
    #   Prism::lex_ripper(source) -> Array
    #
    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # source://prism//lib/prism.rb#56
    def lex_ripper(source); end

    # :call-seq:
    #   Prism::load(source, serialized) -> ParseResult
    #
    # Load the serialized AST using the source as a reference into a tree.
    #
    # source://prism//lib/prism.rb#64
    def load(source, serialized); end

    # Mirror the Prism.parse API by using the serialization API.
    def parse(*_arg0); end

    # Mirror the Prism.parse_comments API by using the serialization API.
    def parse_comments(*_arg0); end

    # :call-seq:
    #   Prism::parse_failure?(source, **options) -> bool
    #
    # Returns true if the source parses with errors.
    #
    # @return [Boolean]
    #
    # source://prism//lib/prism.rb#72
    def parse_failure?(source, **options); end

    # Mirror the Prism.parse_file API by using the serialization API. This uses
    # native strings instead of Ruby strings because it allows us to use mmap
    # when it is available.
    def parse_file(*_arg0); end

    # Mirror the Prism.parse_file_comments API by using the serialization
    # API. This uses native strings instead of Ruby strings because it allows us
    # to use mmap when it is available.
    def parse_file_comments(*_arg0); end

    # :call-seq:
    #   Prism::parse_file_failure?(filepath, **options) -> bool
    #
    # Returns true if the file at filepath parses with errors.
    #
    # @return [Boolean]
    #
    # source://prism//lib/prism.rb#80
    def parse_file_failure?(filepath, **options); end

    # Mirror the Prism.parse_file_success? API by using the serialization API.
    #
    # @return [Boolean]
    def parse_file_success?(*_arg0); end

    # Mirror the Prism.parse_lex API by using the serialization API.
    def parse_lex(*_arg0); end

    # Mirror the Prism.parse_lex_file API by using the serialization API.
    def parse_lex_file(*_arg0); end

    # Mirror the Prism.parse_stream API by using the serialization API.
    def parse_stream(*_arg0); end

    # Mirror the Prism.parse_success? API by using the serialization API.
    #
    # @return [Boolean]
    def parse_success?(*_arg0); end
  end
end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#119
class Prism::AliasGlobalVariableNode < ::Prism::Node
  # def initialize: (Prism::node new_name, Prism::node old_name, Location keyword_loc, Location location) -> void
  #
  # @return [AliasGlobalVariableNode] a new instance of AliasGlobalVariableNode
  #
  # source://prism//lib/prism/node.rb#121
  def initialize(source, new_name, old_name, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#131
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#136
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#146
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#141
  def compact_child_nodes; end

  # def copy: (?new_name: Prism::node, ?old_name: Prism::node, ?keyword_loc: Location, ?location: Location) -> AliasGlobalVariableNode
  #
  # source://prism//lib/prism/node.rb#151
  def copy(new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#136
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { new_name: Prism::node, old_name: Prism::node, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#159
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#183
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#178
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#170
  def keyword_loc; end

  # attr_reader new_name: Prism::node
  #
  # source://prism//lib/prism/node.rb#164
  def new_name; end

  # attr_reader old_name: Prism::node
  #
  # source://prism//lib/prism/node.rb#167
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#207
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#217
    def type; end
  end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#226
class Prism::AliasMethodNode < ::Prism::Node
  # def initialize: (Prism::node new_name, Prism::node old_name, Location keyword_loc, Location location) -> void
  #
  # @return [AliasMethodNode] a new instance of AliasMethodNode
  #
  # source://prism//lib/prism/node.rb#228
  def initialize(source, new_name, old_name, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#238
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#243
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#253
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#248
  def compact_child_nodes; end

  # def copy: (?new_name: Prism::node, ?old_name: Prism::node, ?keyword_loc: Location, ?location: Location) -> AliasMethodNode
  #
  # source://prism//lib/prism/node.rb#258
  def copy(new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#243
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { new_name: Prism::node, old_name: Prism::node, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#266
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#290
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#285
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#277
  def keyword_loc; end

  # attr_reader new_name: Prism::node
  #
  # source://prism//lib/prism/node.rb#271
  def new_name; end

  # attr_reader old_name: Prism::node
  #
  # source://prism//lib/prism/node.rb#274
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#314
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#324
    def type; end
  end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#333
class Prism::AlternationPatternNode < ::Prism::Node
  # def initialize: (Prism::node left, Prism::node right, Location operator_loc, Location location) -> void
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # source://prism//lib/prism/node.rb#335
  def initialize(source, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#345
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#350
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#360
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#355
  def compact_child_nodes; end

  # def copy: (?left: Prism::node, ?right: Prism::node, ?operator_loc: Location, ?location: Location) -> AlternationPatternNode
  #
  # source://prism//lib/prism/node.rb#365
  def copy(left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#350
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Prism::node, right: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#373
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#397
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Prism::node
  #
  # source://prism//lib/prism/node.rb#378
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#392
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#384
  def operator_loc; end

  # attr_reader right: Prism::node
  #
  # source://prism//lib/prism/node.rb#381
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#421
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#431
    def type; end
  end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#440
class Prism::AndNode < ::Prism::Node
  # def initialize: (Prism::node left, Prism::node right, Location operator_loc, Location location) -> void
  #
  # @return [AndNode] a new instance of AndNode
  #
  # source://prism//lib/prism/node.rb#442
  def initialize(source, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#452
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#457
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#467
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#462
  def compact_child_nodes; end

  # def copy: (?left: Prism::node, ?right: Prism::node, ?operator_loc: Location, ?location: Location) -> AndNode
  #
  # source://prism//lib/prism/node.rb#472
  def copy(left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#457
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Prism::node, right: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#480
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#519
  def inspect(inspector = T.unsafe(nil)); end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left and right
  #     ^^^^
  #
  #     1 && 2
  #     ^
  #
  # source://prism//lib/prism/node.rb#491
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#514
  def operator; end

  # The location of the `and` keyword or the `&&` operator.
  #
  #     left and right
  #          ^^^
  #
  # source://prism//lib/prism/node.rb#506
  def operator_loc; end

  # Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left && right
  #             ^^^^^
  #
  #     1 and 2
  #           ^
  #
  # source://prism//lib/prism/node.rb#500
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#543
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#553
    def type; end
  end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#562
class Prism::ArgumentsNode < ::Prism::Node
  # def initialize: (Integer flags, Array[Prism::node] arguments, Location location) -> void
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # source://prism//lib/prism/node.rb#564
  def initialize(source, flags, arguments, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#573
  def accept(visitor); end

  # attr_reader arguments: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#610
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#578
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#588
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#583
  def compact_child_nodes; end

  # def contains_keyword_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#614
  def contains_keyword_splat?; end

  # def copy: (?flags: Integer, ?arguments: Array[Prism::node], ?location: Location) -> ArgumentsNode
  #
  # source://prism//lib/prism/node.rb#593
  def copy(flags: T.unsafe(nil), arguments: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#578
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, arguments: Array[Prism::node], location: Location }
  #
  # source://prism//lib/prism/node.rb#601
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#619
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#641
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#606
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#651
    def type; end
  end
end

# Flags for arguments nodes.
#
# source://prism//lib/prism/node.rb#18814
module Prism::ArgumentsNodeFlags; end

# if arguments contain keyword splat
#
# source://prism//lib/prism/node.rb#18816
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORD_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#660
class Prism::ArrayNode < ::Prism::Node
  # def initialize: (Integer flags, Array[Prism::node] elements, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # source://prism//lib/prism/node.rb#662
  def initialize(source, flags, elements, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#673
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#678
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#750
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#726
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#688
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#683
  def compact_child_nodes; end

  # def contains_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#740
  def contains_splat?; end

  # def copy: (?flags: Integer, ?elements: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?, ?location: Location) -> ArrayNode
  #
  # source://prism//lib/prism/node.rb#693
  def copy(flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#678
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, elements: Array[Prism::node], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#701
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#710
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#755
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#745
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#713
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#779
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#706
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#789
    def type; end
  end
end

# Flags for array nodes.
#
# source://prism//lib/prism/node.rb#18820
module Prism::ArrayNodeFlags; end

# if array contains splat nodes
#
# source://prism//lib/prism/node.rb#18822
Prism::ArrayNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#810
class Prism::ArrayPatternNode < ::Prism::Node
  # def initialize: (Prism::node? constant, Array[Prism::node] requireds, Prism::node? rest, Array[Prism::node] posts, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # source://prism//lib/prism/node.rb#812
  def initialize(source, constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#825
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#830
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#907
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#888
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#845
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#835
  def compact_child_nodes; end

  # attr_reader constant: Prism::node?
  #
  # source://prism//lib/prism/node.rb#863
  def constant; end

  # def copy: (?constant: Prism::node?, ?requireds: Array[Prism::node], ?rest: Prism::node?, ?posts: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?, ?location: Location) -> ArrayPatternNode
  #
  # source://prism//lib/prism/node.rb#850
  def copy(constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#830
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Prism::node?, requireds: Array[Prism::node], rest: Prism::node?, posts: Array[Prism::node], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#858
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#912
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#902
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#875
  def opening_loc; end

  # attr_reader posts: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#872
  def posts; end

  # attr_reader requireds: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#866
  def requireds; end

  # attr_reader rest: Prism::node?
  #
  # source://prism//lib/prism/node.rb#869
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#947
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#957
    def type; end
  end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# source://prism//lib/prism/node.rb#966
class Prism::AssocNode < ::Prism::Node
  # def initialize: (Prism::node key, Prism::node value, Location? operator_loc, Location location) -> void
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # source://prism//lib/prism/node.rb#968
  def initialize(source, key, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#978
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#983
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#993
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#988
  def compact_child_nodes; end

  # def copy: (?key: Prism::node, ?value: Prism::node, ?operator_loc: Location?, ?location: Location) -> AssocNode
  #
  # source://prism//lib/prism/node.rb#998
  def copy(key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#983
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { key: Prism::node, value: Prism::node, operator_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#1006
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1054
  def inspect(inspector = T.unsafe(nil)); end

  # The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { a: b }
  #       ^
  #
  #     { foo => bar }
  #       ^^^
  #
  #     { def a; end => 1 }
  #       ^^^^^^^^^^
  #
  # source://prism//lib/prism/node.rb#1020
  def key; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#1049
  def operator; end

  # The location of the `=>` operator, if present.
  #
  #     { foo => bar }
  #           ^^
  #
  # source://prism//lib/prism/node.rb#1035
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1078
  def type; end

  # The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { foo => bar }
  #              ^^^
  #
  #     { x: 1 }
  #          ^
  #
  # source://prism//lib/prism/node.rb#1029
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1088
    def type; end
  end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# source://prism//lib/prism/node.rb#1097
class Prism::AssocSplatNode < ::Prism::Node
  # def initialize: (Prism::node? value, Location operator_loc, Location location) -> void
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # source://prism//lib/prism/node.rb#1099
  def initialize(source, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1108
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1113
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1125
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1118
  def compact_child_nodes; end

  # def copy: (?value: Prism::node?, ?operator_loc: Location, ?location: Location) -> AssocSplatNode
  #
  # source://prism//lib/prism/node.rb#1130
  def copy(value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1113
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Prism::node?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#1138
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1165
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#1160
  def operator; end

  # The location of the `**` operator.
  #
  #     { **x }
  #       ^^
  #
  # source://prism//lib/prism/node.rb#1152
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1191
  def type; end

  # The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.
  #
  #     { **foo }
  #         ^^^
  #
  # source://prism//lib/prism/node.rb#1146
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1201
    def type; end
  end
end

# The FFI backend is used on other Ruby implementations.
#
# source://prism//lib/prism.rb#99
Prism::BACKEND = T.let(T.unsafe(nil), Symbol)

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# source://prism//lib/prism/node.rb#1210
class Prism::BackReferenceReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#1212
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1220
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1225
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1235
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1230
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> BackReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#1240
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1225
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#1248
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1261
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the back-reference variable, including the leading `$`.
  #
  #     $& # name `:$&`
  #
  #     $+ # name `:$+`
  #
  # source://prism//lib/prism/node.rb#1257
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1281
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1291
    def type; end
  end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# source://prism//lib/prism/visitor.rb#14
class Prism::BasicVisitor
  # Calls `accept` on the given node if it is not `nil`, which in turn should
  # call back into this visitor by calling the appropriate `visit_*` method.
  #
  # source://prism//lib/prism/visitor.rb#17
  def visit(node); end

  # Visits each node in `nodes` by calling `accept` on each one.
  #
  # source://prism//lib/prism/visitor.rb#23
  def visit_all(nodes); end

  # Visits the child nodes of `node` by calling `accept` on each one.
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# source://prism//lib/prism/node.rb#1302
class Prism::BeginNode < ::Prism::Node
  # def initialize: (Location? begin_keyword_loc, StatementsNode? statements, RescueNode? rescue_clause, ElseNode? else_clause, EnsureNode? ensure_clause, Location? end_keyword_loc, Location location) -> void
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # source://prism//lib/prism/node.rb#1304
  def initialize(source, begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1317
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#1398
  def begin_keyword; end

  # attr_reader begin_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1359
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1326
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1341
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1331
  def compact_child_nodes; end

  # def copy: (?begin_keyword_loc: Location?, ?statements: StatementsNode?, ?rescue_clause: RescueNode?, ?else_clause: ElseNode?, ?ensure_clause: EnsureNode?, ?end_keyword_loc: Location?, ?location: Location) -> BeginNode
  #
  # source://prism//lib/prism/node.rb#1346
  def copy(begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1326
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#1354
  def deconstruct_keys(keys); end

  # attr_reader else_clause: ElseNode?
  #
  # source://prism//lib/prism/node.rb#1378
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#1403
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1384
  def end_keyword_loc; end

  # attr_reader ensure_clause: EnsureNode?
  #
  # source://prism//lib/prism/node.rb#1381
  def ensure_clause; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1408
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader rescue_clause: RescueNode?
  #
  # source://prism//lib/prism/node.rb#1375
  def rescue_clause; end

  # source://prism//lib/prism/node.rb#1321
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#1372
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1453
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1463
    def type; end
  end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1472
class Prism::BlockArgumentNode < ::Prism::Node
  # def initialize: (Prism::node? expression, Location operator_loc, Location location) -> void
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # source://prism//lib/prism/node.rb#1474
  def initialize(source, expression, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1483
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1488
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1500
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1493
  def compact_child_nodes; end

  # def copy: (?expression: Prism::node?, ?operator_loc: Location, ?location: Location) -> BlockArgumentNode
  #
  # source://prism//lib/prism/node.rb#1505
  def copy(expression: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1488
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Prism::node?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#1513
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node?
  #
  # source://prism//lib/prism/node.rb#1518
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1534
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#1529
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#1521
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1560
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1570
    def type; end
  end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
#
# source://prism//lib/prism/node.rb#1579
class Prism::BlockLocalVariableNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location location) -> void
  #
  # @return [BlockLocalVariableNode] a new instance of BlockLocalVariableNode
  #
  # source://prism//lib/prism/node.rb#1581
  def initialize(source, flags, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1590
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1595
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1605
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1600
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol, ?location: Location) -> BlockLocalVariableNode
  #
  # source://prism//lib/prism/node.rb#1610
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1595
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#1618
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1636
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#1627
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#1631
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1658
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#1623
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1668
    def type; end
  end
end

# Represents a block of ruby code.
#
#     [1, 2, 3].each { |i| puts x }
#                    ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#1677
class Prism::BlockNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Prism::node? parameters, Prism::node? body, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # source://prism//lib/prism/node.rb#1679
  def initialize(source, locals, parameters, body, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1691
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#1733
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1696
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#1756
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#1743
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1709
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1701
  def compact_child_nodes; end

  # def copy: (?locals: Array[Symbol], ?parameters: Prism::node?, ?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location, ?location: Location) -> BlockNode
  #
  # source://prism//lib/prism/node.rb#1714
  def copy(locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1696
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], parameters: Prism::node?, body: Prism::node?, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#1722
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1761
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#1727
  def locals; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#1751
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#1736
  def opening_loc; end

  # attr_reader parameters: Prism::node?
  #
  # source://prism//lib/prism/node.rb#1730
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1795
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1805
    def type; end
  end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#1815
class Prism::BlockParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # source://prism//lib/prism/node.rb#1817
  def initialize(source, flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1828
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1833
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1843
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1838
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location, ?location: Location) -> BlockParameterNode
  #
  # source://prism//lib/prism/node.rb#1848
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1833
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#1856
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#1899
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#1865
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#1868
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#1894
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#1881
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#1889
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#1927
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#1861
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#1937
    def type; end
  end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#1950
class Prism::BlockParametersNode < ::Prism::Node
  # def initialize: (ParametersNode? parameters, Array[BlockLocalVariableNode] locals, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # source://prism//lib/prism/node.rb#1952
  def initialize(source, parameters, locals, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#1963
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1968
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#2037
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2018
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#1981
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#1973
  def compact_child_nodes; end

  # def copy: (?parameters: ParametersNode?, ?locals: Array[BlockLocalVariableNode], ?opening_loc: Location?, ?closing_loc: Location?, ?location: Location) -> BlockParametersNode
  #
  # source://prism//lib/prism/node.rb#1986
  def copy(parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#1968
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parameters: ParametersNode?, locals: Array[BlockLocalVariableNode], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#1994
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2042
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[BlockLocalVariableNode]
  #
  # source://prism//lib/prism/node.rb#2002
  def locals; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#2032
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2005
  def opening_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism//lib/prism/node.rb#1999
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2070
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2080
    def type; end
  end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2089
class Prism::BreakNode < ::Prism::Node
  # def initialize: (ArgumentsNode? arguments, Location keyword_loc, Location location) -> void
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # source://prism//lib/prism/node.rb#2091
  def initialize(source, arguments, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2100
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#2135
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2105
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2117
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2110
  def compact_child_nodes; end

  # def copy: (?arguments: ArgumentsNode?, ?keyword_loc: Location, ?location: Location) -> BreakNode
  #
  # source://prism//lib/prism/node.rb#2122
  def copy(arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2105
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { arguments: ArgumentsNode?, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#2130
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2151
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#2146
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#2138
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2177
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2187
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2196
class Prism::CallAndWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [CallAndWriteNode] a new instance of CallAndWriteNode
  #
  # source://prism//lib/prism/node.rb#2198
  def initialize(source, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2213
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2309
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2319
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2256
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2218
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2231
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2223
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> CallAndWriteNode
  #
  # source://prism//lib/prism/node.rb#2236
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2218
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#2244
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2314
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2334
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2324
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2269
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#2329
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2288
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2282
  def read_name; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#2253
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2299
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2368
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#2295
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2304
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2285
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#2249
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2378
    def type; end
  end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#2402
class Prism::CallNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Symbol name, Location? message_loc, Location? opening_loc, ArgumentsNode? arguments, Location? closing_loc, Prism::node? block, Location location) -> void
  #
  # @return [CallNode] a new instance of CallNode
  #
  # source://prism//lib/prism/node.rb#2404
  def initialize(source, flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2420
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#2515
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2545
  def attribute_write?; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#2531
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2555
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2473
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2425
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#2570
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2518
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2439
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2430
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?name: Symbol, ?message_loc: Location?, ?opening_loc: Location?, ?arguments: ArgumentsNode?, ?closing_loc: Location?, ?block: Prism::node?, ?location: Location) -> CallNode
  #
  # source://prism//lib/prism/node.rb#2444
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2425
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, name: Symbol, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Prism::node?, location: Location }
  #
  # source://prism//lib/prism/node.rb#2452
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2550
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2575
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2560
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2489
  def message_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#2486
  def name; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#2565
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2502
  def opening_loc; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar
  #     ^^^
  #
  #     +foo
  #      ^^^
  #
  #     foo + bar
  #     ^^^
  #
  # source://prism//lib/prism/node.rb#2470
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2535
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2619
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2540
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#2457
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2629
    def type; end
  end
end

# Flags for call nodes.
#
# source://prism//lib/prism/node.rb#18826
module Prism::CallNodeFlags; end

# a call that is an attribute write, so the value being written should be returned
#
# source://prism//lib/prism/node.rb#18834
Prism::CallNodeFlags::ATTRIBUTE_WRITE = T.let(T.unsafe(nil), Integer)

# a call that ignores method visibility
#
# source://prism//lib/prism/node.rb#18837
Prism::CallNodeFlags::IGNORE_VISIBILITY = T.let(T.unsafe(nil), Integer)

# &. operator
#
# source://prism//lib/prism/node.rb#18828
Prism::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)

# a call that could have been a local variable
#
# source://prism//lib/prism/node.rb#18831
Prism::CallNodeFlags::VARIABLE_CALL = T.let(T.unsafe(nil), Integer)

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2638
class Prism::CallOperatorWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Symbol operator, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#2640
  def initialize(source, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2656
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2755
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2765
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2699
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2661
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2674
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2666
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator: Symbol, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> CallOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#2679
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2661
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator: Symbol, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#2687
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2760
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2775
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2770
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2712
  def message_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#2731
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2734
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2725
  def read_name; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#2696
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2745
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#2810
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#2741
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2750
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2728
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#2692
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#2820
    def type; end
  end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#2829
class Prism::CallOrWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [CallOrWriteNode] a new instance of CallOrWriteNode
  #
  # source://prism//lib/prism/node.rb#2831
  def initialize(source, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#2846
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2942
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#2952
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2889
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2851
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#2864
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#2856
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> CallOrWriteNode
  #
  # source://prism//lib/prism/node.rb#2869
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#2851
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#2877
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2947
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#2967
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism//lib/prism/node.rb#2957
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism//lib/prism/node.rb#2902
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#2962
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#2921
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2915
  def read_name; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#2886
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2932
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3001
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#2928
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#2937
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism//lib/prism/node.rb#2918
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#2882
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3011
    def type; end
  end
end

# Represents assigning to a method call.
#
#     foo.bar, = 1
#     ^^^^^^^
#
#     begin
#     rescue => foo.bar
#               ^^^^^^^
#     end
#
#     for foo.bar in baz do end
#         ^^^^^^^
#
# source://prism//lib/prism/node.rb#3028
class Prism::CallTargetNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node receiver, Location call_operator_loc, Symbol name, Location message_loc, Location location) -> void
  #
  # @return [CallTargetNode] a new instance of CallTargetNode
  #
  # source://prism//lib/prism/node.rb#3030
  def initialize(source, flags, receiver, call_operator_loc, name, message_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3042
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#3110
  def attribute_write?; end

  # def call_operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3120
  def call_operator; end

  # attr_reader call_operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3082
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3047
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3057
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3052
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node, ?call_operator_loc: Location, ?name: Symbol, ?message_loc: Location, ?location: Location) -> CallTargetNode
  #
  # source://prism//lib/prism/node.rb#3062
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3047
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node, call_operator_loc: Location, name: Symbol, message_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#3070
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#3115
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3130
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String
  #
  # source://prism//lib/prism/node.rb#3125
  def message; end

  # attr_reader message_loc: Location
  #
  # source://prism//lib/prism/node.rb#3092
  def message_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3089
  def name; end

  # attr_reader receiver: Prism::node
  #
  # source://prism//lib/prism/node.rb#3079
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#3100
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3156
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#3105
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#3075
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3166
    def type; end
  end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3175
class Prism::CapturePatternNode < ::Prism::Node
  # def initialize: (Prism::node value, Prism::node target, Location operator_loc, Location location) -> void
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # source://prism//lib/prism/node.rb#3177
  def initialize(source, value, target, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3187
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3192
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3202
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3197
  def compact_child_nodes; end

  # def copy: (?value: Prism::node, ?target: Prism::node, ?operator_loc: Location, ?location: Location) -> CapturePatternNode
  #
  # source://prism//lib/prism/node.rb#3207
  def copy(value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3192
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Prism::node, target: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#3215
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3239
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3234
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3226
  def operator_loc; end

  # attr_reader target: Prism::node
  #
  # source://prism//lib/prism/node.rb#3223
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3263
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#3220
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3273
    def type; end
  end
end

# Represents the use of a case statement for pattern matching.
#
#     case true
#     in false
#     end
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3284
class Prism::CaseMatchNode < ::Prism::Node
  # def initialize: (Prism::node? predicate, Array[Prism::node] conditions, ElseNode? consequent, Location case_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [CaseMatchNode] a new instance of CaseMatchNode
  #
  # source://prism//lib/prism/node.rb#3286
  def initialize(source, predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3298
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3359
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3344
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3303
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3317
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3308
  def compact_child_nodes; end

  # attr_reader conditions: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#3338
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#3341
  def consequent; end

  # def copy: (?predicate: Prism::node?, ?conditions: Array[Prism::node], ?consequent: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location, ?location: Location) -> CaseMatchNode
  #
  # source://prism//lib/prism/node.rb#3322
  def copy(predicate: T.unsafe(nil), conditions: T.unsafe(nil), consequent: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3303
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { predicate: Prism::node?, conditions: Array[Prism::node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#3330
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3364
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3351
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3369
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Prism::node?
  #
  # source://prism//lib/prism/node.rb#3335
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3403
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3413
    def type; end
  end
end

# Represents the use of a case statement.
#
#     case true
#     when false
#     end
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3424
class Prism::CaseNode < ::Prism::Node
  # def initialize: (Prism::node? predicate, Array[Prism::node] conditions, ElseNode? consequent, Location case_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # source://prism//lib/prism/node.rb#3426
  def initialize(source, predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3438
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3499
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3484
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3443
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3457
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3448
  def compact_child_nodes; end

  # attr_reader conditions: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#3478
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#3481
  def consequent; end

  # def copy: (?predicate: Prism::node?, ?conditions: Array[Prism::node], ?consequent: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location, ?location: Location) -> CaseNode
  #
  # source://prism//lib/prism/node.rb#3462
  def copy(predicate: T.unsafe(nil), conditions: T.unsafe(nil), consequent: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3443
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { predicate: Prism::node?, conditions: Array[Prism::node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#3470
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3504
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3491
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3509
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Prism::node?
  #
  # source://prism//lib/prism/node.rb#3475
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3543
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3553
    def type; end
  end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3562
class Prism::ClassNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location class_keyword_loc, Prism::node constant_path, Location? inheritance_operator_loc, Prism::node? superclass, Prism::node? body, Location end_keyword_loc, Symbol name, Location location) -> void
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # source://prism//lib/prism/node.rb#3564
  def initialize(source, locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3579
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#3645
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3584
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3659
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3619
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3598
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3589
  def compact_child_nodes; end

  # attr_reader constant_path: Prism::node
  #
  # source://prism//lib/prism/node.rb#3626
  def constant_path; end

  # def copy: (?locals: Array[Symbol], ?class_keyword_loc: Location, ?constant_path: Prism::node, ?inheritance_operator_loc: Location?, ?superclass: Prism::node?, ?body: Prism::node?, ?end_keyword_loc: Location, ?name: Symbol, ?location: Location) -> ClassNode
  #
  # source://prism//lib/prism/node.rb#3603
  def copy(locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3584
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], class_keyword_loc: Location, constant_path: Prism::node, inheritance_operator_loc: Location?, superclass: Prism::node?, body: Prism::node?, end_keyword_loc: Location, name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#3611
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#3669
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#3648
  def end_keyword_loc; end

  # def inheritance_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#3664
  def inheritance_operator; end

  # attr_reader inheritance_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#3629
  def inheritance_operator_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3674
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#3616
  def locals; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3655
  def name; end

  # attr_reader superclass: Prism::node?
  #
  # source://prism//lib/prism/node.rb#3642
  def superclass; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3712
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3722
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3731
class Prism::ClassVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ClassVariableAndWriteNode] a new instance of ClassVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3733
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3744
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3749
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3759
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3754
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ClassVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#3764
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3749
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#3772
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#125
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3803
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3777
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3780
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#3798
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3787
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3827
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#3794
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3837
    def type; end
  end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3846
class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Symbol operator, Location location) -> void
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3848
  def initialize(source, name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3860
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3865
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3875
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3870
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?operator: Symbol, ?location: Location) -> ClassVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#3880
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), operator: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3865
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, operator: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#3888
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#137
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#3917
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#3893
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#3896
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#3913
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#3903
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#3942
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#3910
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#3952
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#3961
class Prism::ClassVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ClassVariableOrWriteNode] a new instance of ClassVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#3963
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#3974
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3979
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#3989
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#3984
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ClassVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#3994
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#3979
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#4002
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#131
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4033
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4007
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4010
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4028
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4017
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4057
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#4024
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4067
    def type; end
  end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# source://prism//lib/prism/node.rb#4076
class Prism::ClassVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # source://prism//lib/prism/node.rb#4078
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4086
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4091
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4101
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4096
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> ClassVariableReadNode
  #
  # source://prism//lib/prism/node.rb#4106
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4091
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#4114
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4127
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@abc   # name `:@@abc`
  #
  #     @@_test # name `:@@_test`
  #
  # source://prism//lib/prism/node.rb#4123
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4147
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4157
    def type; end
  end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
#
# source://prism//lib/prism/node.rb#4166
class Prism::ClassVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ClassVariableTargetNode] a new instance of ClassVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#4168
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4176
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4181
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4191
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4186
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> ClassVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#4196
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4181
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#4204
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4213
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4209
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4233
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4243
    def type; end
  end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4252
class Prism::ClassVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Prism::node value, Location operator_loc, Location location) -> void
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#4254
  def initialize(source, name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4265
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4270
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4280
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4275
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location, ?location: Location) -> ClassVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#4285
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4270
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#4293
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4341
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@abc = 123     # name `@@abc`
  #
  #     @@_test = :test # name `@@_test`
  #
  # source://prism//lib/prism/node.rb#4302
  def name; end

  # The location of the variable name.
  #
  #     @@foo = :bar
  #     ^^^^^
  #
  # source://prism//lib/prism/node.rb#4308
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4336
  def operator; end

  # The location of the `=` operator.
  #
  #     @@foo = :bar
  #           ^
  #
  # source://prism//lib/prism/node.rb#4328
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4365
  def type; end

  # The value to assign to the class variable. Can be any node that
  # represents a non-void expression.
  #
  #     @@foo = :bar
  #             ^^^^
  #
  #     @@_xyz = 123
  #              ^^^
  #
  # source://prism//lib/prism/node.rb#4322
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4375
    def type; end
  end
end

# This represents a comment that was encountered during parsing. It is the
# base class for all comment types.
#
# source://prism//lib/prism/parse_result.rb#283
class Prism::Comment
  # Create a new comment object with the given location.
  #
  # @return [Comment] a new instance of Comment
  #
  # source://prism//lib/prism/parse_result.rb#288
  def initialize(location); end

  # Implement the hash pattern matching interface for Comment.
  #
  # source://prism//lib/prism/parse_result.rb#293
  def deconstruct_keys(keys); end

  # The location of this comment in the source.
  #
  # source://prism//lib/prism/parse_result.rb#285
  def location; end

  # Returns the content of the comment by slicing it from the source code.
  #
  # source://prism//lib/prism/parse_result.rb#298
  def slice; end
end

# A compiler is a visitor that returns the value of each node as it visits.
# This is as opposed to a visitor which will only walk the tree. This can be
# useful when you are trying to compile a tree into a different format.
#
# For example, to build a representation of the tree as s-expressions, you
# could write:
#
#     class SExpressions < Prism::Compiler
#       def visit_arguments_node(node) = [:arguments, super]
#       def visit_call_node(node) = [:call, super]
#       def visit_integer_node(node) = [:integer]
#       def visit_program_node(node) = [:program, super]
#     end
#
#     Prism.parse("1 + 2").value.accept(SExpressions.new)
#     # => [:program, [[[:call, [[:integer], [:arguments, [[:integer]]]]]]]]
#
# source://prism//lib/prism/compiler.rb#27
class Prism::Compiler < ::Prism::Visitor
  # Visit an individual node.
  #
  # source://prism//lib/prism/compiler.rb#29
  def visit(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_alias_global_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasMethodNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_alias_method_node(node); end

  # Visit a list of nodes.
  #
  # source://prism//lib/prism/compiler.rb#34
  def visit_all(nodes); end

  # Visit the child nodes of the given node.
  # Compile a AlternationPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_alternation_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AndNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_and_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArgumentsNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_array_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_array_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_assoc_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocSplatNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_assoc_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BackReferenceReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_back_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BeginNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_begin_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockArgumentNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_block_argument_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_block_local_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_block_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_block_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_block_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BreakNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_break_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_call_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_call_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_call_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_call_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_call_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CapturePatternNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_capture_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseMatchNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_case_match_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_case_node(node); end

  # Visit the child nodes of the given node.
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_child_nodes(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_class_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_path_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_constant_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_def_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefinedNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_defined_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ElseNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_else_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_embedded_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_embedded_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EnsureNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_ensure_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FalseNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_false_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FindPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_find_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FlipFlopNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_flip_flop_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FloatNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_float_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_for_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_forwarding_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_forwarding_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingSuperNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_forwarding_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_global_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashPatternNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_hash_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IfNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_if_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImaginaryNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_imaginary_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImplicitNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_implicit_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImplicitRestNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_implicit_rest_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_in_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_index_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_index_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_index_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_index_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_instance_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IntegerNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_integer_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_interpolated_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_interpolated_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedStringNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_interpolated_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_interpolated_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_interpolated_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ItParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_it_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordHashNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_keyword_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_keyword_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LambdaNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_lambda_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_local_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchLastLineNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchPredicateNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_match_predicate_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchRequiredNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_match_required_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_match_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MissingNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_missing_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ModuleNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_module_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiTargetNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_multi_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiWriteNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_multi_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NextNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_next_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NilNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_nil_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_no_keywords_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NumberedParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_numbered_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_numbered_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_optional_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_optional_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OrNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_or_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParametersNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParenthesesNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_parentheses_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_pinned_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedVariableNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_pinned_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PostExecutionNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_post_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PreExecutionNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_pre_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ProgramNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_program_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RangeNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_range_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RationalNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_rational_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RedoNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_redo_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RegularExpressionNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_required_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_required_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueModifierNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_rescue_modifier_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_rescue_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RestParameterNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RetryNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_retry_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ReturnNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_return_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SelfNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_self_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ShareableConstantNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_shareable_constant_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SingletonClassNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_singleton_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceEncodingNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_source_encoding_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceFileNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_source_file_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceLineNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_source_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SplatNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StatementsNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StringNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SuperNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SymbolNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a TrueNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_true_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UndefNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_undef_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UnlessNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_unless_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UntilNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_until_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhenNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_when_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhileNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_while_node(node); end

  # Visit the child nodes of the given node.
  # Compile a XStringNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a YieldNode node
  #
  # source://prism//lib/prism/compiler.rb#39
  def visit_yield_node(node); end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4384
class Prism::ConstantAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ConstantAndWriteNode] a new instance of ConstantAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4386
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4397
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4402
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4412
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4407
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ConstantAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4417
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4402
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#4425
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#143
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4456
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4430
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4433
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4451
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4440
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4480
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#4447
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4490
    def type; end
  end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4499
class Prism::ConstantOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Symbol operator, Location location) -> void
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4501
  def initialize(source, name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4513
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4518
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4528
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4523
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?operator: Symbol, ?location: Location) -> ConstantOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4533
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), operator: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4518
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, operator: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#4541
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#155
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4570
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4546
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4549
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#4566
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4556
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4595
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#4563
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4605
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4614
class Prism::ConstantOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ConstantOrWriteNode] a new instance of ConstantOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4616
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4627
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4632
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4642
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4637
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ConstantOrWriteNode
  #
  # source://prism//lib/prism/node.rb#4647
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4632
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#4655
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#149
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4686
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#4660
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#4663
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4681
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4670
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4710
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#4677
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4720
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4729
class Prism::ConstantPathAndWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ConstantPathAndWriteNode] a new instance of ConstantPathAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4731
  def initialize(source, target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4741
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4746
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4756
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4751
  def compact_child_nodes; end

  # def copy: (?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ConstantPathAndWriteNode
  #
  # source://prism//lib/prism/node.rb#4761
  def copy(target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4746
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#4769
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4793
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#4788
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4777
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4774
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4817
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#4784
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4827
    def type; end
  end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#4836
class Prism::ConstantPathNode < ::Prism::Node
  # def initialize: (Prism::node? parent, ConstantReadNode | MissingNode child, Location delimiter_loc, Location location) -> void
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4838
  def initialize(source, parent, child, delimiter_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4848
  def accept(visitor); end

  # attr_reader child: ConstantReadNode | MissingNode
  #
  # source://prism//lib/prism/node.rb#4887
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4853
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4866
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4858
  def compact_child_nodes; end

  # def copy: (?parent: Prism::node?, ?child: ConstantReadNode | MissingNode, ?delimiter_loc: Location, ?location: Location) -> ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4871
  def copy(parent: T.unsafe(nil), child: T.unsafe(nil), delimiter_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4853
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parent: Prism::node?, child: ConstantReadNode | MissingNode, delimiter_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#4879
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism//lib/prism/node.rb#4898
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism//lib/prism/node.rb#4890
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism//lib/prism/node_ext.rb#162
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism//lib/prism/node_ext.rb#141
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#4903
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Prism::node?
  #
  # source://prism//lib/prism/node.rb#4884
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#4931
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#4941
    def type; end
  end
end

# An error class raised when dynamic parts are found while computing a
# constant path's full name. For example:
# Foo::Bar::Baz -> does not raise because all parts of the constant path are
# simple constants
# var::Bar::Baz -> raises because the first part of the constant path is a
# local variable
#
# source://prism//lib/prism/node_ext.rb#132
class Prism::ConstantPathNode::DynamicPartsInConstantPathError < ::StandardError; end

# An error class raised when missing nodes are found while computing a
# constant path's full name. For example:
# Foo:: -> raises because the constant path is missing the last part
#
# source://prism//lib/prism/node_ext.rb#137
class Prism::ConstantPathNode::MissingNodesInConstantPathError < ::StandardError; end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#4950
class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Prism::node value, Symbol operator, Location location) -> void
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4952
  def initialize(source, target, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#4963
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4968
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#4978
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#4973
  def compact_child_nodes; end

  # def copy: (?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node, ?operator: Symbol, ?location: Location) -> ConstantPathOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#4983
  def copy(target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), operator: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#4968
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Prism::node, operator: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#4991
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5013
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#5009
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#4999
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#4996
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5038
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#5006
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5048
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5057
class Prism::ConstantPathOrWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ConstantPathOrWriteNode] a new instance of ConstantPathOrWriteNode
  #
  # source://prism//lib/prism/node.rb#5059
  def initialize(source, target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5069
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5074
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5084
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5079
  def compact_child_nodes; end

  # def copy: (?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ConstantPathOrWriteNode
  #
  # source://prism//lib/prism/node.rb#5089
  def copy(target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5074
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#5097
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5121
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#5116
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#5105
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#5102
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5145
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#5112
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5155
    def type; end
  end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
#
# source://prism//lib/prism/node.rb#5164
class Prism::ConstantPathTargetNode < ::Prism::Node
  # def initialize: (Prism::node? parent, ConstantReadNode | MissingNode child, Location delimiter_loc, Location location) -> void
  #
  # @return [ConstantPathTargetNode] a new instance of ConstantPathTargetNode
  #
  # source://prism//lib/prism/node.rb#5166
  def initialize(source, parent, child, delimiter_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5176
  def accept(visitor); end

  # attr_reader child: ConstantReadNode | MissingNode
  #
  # source://prism//lib/prism/node.rb#5215
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5181
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5194
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5186
  def compact_child_nodes; end

  # def copy: (?parent: Prism::node?, ?child: ConstantReadNode | MissingNode, ?delimiter_loc: Location, ?location: Location) -> ConstantPathTargetNode
  #
  # source://prism//lib/prism/node.rb#5199
  def copy(parent: T.unsafe(nil), child: T.unsafe(nil), delimiter_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5181
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parent: Prism::node?, child: ConstantReadNode | MissingNode, delimiter_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#5207
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism//lib/prism/node.rb#5226
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism//lib/prism/node.rb#5218
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism//lib/prism/node_ext.rb#190
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism//lib/prism/node_ext.rb#170
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5231
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Prism::node?
  #
  # source://prism//lib/prism/node.rb#5212
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5259
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5269
    def type; end
  end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5284
class Prism::ConstantPathWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # source://prism//lib/prism/node.rb#5286
  def initialize(source, target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5296
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5301
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5311
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5306
  def compact_child_nodes; end

  # def copy: (?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> ConstantPathWriteNode
  #
  # source://prism//lib/prism/node.rb#5316
  def copy(target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5301
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#5324
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5348
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#5343
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#5332
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism//lib/prism/node.rb#5329
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5372
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#5339
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5382
    def type; end
  end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# source://prism//lib/prism/node.rb#5391
class Prism::ConstantReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # source://prism//lib/prism/node.rb#5393
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5401
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5406
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5416
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5411
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> ConstantReadNode
  #
  # source://prism//lib/prism/node.rb#5421
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5406
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#5429
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism//lib/prism/node_ext.rb#107
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism//lib/prism/node_ext.rb#102
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5442
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
  #
  #     X              # name `:X`
  #
  #     SOME_CONSTANT  # name `:SOME_CONSTANT`
  #
  # source://prism//lib/prism/node.rb#5438
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5462
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5472
    def type; end
  end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
#
# source://prism//lib/prism/node.rb#5481
class Prism::ConstantTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ConstantTargetNode] a new instance of ConstantTargetNode
  #
  # source://prism//lib/prism/node.rb#5483
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5491
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5496
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5506
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5501
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> ConstantTargetNode
  #
  # source://prism//lib/prism/node.rb#5511
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5496
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#5519
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism//lib/prism/node_ext.rb#203
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism//lib/prism/node_ext.rb#198
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5528
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#5524
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5548
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5558
    def type; end
  end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#5567
class Prism::ConstantWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Prism::node value, Location operator_loc, Location location) -> void
  #
  # @return [ConstantWriteNode] a new instance of ConstantWriteNode
  #
  # source://prism//lib/prism/node.rb#5569
  def initialize(source, name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5580
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5585
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5595
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5590
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location, ?location: Location) -> ConstantWriteNode
  #
  # source://prism//lib/prism/node.rb#5600
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5585
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#5608
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism//lib/prism/node_ext.rb#120
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism//lib/prism/node_ext.rb#115
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5639
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#5613
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#5616
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#5634
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#5626
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5663
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#5623
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5673
    def type; end
  end
end

# The DSL module provides a set of methods that can be used to create prism
# nodes in a more concise manner. For example, instead of writing:
#
#     source = Prism::Source.new("[1]")
#
#     Prism::ArrayNode.new(
#       [
#         Prism::IntegerNode.new(
#           Prism::IntegerBaseFlags::DECIMAL,
#           1,
#           Prism::Location.new(source, 1, 1),
#           source
#         )
#       ],
#       Prism::Location.new(source, 0, 1),
#       Prism::Location.new(source, 2, 1),
#       source
#     )
#
# you could instead write:
#
#     source = Prism::Source.new("[1]")
#
#     ArrayNode(
#       IntegerNode(Prism::IntegerBaseFlags::DECIMAL, 1, Location(source, 1, 1)), source),
#       Location(source, 0, 1),
#       Location(source, 2, 1),
#       source
#     )
#
# This is mostly helpful in the context of writing tests, but can also be used
# to generate trees programmatically.
#
# source://prism//lib/prism/dsl.rb#42
module Prism::DSL
  private

  # Create a new AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#51
  def AliasGlobalVariableNode(new_name, old_name, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new AliasMethodNode node
  #
  # source://prism//lib/prism/dsl.rb#56
  def AliasMethodNode(new_name, old_name, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new AlternationPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#61
  def AlternationPatternNode(left, right, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new AndNode node
  #
  # source://prism//lib/prism/dsl.rb#66
  def AndNode(left, right, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ArgumentsNode node
  #
  # source://prism//lib/prism/dsl.rb#71
  def ArgumentsNode(flags, arguments, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ArrayNode node
  #
  # source://prism//lib/prism/dsl.rb#76
  def ArrayNode(flags, elements, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ArrayPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#81
  def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new AssocNode node
  #
  # source://prism//lib/prism/dsl.rb#86
  def AssocNode(key, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new AssocSplatNode node
  #
  # source://prism//lib/prism/dsl.rb#91
  def AssocSplatNode(value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BackReferenceReadNode node
  #
  # source://prism//lib/prism/dsl.rb#96
  def BackReferenceReadNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BeginNode node
  #
  # source://prism//lib/prism/dsl.rb#101
  def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BlockArgumentNode node
  #
  # source://prism//lib/prism/dsl.rb#106
  def BlockArgumentNode(expression, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BlockLocalVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#111
  def BlockLocalVariableNode(flags, name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BlockNode node
  #
  # source://prism//lib/prism/dsl.rb#116
  def BlockNode(locals, parameters, body, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BlockParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#121
  def BlockParameterNode(flags, name, name_loc, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BlockParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#126
  def BlockParametersNode(parameters, locals, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new BreakNode node
  #
  # source://prism//lib/prism/dsl.rb#131
  def BreakNode(arguments, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CallAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#136
  def CallAndWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CallNode node
  #
  # source://prism//lib/prism/dsl.rb#141
  def CallNode(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CallOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#146
  def CallOperatorWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CallOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#151
  def CallOrWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CallTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#156
  def CallTargetNode(flags, receiver, call_operator_loc, name, message_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CapturePatternNode node
  #
  # source://prism//lib/prism/dsl.rb#161
  def CapturePatternNode(value, target, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CaseMatchNode node
  #
  # source://prism//lib/prism/dsl.rb#166
  def CaseMatchNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new CaseNode node
  #
  # source://prism//lib/prism/dsl.rb#171
  def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassNode node
  #
  # source://prism//lib/prism/dsl.rb#176
  def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#181
  def ClassVariableAndWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#186
  def ClassVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#191
  def ClassVariableOrWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#196
  def ClassVariableReadNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#201
  def ClassVariableTargetNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ClassVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#206
  def ClassVariableWriteNode(name, name_loc, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#211
  def ConstantAndWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#216
  def ConstantOperatorWriteNode(name, name_loc, operator_loc, value, operator, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#221
  def ConstantOrWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#226
  def ConstantPathAndWriteNode(target, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathNode node
  #
  # source://prism//lib/prism/dsl.rb#231
  def ConstantPathNode(parent, child, delimiter_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#236
  def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#241
  def ConstantPathOrWriteNode(target, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#246
  def ConstantPathTargetNode(parent, child, delimiter_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantPathWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#251
  def ConstantPathWriteNode(target, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantReadNode node
  #
  # source://prism//lib/prism/dsl.rb#256
  def ConstantReadNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#261
  def ConstantTargetNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ConstantWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#266
  def ConstantWriteNode(name, name_loc, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new DefNode node
  #
  # source://prism//lib/prism/dsl.rb#271
  def DefNode(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new DefinedNode node
  #
  # source://prism//lib/prism/dsl.rb#276
  def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ElseNode node
  #
  # source://prism//lib/prism/dsl.rb#281
  def ElseNode(else_keyword_loc, statements, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/dsl.rb#286
  def EmbeddedStatementsNode(opening_loc, statements, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new EmbeddedVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#291
  def EmbeddedVariableNode(operator_loc, variable, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new EnsureNode node
  #
  # source://prism//lib/prism/dsl.rb#296
  def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new FalseNode node
  #
  # source://prism//lib/prism/dsl.rb#301
  def FalseNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new FindPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#306
  def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new FlipFlopNode node
  #
  # source://prism//lib/prism/dsl.rb#311
  def FlipFlopNode(flags, left, right, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new FloatNode node
  #
  # source://prism//lib/prism/dsl.rb#316
  def FloatNode(value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ForNode node
  #
  # source://prism//lib/prism/dsl.rb#321
  def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/dsl.rb#326
  def ForwardingArgumentsNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ForwardingParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#331
  def ForwardingParameterNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ForwardingSuperNode node
  #
  # source://prism//lib/prism/dsl.rb#336
  def ForwardingSuperNode(block, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#341
  def GlobalVariableAndWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#346
  def GlobalVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#351
  def GlobalVariableOrWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#356
  def GlobalVariableReadNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#361
  def GlobalVariableTargetNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#366
  def GlobalVariableWriteNode(name, name_loc, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new HashNode node
  #
  # source://prism//lib/prism/dsl.rb#371
  def HashNode(opening_loc, elements, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new HashPatternNode node
  #
  # source://prism//lib/prism/dsl.rb#376
  def HashPatternNode(constant, elements, rest, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IfNode node
  #
  # source://prism//lib/prism/dsl.rb#381
  def IfNode(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ImaginaryNode node
  #
  # source://prism//lib/prism/dsl.rb#386
  def ImaginaryNode(numeric, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ImplicitNode node
  #
  # source://prism//lib/prism/dsl.rb#391
  def ImplicitNode(value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ImplicitRestNode node
  #
  # source://prism//lib/prism/dsl.rb#396
  def ImplicitRestNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InNode node
  #
  # source://prism//lib/prism/dsl.rb#401
  def InNode(pattern, statements, in_loc, then_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IndexAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#406
  def IndexAndWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#411
  def IndexOperatorWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IndexOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#416
  def IndexOrWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IndexTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#421
  def IndexTargetNode(flags, receiver, opening_loc, arguments, closing_loc, block, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#426
  def InstanceVariableAndWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#431
  def InstanceVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#436
  def InstanceVariableOrWriteNode(name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#441
  def InstanceVariableReadNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#446
  def InstanceVariableTargetNode(name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#451
  def InstanceVariableWriteNode(name, name_loc, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new IntegerNode node
  #
  # source://prism//lib/prism/dsl.rb#456
  def IntegerNode(flags, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/dsl.rb#461
  def InterpolatedMatchLastLineNode(flags, opening_loc, parts, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#466
  def InterpolatedRegularExpressionNode(flags, opening_loc, parts, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InterpolatedStringNode node
  #
  # source://prism//lib/prism/dsl.rb#471
  def InterpolatedStringNode(flags, opening_loc, parts, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/dsl.rb#476
  def InterpolatedSymbolNode(opening_loc, parts, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new InterpolatedXStringNode node
  #
  # source://prism//lib/prism/dsl.rb#481
  def InterpolatedXStringNode(opening_loc, parts, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ItParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#486
  def ItParametersNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new KeywordHashNode node
  #
  # source://prism//lib/prism/dsl.rb#491
  def KeywordHashNode(flags, elements, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new KeywordRestParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#496
  def KeywordRestParameterNode(flags, name, name_loc, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LambdaNode node
  #
  # source://prism//lib/prism/dsl.rb#501
  def LambdaNode(locals, operator_loc, opening_loc, closing_loc, parameters, body, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#506
  def LocalVariableAndWriteNode(name_loc, operator_loc, value, name, depth, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#511
  def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, name, operator, depth, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#516
  def LocalVariableOrWriteNode(name_loc, operator_loc, value, name, depth, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableReadNode node
  #
  # source://prism//lib/prism/dsl.rb#521
  def LocalVariableReadNode(name, depth, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#526
  def LocalVariableTargetNode(name, depth, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new LocalVariableWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#531
  def LocalVariableWriteNode(name, depth, name_loc, value, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new Location object
  #
  # source://prism//lib/prism/dsl.rb#46
  def Location(source = T.unsafe(nil), start_offset = T.unsafe(nil), length = T.unsafe(nil)); end

  # Create a new MatchLastLineNode node
  #
  # source://prism//lib/prism/dsl.rb#536
  def MatchLastLineNode(flags, opening_loc, content_loc, closing_loc, unescaped, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MatchPredicateNode node
  #
  # source://prism//lib/prism/dsl.rb#541
  def MatchPredicateNode(value, pattern, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MatchRequiredNode node
  #
  # source://prism//lib/prism/dsl.rb#546
  def MatchRequiredNode(value, pattern, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MatchWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#551
  def MatchWriteNode(call, targets, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MissingNode node
  #
  # source://prism//lib/prism/dsl.rb#556
  def MissingNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ModuleNode node
  #
  # source://prism//lib/prism/dsl.rb#561
  def ModuleNode(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MultiTargetNode node
  #
  # source://prism//lib/prism/dsl.rb#566
  def MultiTargetNode(lefts, rest, rights, lparen_loc, rparen_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new MultiWriteNode node
  #
  # source://prism//lib/prism/dsl.rb#571
  def MultiWriteNode(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new NextNode node
  #
  # source://prism//lib/prism/dsl.rb#576
  def NextNode(arguments, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new NilNode node
  #
  # source://prism//lib/prism/dsl.rb#581
  def NilNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#586
  def NoKeywordsParameterNode(operator_loc, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new NumberedParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#591
  def NumberedParametersNode(maximum, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/dsl.rb#596
  def NumberedReferenceReadNode(number, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#601
  def OptionalKeywordParameterNode(flags, name, name_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new OptionalParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#606
  def OptionalParameterNode(flags, name, name_loc, operator_loc, value, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new OrNode node
  #
  # source://prism//lib/prism/dsl.rb#611
  def OrNode(left, right, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ParametersNode node
  #
  # source://prism//lib/prism/dsl.rb#616
  def ParametersNode(requireds, optionals, rest, posts, keywords, keyword_rest, block, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ParenthesesNode node
  #
  # source://prism//lib/prism/dsl.rb#621
  def ParenthesesNode(body, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new PinnedExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#626
  def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new PinnedVariableNode node
  #
  # source://prism//lib/prism/dsl.rb#631
  def PinnedVariableNode(variable, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new PostExecutionNode node
  #
  # source://prism//lib/prism/dsl.rb#636
  def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new PreExecutionNode node
  #
  # source://prism//lib/prism/dsl.rb#641
  def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ProgramNode node
  #
  # source://prism//lib/prism/dsl.rb#646
  def ProgramNode(locals, statements, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RangeNode node
  #
  # source://prism//lib/prism/dsl.rb#651
  def RangeNode(flags, left, right, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RationalNode node
  #
  # source://prism//lib/prism/dsl.rb#656
  def RationalNode(numeric, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RedoNode node
  #
  # source://prism//lib/prism/dsl.rb#661
  def RedoNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RegularExpressionNode node
  #
  # source://prism//lib/prism/dsl.rb#666
  def RegularExpressionNode(flags, opening_loc, content_loc, closing_loc, unescaped, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#671
  def RequiredKeywordParameterNode(flags, name, name_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RequiredParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#676
  def RequiredParameterNode(flags, name, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RescueModifierNode node
  #
  # source://prism//lib/prism/dsl.rb#681
  def RescueModifierNode(expression, keyword_loc, rescue_expression, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RescueNode node
  #
  # source://prism//lib/prism/dsl.rb#686
  def RescueNode(keyword_loc, exceptions, operator_loc, reference, statements, consequent, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RestParameterNode node
  #
  # source://prism//lib/prism/dsl.rb#691
  def RestParameterNode(flags, name, name_loc, operator_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new RetryNode node
  #
  # source://prism//lib/prism/dsl.rb#696
  def RetryNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ReturnNode node
  #
  # source://prism//lib/prism/dsl.rb#701
  def ReturnNode(keyword_loc, arguments, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SelfNode node
  #
  # source://prism//lib/prism/dsl.rb#706
  def SelfNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new ShareableConstantNode node
  #
  # source://prism//lib/prism/dsl.rb#711
  def ShareableConstantNode(flags, write, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SingletonClassNode node
  #
  # source://prism//lib/prism/dsl.rb#716
  def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SourceEncodingNode node
  #
  # source://prism//lib/prism/dsl.rb#721
  def SourceEncodingNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SourceFileNode node
  #
  # source://prism//lib/prism/dsl.rb#726
  def SourceFileNode(flags, filepath, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SourceLineNode node
  #
  # source://prism//lib/prism/dsl.rb#731
  def SourceLineNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SplatNode node
  #
  # source://prism//lib/prism/dsl.rb#736
  def SplatNode(operator_loc, expression, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new StatementsNode node
  #
  # source://prism//lib/prism/dsl.rb#741
  def StatementsNode(body, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new StringNode node
  #
  # source://prism//lib/prism/dsl.rb#746
  def StringNode(flags, opening_loc, content_loc, closing_loc, unescaped, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SuperNode node
  #
  # source://prism//lib/prism/dsl.rb#751
  def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new SymbolNode node
  #
  # source://prism//lib/prism/dsl.rb#756
  def SymbolNode(flags, opening_loc, value_loc, closing_loc, unescaped, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new TrueNode node
  #
  # source://prism//lib/prism/dsl.rb#761
  def TrueNode(source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new UndefNode node
  #
  # source://prism//lib/prism/dsl.rb#766
  def UndefNode(names, keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new UnlessNode node
  #
  # source://prism//lib/prism/dsl.rb#771
  def UnlessNode(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new UntilNode node
  #
  # source://prism//lib/prism/dsl.rb#776
  def UntilNode(flags, keyword_loc, closing_loc, predicate, statements, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new WhenNode node
  #
  # source://prism//lib/prism/dsl.rb#781
  def WhenNode(keyword_loc, conditions, then_keyword_loc, statements, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new WhileNode node
  #
  # source://prism//lib/prism/dsl.rb#786
  def WhileNode(flags, keyword_loc, closing_loc, predicate, statements, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new XStringNode node
  #
  # source://prism//lib/prism/dsl.rb#791
  def XStringNode(flags, opening_loc, content_loc, closing_loc, unescaped, source = T.unsafe(nil), location = T.unsafe(nil)); end

  # Create a new YieldNode node
  #
  # source://prism//lib/prism/dsl.rb#796
  def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, source = T.unsafe(nil), location = T.unsafe(nil)); end
end

# This module is used for testing and debugging and is not meant to be used by
# consumers of this library.
#
# source://prism//lib/prism/debug.rb#6
module Prism::Debug
  class << self
    # :call-seq:
    #   Debug::cruby_locals(source) -> Array
    #
    # For the given source, compiles with CRuby and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism//lib/prism/debug.rb#54
    def cruby_locals(source); end

    def format_errors(_arg0, _arg1); end
    def inspect_node(_arg0); end
    def integer_parse(_arg0); end
    def memsize(_arg0); end
    def named_captures(_arg0); end

    # :call-seq:
    #   Debug::newlines(source) -> Array
    #
    # For the given source string, return the byte offsets of every newline in
    # the source.
    #
    # source://prism//lib/prism/debug.rb#202
    def newlines(source); end

    # :call-seq:
    #   Debug::prism_locals(source) -> Array
    #
    # For the given source, parses with prism and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism//lib/prism/debug.rb#98
    def prism_locals(source); end

    def profile_file(_arg0); end
    def static_inspect(*_arg0); end
  end
end

# Used to hold the place of a local that will be in the local table but
# cannot be accessed directly from the source code. For example, the
# iteration variable in a for loop or the positional parameter on a method
# definition that is destructured.
#
# source://prism//lib/prism/debug.rb#90
Prism::Debug::AnonymousLocal = T.let(T.unsafe(nil), Object)

# A wrapping around prism's internal encoding data structures. This is used
# for reflection and debugging purposes.
#
# source://prism//lib/prism/debug.rb#208
class Prism::Debug::Encoding
  # Initialize a new encoding with the given name and whether or not it is
  # a multibyte encoding.
  #
  # @return [Encoding] a new instance of Encoding
  #
  # source://prism//lib/prism/debug.rb#214
  def initialize(name, multibyte); end

  # Returns true if the first character in the source string is a valid
  # alphanumeric character for the encoding.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/debug.rb#232
  def alnum?(source); end

  # Returns true if the first character in the source string is a valid
  # alphabetic character for the encoding.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/debug.rb#238
  def alpha?(source); end

  # Whether or not the encoding is a multibyte encoding.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/debug.rb#220
  def multibyte?; end

  # The name of the encoding, that can be passed to Encoding.find.
  #
  # source://prism//lib/prism/debug.rb#210
  def name; end

  # Returns true if the first character in the source string is a valid
  # uppercase character for the encoding.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/debug.rb#244
  def upper?(source); end

  # Returns the number of bytes of the first character in the source string,
  # if it is valid for the encoding. Otherwise, returns 0.
  #
  # source://prism//lib/prism/debug.rb#226
  def width(source); end

  class << self
    def _alnum?(_arg0, _arg1); end
    def _alpha?(_arg0, _arg1); end
    def _upper?(_arg0, _arg1); end
    def _width(_arg0, _arg1); end
    def all; end
  end
end

# A wrapper around a RubyVM::InstructionSequence that provides a more
# convenient interface for accessing parts of the iseq.
#
# source://prism//lib/prism/debug.rb#9
class Prism::Debug::ISeq
  # @return [ISeq] a new instance of ISeq
  #
  # source://prism//lib/prism/debug.rb#12
  def initialize(parts); end

  # source://prism//lib/prism/debug.rb#28
  def each_child; end

  # source://prism//lib/prism/debug.rb#24
  def instructions; end

  # source://prism//lib/prism/debug.rb#20
  def local_table; end

  # source://prism//lib/prism/debug.rb#10
  def parts; end

  # source://prism//lib/prism/debug.rb#16
  def type; end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5683
class Prism::DefNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Prism::node? receiver, ParametersNode? parameters, Prism::node? body, Array[Symbol] locals, Location def_keyword_loc, Location? operator_loc, Location? lparen_loc, Location? rparen_loc, Location? equal_loc, Location? end_keyword_loc, Location location) -> void
  #
  # @return [DefNode] a new instance of DefNode
  #
  # source://prism//lib/prism/node.rb#5685
  def initialize(source, name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5704
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#5757
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5709
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5723
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5714
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?receiver: Prism::node?, ?parameters: ParametersNode?, ?body: Prism::node?, ?locals: Array[Symbol], ?def_keyword_loc: Location, ?operator_loc: Location?, ?lparen_loc: Location?, ?rparen_loc: Location?, ?equal_loc: Location?, ?end_keyword_loc: Location?, ?location: Location) -> DefNode
  #
  # source://prism//lib/prism/node.rb#5728
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5709
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, receiver: Prism::node?, parameters: ParametersNode?, body: Prism::node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#5736
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#5836
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#5763
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#5861
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5822
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # source://prism//lib/prism/node.rb#5856
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5809
  def equal_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#5866
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#5760
  def locals; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5846
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5783
  def lparen_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#5741
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#5744
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#5841
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5770
  def operator_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism//lib/prism/node.rb#5754
  def parameters; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#5751
  def receiver; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#5851
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5796
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#5912
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#5922
    def type; end
  end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#5931
class Prism::DefinedNode < ::Prism::Node
  # def initialize: (Location? lparen_loc, Prism::node value, Location? rparen_loc, Location keyword_loc, Location location) -> void
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # source://prism//lib/prism/node.rb#5933
  def initialize(source, lparen_loc, value, rparen_loc, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#5944
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5949
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#5959
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#5954
  def compact_child_nodes; end

  # def copy: (?lparen_loc: Location?, ?value: Prism::node, ?rparen_loc: Location?, ?keyword_loc: Location, ?location: Location) -> DefinedNode
  #
  # source://prism//lib/prism/node.rb#5964
  def copy(lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#5949
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lparen_loc: Location?, value: Prism::node, rparen_loc: Location?, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#5972
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6029
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6024
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6006
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#6014
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5977
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#6019
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#5993
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6053
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#5990
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6063
    def type; end
  end
end

# source://prism//lib/prism/desugar_compiler.rb#4
class Prism::DesugarAndWriteNode
  # @return [DesugarAndWriteNode] a new instance of DesugarAndWriteNode
  #
  # source://prism//lib/prism/desugar_compiler.rb#7
  def initialize(node, source, read_class, write_class, *arguments); end

  # Returns the value of attribute arguments.
  #
  # source://prism//lib/prism/desugar_compiler.rb#5
  def arguments; end

  # Desugar `x &&= y` to `x && x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#16
  def compile; end

  # Returns the value of attribute node.
  #
  # source://prism//lib/prism/desugar_compiler.rb#5
  def node; end

  # Returns the value of attribute read_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#5
  def read_class; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/desugar_compiler.rb#5
  def source; end

  # Returns the value of attribute write_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#5
  def write_class; end
end

# DesugarCompiler is a compiler that desugars Ruby code into a more primitive
# form. This is useful for consumers that want to deal with fewer node types.
#
# source://prism//lib/prism/desugar_compiler.rb#216
class Prism::DesugarCompiler < ::Prism::MutationCompiler
  # @@foo &&= bar
  #
  # becomes
  #
  # @@foo && @@foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#222
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  #
  # becomes
  #
  # @@foo = @@foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#240
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  #
  # becomes
  #
  # defined?(@@foo) ? @@foo : @@foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#231
  def visit_class_variable_or_write_node(node); end

  # Foo &&= bar
  #
  # becomes
  #
  # Foo && Foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#249
  def visit_constant_and_write_node(node); end

  # Foo += bar
  #
  # becomes
  #
  # Foo = Foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#267
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  #
  # becomes
  #
  # defined?(Foo) ? Foo : Foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#258
  def visit_constant_or_write_node(node); end

  # $foo &&= bar
  #
  # becomes
  #
  # $foo && $foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#276
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  #
  # becomes
  #
  # $foo = $foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#294
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  #
  # becomes
  #
  # defined?($foo) ? $foo : $foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#285
  def visit_global_variable_or_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#303
  def visit_instance_variable_and_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#321
  def visit_instance_variable_operator_write_node(node); end

  # becomes
  #
  # source://prism//lib/prism/desugar_compiler.rb#312
  def visit_instance_variable_or_write_node(node); end

  # foo &&= bar
  #
  # becomes
  #
  # foo && foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#330
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  #
  # becomes
  #
  # foo = foo + bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#348
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  #
  # becomes
  #
  # foo || foo = bar
  #
  # source://prism//lib/prism/desugar_compiler.rb#339
  def visit_local_variable_or_write_node(node); end
end

# source://prism//lib/prism/desugar_compiler.rb#63
class Prism::DesugarOperatorWriteNode
  # @return [DesugarOperatorWriteNode] a new instance of DesugarOperatorWriteNode
  #
  # source://prism//lib/prism/desugar_compiler.rb#66
  def initialize(node, source, read_class, write_class, *arguments); end

  # Returns the value of attribute arguments.
  #
  # source://prism//lib/prism/desugar_compiler.rb#64
  def arguments; end

  # Desugar `x += y` to `x = x + y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#75
  def compile; end

  # Returns the value of attribute node.
  #
  # source://prism//lib/prism/desugar_compiler.rb#64
  def node; end

  # Returns the value of attribute read_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#64
  def read_class; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/desugar_compiler.rb#64
  def source; end

  # Returns the value of attribute write_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#64
  def write_class; end
end

# source://prism//lib/prism/desugar_compiler.rb#27
class Prism::DesugarOrWriteDefinedNode
  # @return [DesugarOrWriteDefinedNode] a new instance of DesugarOrWriteDefinedNode
  #
  # source://prism//lib/prism/desugar_compiler.rb#30
  def initialize(node, source, read_class, write_class, *arguments); end

  # Returns the value of attribute arguments.
  #
  # source://prism//lib/prism/desugar_compiler.rb#28
  def arguments; end

  # Desugar `x ||= y` to `defined?(x) ? x : x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#39
  def compile; end

  # Returns the value of attribute node.
  #
  # source://prism//lib/prism/desugar_compiler.rb#28
  def node; end

  # Returns the value of attribute read_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#28
  def read_class; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/desugar_compiler.rb#28
  def source; end

  # Returns the value of attribute write_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#28
  def write_class; end
end

# source://prism//lib/prism/desugar_compiler.rb#99
class Prism::DesugarOrWriteNode
  # @return [DesugarOrWriteNode] a new instance of DesugarOrWriteNode
  #
  # source://prism//lib/prism/desugar_compiler.rb#102
  def initialize(node, source, read_class, write_class, *arguments); end

  # Returns the value of attribute arguments.
  #
  # source://prism//lib/prism/desugar_compiler.rb#100
  def arguments; end

  # Desugar `x ||= y` to `x || x = y`
  #
  # source://prism//lib/prism/desugar_compiler.rb#111
  def compile; end

  # Returns the value of attribute node.
  #
  # source://prism//lib/prism/desugar_compiler.rb#100
  def node; end

  # Returns the value of attribute read_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#100
  def read_class; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/desugar_compiler.rb#100
  def source; end

  # Returns the value of attribute write_class.
  #
  # source://prism//lib/prism/desugar_compiler.rb#100
  def write_class; end
end

# The dispatcher class fires events for nodes that are found while walking an
# AST to all registered listeners. It's useful for performing different types
# of analysis on the AST while only having to walk the tree once.
#
# To use the dispatcher, you would first instantiate it and register listeners
# for the events you're interested in:
#
#     class OctalListener
#       def on_integer_node_enter(node)
#         if node.octal? && !node.slice.start_with?("0o")
#           warn("Octal integers should be written with the 0o prefix")
#         end
#       end
#     end
#
#     dispatcher = Dispatcher.new
#     dispatcher.register(listener, :on_integer_node_enter)
#
# Then, you can walk any number of trees and dispatch events to the listeners:
#
#     result = Prism.parse("001 + 002 + 003")
#     dispatcher.dispatch(result.value)
#
# Optionally, you can also use `#dispatch_once` to dispatch enter and leave
# events for a single node without recursing further down the tree. This can
# be useful in circumstances where you want to reuse the listeners you already
# have registers but want to stop walking the tree at a certain point.
#
#     integer = result.value.statements.body.first.receiver.receiver
#     dispatcher.dispatch_once(integer)
#
# source://prism//lib/prism/dispatcher.rb#41
class Prism::Dispatcher < ::Prism::Visitor
  # Initialize a new dispatcher.
  #
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://prism//lib/prism/dispatcher.rb#46
  def initialize; end

  # Walks `root` dispatching events to all registered listeners.
  #
  # def dispatch: (Node) -> void
  #
  # source://prism//lib/prism/visitor.rb#17
  def dispatch(node); end

  # Dispatches a single event for `node` to all registered listeners.
  #
  # def dispatch_once: (Node) -> void
  #
  # source://prism//lib/prism/dispatcher.rb#65
  def dispatch_once(node); end

  # attr_reader listeners: Hash[Symbol, Array[Listener]]
  #
  # source://prism//lib/prism/dispatcher.rb#43
  def listeners; end

  # Register a listener for one or more events.
  #
  # def register: (Listener, *Symbol) -> void
  #
  # source://prism//lib/prism/dispatcher.rb#53
  def register(listener, *events); end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#71
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#79
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#87
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#95
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#103
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#111
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#119
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#127
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#135
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#143
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#151
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#159
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#167
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#175
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#183
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#191
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#199
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#207
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#215
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#223
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#231
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#239
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#247
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#255
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#263
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#271
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#279
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#287
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#295
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#303
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#311
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#319
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#327
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#335
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#343
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#351
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#359
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#367
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#375
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#383
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#391
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#399
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#407
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#415
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#423
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#431
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#439
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#447
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#455
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#463
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#471
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#479
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#487
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#495
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#503
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#511
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#519
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#527
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#535
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#543
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#551
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#559
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#567
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#575
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#583
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#591
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#599
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#607
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#615
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#623
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#631
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#639
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#647
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#655
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#663
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#671
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#679
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#687
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#695
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#703
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#711
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#719
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#727
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#735
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#743
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#751
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#759
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for ItParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#767
  def visit_it_parameters_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#775
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#783
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#791
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#799
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#807
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#815
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#823
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#831
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#839
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#847
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#855
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#863
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#871
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#879
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#887
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#895
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#903
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#911
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#919
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#927
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#935
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#943
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#951
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#959
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#967
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#975
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#983
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#991
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#999
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1007
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1015
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1023
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1031
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1039
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1047
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1055
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1063
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1071
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1079
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1087
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1095
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1103
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1111
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1119
  def visit_self_node(node); end

  # Dispatch enter and leave events for ShareableConstantNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1127
  def visit_shareable_constant_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1135
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1143
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1151
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1159
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1167
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1175
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1183
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1191
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1199
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1207
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1215
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1223
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1231
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1239
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1247
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1255
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes and continue
  # walking the tree.
  #
  # source://prism//lib/prism/dispatcher.rb#1263
  def visit_yield_node(node); end
end

# source://prism//lib/prism/dispatcher.rb#1269
class Prism::Dispatcher::DispatchOnce < ::Prism::Visitor
  # @return [DispatchOnce] a new instance of DispatchOnce
  #
  # source://prism//lib/prism/dispatcher.rb#1272
  def initialize(listeners); end

  # Returns the value of attribute listeners.
  #
  # source://prism//lib/prism/dispatcher.rb#1270
  def listeners; end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1277
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1283
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1289
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1295
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1301
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1307
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1313
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1319
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1325
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1331
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1337
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1343
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1349
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1355
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1361
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1367
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1373
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1379
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1385
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1391
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1397
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1403
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1409
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1415
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1421
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1427
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1433
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1439
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1445
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1451
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1457
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1463
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1469
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1475
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1481
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1487
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1493
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1499
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1505
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1511
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1517
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1523
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1529
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1535
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1541
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1547
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1553
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1559
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1565
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1571
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1577
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1583
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1589
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1595
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1601
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1607
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1613
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1619
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1625
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1631
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1637
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1643
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1649
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1655
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1661
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1667
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1673
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1679
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1685
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1691
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1697
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1703
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1709
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1715
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1721
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1727
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1733
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1739
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1745
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1751
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1757
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1763
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1769
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1775
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1781
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1787
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1793
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for ItParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1799
  def visit_it_parameters_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1805
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1811
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1817
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1823
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1829
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1835
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1841
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1847
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1853
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1859
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1865
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1871
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1877
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1883
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1889
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1895
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1901
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1907
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1913
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1919
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1925
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1931
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1937
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1943
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1949
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1955
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1961
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1967
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1973
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1979
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1985
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1991
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#1997
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2003
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2009
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2015
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2021
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2027
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2033
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2039
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2045
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2051
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2057
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2063
  def visit_self_node(node); end

  # Dispatch enter and leave events for ShareableConstantNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2069
  def visit_shareable_constant_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2075
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2081
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2087
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2093
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2099
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2105
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2111
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2117
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2123
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2129
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2135
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2141
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2147
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2153
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2159
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2165
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes.
  #
  # source://prism//lib/prism/dispatcher.rb#2171
  def visit_yield_node(node); end
end

# This visitor provides the ability to call Node#to_dot, which converts a
# subtree into a graphviz dot graph.
#
# source://prism//lib/prism/dot_visitor.rb#14
class Prism::DotVisitor < ::Prism::Visitor
  # Initialize a new dot visitor.
  #
  # @return [DotVisitor] a new instance of DotVisitor
  #
  # source://prism//lib/prism/dot_visitor.rb#106
  def initialize; end

  # The digraph that is being built.
  #
  # source://prism//lib/prism/dot_visitor.rb#103
  def digraph; end

  # Convert this visitor into a graphviz dot graph string.
  #
  # source://prism//lib/prism/dot_visitor.rb#111
  def to_dot; end

  # Visit a AliasGlobalVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#116
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#141
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#166
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#191
  def visit_and_node(node); end

  # Visit a ArgumentsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#216
  def visit_arguments_node(node); end

  # Visit a ArrayNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#246
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#286
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#348
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#375
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#398
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#415
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#463
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#486
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#506
  def visit_block_node(node); end

  # Visit a BlockParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#541
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#569
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#612
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#635
  def visit_call_and_write_node(node); end

  # Visit a CallNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#681
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#739
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#788
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#834
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#864
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#889
  def visit_case_match_node(node); end

  # Visit a CaseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#934
  def visit_case_node(node); end

  # Visit a ClassNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#979
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1026
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1053
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1083
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1110
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1127
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1144
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1171
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1198
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1228
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1255
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1280
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1307
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1335
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1360
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1387
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1412
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1429
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1446
  def visit_constant_write_node(node); end

  # Visit a DefNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1473
  def visit_def_node(node); end

  # Visit a DefinedNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1542
  def visit_defined_node(node); end

  # Visit a ElseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1573
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1601
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1627
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1648
  def visit_ensure_node(node); end

  # Visit a FalseNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1674
  def visit_false_node(node); end

  # Visit a FindPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1688
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1739
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1771
  def visit_float_node(node); end

  # Visit a ForNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1788
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1830
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1844
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1858
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1878
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1905
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1935
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1962
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1979
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#1996
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2023
  def visit_hash_node(node); end

  # Visit a HashPatternNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2056
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2105
  def visit_if_node(node); end

  # Visit a ImaginaryNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2150
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2168
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2186
  def visit_implicit_rest_node(node); end

  # Visit a InNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2200
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2232
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2285
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2341
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2394
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2433
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2460
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2490
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2517
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2534
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2551
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2578
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2598
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2634
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2670
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2710
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2747
  def visit_interpolated_x_string_node(node); end

  # Visit a ItParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2780
  def visit_it_parameters_node(node); end

  # Visit a KeywordHashNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2794
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2824
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2852
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2890
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2920
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2953
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#2983
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3003
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3023
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3053
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3082
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3107
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3132
  def visit_match_write_node(node); end

  # Visit a MissingNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3163
  def visit_missing_node(node); end

  # Visit a ModuleNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3177
  def visit_module_node(node); end

  # Visit a MultiTargetNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3213
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3269
  def visit_multi_write_node(node); end

  # Visit a NextNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3332
  def visit_next_node(node); end

  # Visit a NilNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3355
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3369
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3389
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3406
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3423
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3450
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3480
  def visit_or_node(node); end

  # Visit a ParametersNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3505
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3589
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3615
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3642
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3663
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3692
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3721
  def visit_program_node(node); end

  # Visit a RangeNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3742
  def visit_range_node(node); end

  # Visit a RationalNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3774
  def visit_rational_node(node); end

  # Visit a RedoNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3792
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3806
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3835
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3858
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3878
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3903
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3956
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3984
  def visit_retry_node(node); end

  # Visit a ReturnNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#3998
  def visit_return_node(node); end

  # Visit a SelfNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4021
  def visit_self_node(node); end

  # Visit a ShareableConstantNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4035
  def visit_shareable_constant_node(node); end

  # Visit a SingletonClassNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4056
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4092
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4106
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4126
  def visit_source_line_node(node); end

  # Visit a SplatNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4140
  def visit_splat_node(node); end

  # Visit a StatementsNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4163
  def visit_statements_node(node); end

  # Visit a StringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4190
  def visit_string_node(node); end

  # Visit a SuperNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4223
  def visit_super_node(node); end

  # Visit a SymbolNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4262
  def visit_symbol_node(node); end

  # Visit a TrueNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4297
  def visit_true_node(node); end

  # Visit a UndefNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4311
  def visit_undef_node(node); end

  # Visit a UnlessNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4341
  def visit_unless_node(node); end

  # Visit a UntilNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4384
  def visit_until_node(node); end

  # Visit a WhenNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4419
  def visit_when_node(node); end

  # Visit a WhileNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4460
  def visit_while_node(node); end

  # Visit a XStringNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4495
  def visit_x_string_node(node); end

  # Visit a YieldNode node.
  #
  # source://prism//lib/prism/dot_visitor.rb#4524
  def visit_yield_node(node); end

  private

  # Inspect a node that has arguments_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4570
  def arguments_node_flags_inspect(node); end

  # Inspect a node that has array_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4578
  def array_node_flags_inspect(node); end

  # Inspect a node that has call_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4586
  def call_node_flags_inspect(node); end

  # Inspect a node that has encoding_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4597
  def encoding_flags_inspect(node); end

  # Inspect a node that has integer_base_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4606
  def integer_base_flags_inspect(node); end

  # Inspect a node that has interpolated_string_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4617
  def interpolated_string_node_flags_inspect(node); end

  # Inspect a node that has keyword_hash_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4626
  def keyword_hash_node_flags_inspect(node); end

  # Inspect a location to display the start and end line and column numbers.
  #
  # source://prism//lib/prism/dot_visitor.rb#4564
  def location_inspect(location); end

  # Inspect a node that has loop_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4634
  def loop_flags_inspect(node); end

  # Generate a unique node ID for a node throughout the digraph.
  #
  # source://prism//lib/prism/dot_visitor.rb#4559
  def node_id(node); end

  # Inspect a node that has parameter_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4642
  def parameter_flags_inspect(node); end

  # Inspect a node that has range_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4650
  def range_flags_inspect(node); end

  # Inspect a node that has regular_expression_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4658
  def regular_expression_flags_inspect(node); end

  # Inspect a node that has shareable_constant_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4676
  def shareable_constant_node_flags_inspect(node); end

  # Inspect a node that has string_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4686
  def string_flags_inspect(node); end

  # Inspect a node that has symbol_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism//lib/prism/dot_visitor.rb#4697
  def symbol_flags_inspect(node); end
end

# source://prism//lib/prism/dot_visitor.rb#59
class Prism::DotVisitor::Digraph
  # @return [Digraph] a new instance of Digraph
  #
  # source://prism//lib/prism/dot_visitor.rb#62
  def initialize; end

  # source://prism//lib/prism/dot_visitor.rb#76
  def edge(value); end

  # Returns the value of attribute edges.
  #
  # source://prism//lib/prism/dot_visitor.rb#60
  def edges; end

  # source://prism//lib/prism/dot_visitor.rb#68
  def node(value); end

  # Returns the value of attribute nodes.
  #
  # source://prism//lib/prism/dot_visitor.rb#60
  def nodes; end

  # source://prism//lib/prism/dot_visitor.rb#80
  def to_dot; end

  # source://prism//lib/prism/dot_visitor.rb#72
  def waypoint(value); end

  # Returns the value of attribute waypoints.
  #
  # source://prism//lib/prism/dot_visitor.rb#60
  def waypoints; end
end

# source://prism//lib/prism/dot_visitor.rb#15
class Prism::DotVisitor::Field
  # @return [Field] a new instance of Field
  #
  # source://prism//lib/prism/dot_visitor.rb#18
  def initialize(name, value, port); end

  # Returns the value of attribute name.
  #
  # source://prism//lib/prism/dot_visitor.rb#16
  def name; end

  # Returns the value of attribute port.
  #
  # source://prism//lib/prism/dot_visitor.rb#16
  def port; end

  # source://prism//lib/prism/dot_visitor.rb#24
  def to_dot; end

  # Returns the value of attribute value.
  #
  # source://prism//lib/prism/dot_visitor.rb#16
  def value; end
end

# source://prism//lib/prism/dot_visitor.rb#33
class Prism::DotVisitor::Table
  # @return [Table] a new instance of Table
  #
  # source://prism//lib/prism/dot_visitor.rb#36
  def initialize(name); end

  # source://prism//lib/prism/dot_visitor.rb#41
  def field(name, value = T.unsafe(nil), port: T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # source://prism//lib/prism/dot_visitor.rb#34
  def fields; end

  # Returns the value of attribute name.
  #
  # source://prism//lib/prism/dot_visitor.rb#34
  def name; end

  # source://prism//lib/prism/dot_visitor.rb#45
  def to_dot; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6072
class Prism::ElseNode < ::Prism::Node
  # def initialize: (Location else_keyword_loc, StatementsNode? statements, Location? end_keyword_loc, Location location) -> void
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # source://prism//lib/prism/node.rb#6074
  def initialize(source, else_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6084
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6089
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6101
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6094
  def compact_child_nodes; end

  # def copy: (?else_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location?, ?location: Location) -> ElseNode
  #
  # source://prism//lib/prism/node.rb#6106
  def copy(else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6089
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#6114
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6143
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6119
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#6148
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#6129
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6153
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#6126
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6180
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6190
    def type; end
  end
end

# EmbDocComment objects correspond to comments that are surrounded by =begin
# and =end.
#
# source://prism//lib/prism/parse_result.rb#320
class Prism::EmbDocComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism//lib/prism/parse_result.rb#327
  def inspect; end

  # This can only be true for inline comments.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#322
  def trailing?; end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# source://prism//lib/prism/node.rb#6199
class Prism::EmbeddedStatementsNode < ::Prism::Node
  # def initialize: (Location opening_loc, StatementsNode? statements, Location closing_loc, Location location) -> void
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # source://prism//lib/prism/node.rb#6201
  def initialize(source, opening_loc, statements, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6211
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6216
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#6269
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#6256
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6228
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6221
  def compact_child_nodes; end

  # def copy: (?opening_loc: Location, ?statements: StatementsNode?, ?closing_loc: Location, ?location: Location) -> EmbeddedStatementsNode
  #
  # source://prism//lib/prism/node.rb#6233
  def copy(opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6216
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#6241
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6274
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#6264
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#6246
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#6253
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6301
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6311
    def type; end
  end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# source://prism//lib/prism/node.rb#6320
class Prism::EmbeddedVariableNode < ::Prism::Node
  # def initialize: (Location operator_loc, Prism::node variable, Location location) -> void
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # source://prism//lib/prism/node.rb#6322
  def initialize(source, operator_loc, variable, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6331
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6336
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6346
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6341
  def compact_child_nodes; end

  # def copy: (?operator_loc: Location, ?variable: Prism::node, ?location: Location) -> EmbeddedVariableNode
  #
  # source://prism//lib/prism/node.rb#6351
  def copy(operator_loc: T.unsafe(nil), variable: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6336
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, variable: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#6359
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6380
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#6375
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6364
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6402
  def type; end

  # attr_reader variable: Prism::node
  #
  # source://prism//lib/prism/node.rb#6371
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6412
    def type; end
  end
end

# Flags for nodes that have unescaped content.
#
# source://prism//lib/prism/node.rb#18841
module Prism::EncodingFlags; end

# internal bytes forced the encoding to binary
#
# source://prism//lib/prism/node.rb#18846
Prism::EncodingFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism//lib/prism/node.rb#18843
Prism::EncodingFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# source://prism//lib/prism/node.rb#6425
class Prism::EnsureNode < ::Prism::Node
  # def initialize: (Location ensure_keyword_loc, StatementsNode? statements, Location end_keyword_loc, Location location) -> void
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # source://prism//lib/prism/node.rb#6427
  def initialize(source, ensure_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6437
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6442
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6454
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6447
  def compact_child_nodes; end

  # def copy: (?ensure_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location, ?location: Location) -> EnsureNode
  #
  # source://prism//lib/prism/node.rb#6459
  def copy(ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6442
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#6467
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6495
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6482
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#6490
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#6472
  def ensure_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6500
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#6479
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6527
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6537
    def type; end
  end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# source://prism//lib/prism/node.rb#6546
class Prism::FalseNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # source://prism//lib/prism/node.rb#6548
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6555
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6560
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6570
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6565
  def compact_child_nodes; end

  # def copy: (?location: Location) -> FalseNode
  #
  # source://prism//lib/prism/node.rb#6575
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6560
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#6583
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6589
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6608
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6618
    def type; end
  end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#            ^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#            ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6633
class Prism::FindPatternNode < ::Prism::Node
  # def initialize: (Prism::node? constant, Prism::node left, Array[Prism::node] requireds, Prism::node right, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # source://prism//lib/prism/node.rb#6635
  def initialize(source, constant, left, requireds, right, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6648
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6653
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#6730
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#6711
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6668
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6658
  def compact_child_nodes; end

  # attr_reader constant: Prism::node?
  #
  # source://prism//lib/prism/node.rb#6686
  def constant; end

  # def copy: (?constant: Prism::node?, ?left: Prism::node, ?requireds: Array[Prism::node], ?right: Prism::node, ?opening_loc: Location?, ?closing_loc: Location?, ?location: Location) -> FindPatternNode
  #
  # source://prism//lib/prism/node.rb#6673
  def copy(constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6653
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Prism::node?, left: Prism::node, requireds: Array[Prism::node], right: Prism::node, opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#6681
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6735
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Prism::node
  #
  # source://prism//lib/prism/node.rb#6689
  def left; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#6725
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#6698
  def opening_loc; end

  # attr_reader requireds: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#6692
  def requireds; end

  # attr_reader right: Prism::node
  #
  # source://prism//lib/prism/node.rb#6695
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6767
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6777
    def type; end
  end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#6786
class Prism::FlipFlopNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? left, Prism::node? right, Location operator_loc, Location location) -> void
  #
  # @return [FlipFlopNode] a new instance of FlipFlopNode
  #
  # source://prism//lib/prism/node.rb#6788
  def initialize(source, flags, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6799
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6804
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6817
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6809
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location, ?location: Location) -> FlipFlopNode
  #
  # source://prism//lib/prism/node.rb#6822
  def copy(flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6804
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, left: Prism::node?, right: Prism::node?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#6830
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#6853
  def exclude_end?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6863
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Prism::node?
  #
  # source://prism//lib/prism/node.rb#6839
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#6858
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#6845
  def operator_loc; end

  # attr_reader right: Prism::node?
  #
  # source://prism//lib/prism/node.rb#6842
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6897
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#6835
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6907
    def type; end
  end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# source://prism//lib/prism/node.rb#6916
class Prism::FloatNode < ::Prism::Node
  # def initialize: (Float value, Location location) -> void
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # source://prism//lib/prism/node.rb#6918
  def initialize(source, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#6926
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6931
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#6941
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#6936
  def compact_child_nodes; end

  # def copy: (?value: Float, ?location: Location) -> FloatNode
  #
  # source://prism//lib/prism/node.rb#6946
  def copy(value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#6931
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Float, location: Location }
  #
  # source://prism//lib/prism/node.rb#6954
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#6963
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#6983
  def type; end

  # The value of the floating point number as a Float.
  #
  # source://prism//lib/prism/node.rb#6959
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#6993
    def type; end
  end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7002
class Prism::ForNode < ::Prism::Node
  # def initialize: (Prism::node index, Prism::node collection, StatementsNode? statements, Location for_keyword_loc, Location in_keyword_loc, Location? do_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [ForNode] a new instance of ForNode
  #
  # source://prism//lib/prism/node.rb#7004
  def initialize(source, index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7018
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7023
  def child_nodes; end

  # attr_reader collection: Prism::node
  #
  # source://prism//lib/prism/node.rb#7058
  def collection; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7037
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7028
  def compact_child_nodes; end

  # def copy: (?index: Prism::node, ?collection: Prism::node, ?statements: StatementsNode?, ?for_keyword_loc: Location, ?in_keyword_loc: Location, ?do_keyword_loc: Location?, ?end_keyword_loc: Location, ?location: Location) -> ForNode
  #
  # source://prism//lib/prism/node.rb#7042
  def copy(index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7023
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { index: Prism::node, collection: Prism::node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#7050
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#7109
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#7078
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#7114
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#7091
  def end_keyword_loc; end

  # def for_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#7099
  def for_keyword; end

  # attr_reader for_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#7064
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#7104
  def in_keyword; end

  # attr_reader in_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#7071
  def in_keyword_loc; end

  # attr_reader index: Prism::node
  #
  # source://prism//lib/prism/node.rb#7055
  def index; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7119
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#7061
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7152
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7162
    def type; end
  end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#           ^^^
#     end
#
# source://prism//lib/prism/node.rb#7173
class Prism::ForwardingArgumentsNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # source://prism//lib/prism/node.rb#7175
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7182
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7187
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7197
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7192
  def compact_child_nodes; end

  # def copy: (?location: Location) -> ForwardingArgumentsNode
  #
  # source://prism//lib/prism/node.rb#7202
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7187
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#7210
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7216
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7235
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7245
    def type; end
  end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# source://prism//lib/prism/node.rb#7255
class Prism::ForwardingParameterNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # source://prism//lib/prism/node.rb#7257
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7264
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7269
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7279
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7274
  def compact_child_nodes; end

  # def copy: (?location: Location) -> ForwardingParameterNode
  #
  # source://prism//lib/prism/node.rb#7284
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7269
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#7292
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7298
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7317
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7327
    def type; end
  end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
#
# source://prism//lib/prism/node.rb#7336
class Prism::ForwardingSuperNode < ::Prism::Node
  # def initialize: (BlockNode? block, Location location) -> void
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # source://prism//lib/prism/node.rb#7338
  def initialize(source, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7346
  def accept(visitor); end

  # attr_reader block: BlockNode?
  #
  # source://prism//lib/prism/node.rb#7381
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7351
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7363
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7356
  def compact_child_nodes; end

  # def copy: (?block: BlockNode?, ?location: Location) -> ForwardingSuperNode
  #
  # source://prism//lib/prism/node.rb#7368
  def copy(block: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7351
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { block: BlockNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#7376
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7385
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7410
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7420
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7429
class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [GlobalVariableAndWriteNode] a new instance of GlobalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#7431
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7442
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7447
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7457
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7452
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> GlobalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#7462
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7447
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#7470
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#161
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7501
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7475
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#7478
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#7496
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#7485
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7525
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#7492
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7535
    def type; end
  end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7544
class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Symbol operator, Location location) -> void
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#7546
  def initialize(source, name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7558
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7563
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7573
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7568
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?operator: Symbol, ?location: Location) -> GlobalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#7578
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), operator: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7563
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, operator: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#7586
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#173
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7615
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7591
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#7594
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#7611
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#7601
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7640
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#7608
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7650
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#7659
class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [GlobalVariableOrWriteNode] a new instance of GlobalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#7661
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7672
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7677
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7687
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7682
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> GlobalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#7692
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7677
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#7700
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#167
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7731
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7705
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#7708
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#7726
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#7715
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7755
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#7722
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7765
    def type; end
  end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# source://prism//lib/prism/node.rb#7774
class Prism::GlobalVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#7776
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7784
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7789
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7799
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7794
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> GlobalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#7804
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7789
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#7812
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7825
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
  #
  #     $foo   # name `:$foo`
  #
  #     $_Test # name `:$_Test`
  #
  # source://prism//lib/prism/node.rb#7821
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7845
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7855
    def type; end
  end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
#
# source://prism//lib/prism/node.rb#7864
class Prism::GlobalVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [GlobalVariableTargetNode] a new instance of GlobalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#7866
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7874
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7879
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7889
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7884
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> GlobalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#7894
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7879
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#7902
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#7911
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7907
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#7931
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#7941
    def type; end
  end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#7950
class Prism::GlobalVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Prism::node value, Location operator_loc, Location location) -> void
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#7952
  def initialize(source, name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#7963
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7968
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#7978
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#7973
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location, ?location: Location) -> GlobalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#7983
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#7968
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#7991
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8022
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#7996
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#7999
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#8017
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#8009
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8046
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#8006
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8056
    def type; end
  end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8065
class Prism::HashNode < ::Prism::Node
  # def initialize: (Location opening_loc, Array[AssocNode | AssocSplatNode] elements, Location closing_loc, Location location) -> void
  #
  # @return [HashNode] a new instance of HashNode
  #
  # source://prism//lib/prism/node.rb#8067
  def initialize(source, opening_loc, elements, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8077
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8082
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#8145
  def closing; end

  # The location of the closing brace.
  #
  #     { a => b }
  #              ^
  #
  # source://prism//lib/prism/node.rb#8132
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8092
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8087
  def compact_child_nodes; end

  # def copy: (?opening_loc: Location, ?elements: Array[AssocNode | AssocSplatNode], ?closing_loc: Location, ?location: Location) -> HashNode
  #
  # source://prism//lib/prism/node.rb#8097
  def copy(opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8082
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, elements: Array[AssocNode | AssocSplatNode], closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#8105
  def deconstruct_keys(keys); end

  # The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.
  #
  #     { a: b }
  #       ^^^^
  #
  #     { **foo }
  #       ^^^^^
  #
  # source://prism//lib/prism/node.rb#8126
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8150
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#8140
  def opening; end

  # The location of the opening brace.
  #
  #     { a => b }
  #     ^
  #
  # source://prism//lib/prism/node.rb#8113
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8172
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8182
    def type; end
  end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8194
class Prism::HashPatternNode < ::Prism::Node
  # def initialize: (Prism::node? constant, Array[AssocNode] elements, AssocSplatNode | NoKeywordsParameterNode | nil rest, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # source://prism//lib/prism/node.rb#8196
  def initialize(source, constant, elements, rest, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8208
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8213
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#8286
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8267
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8227
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8218
  def compact_child_nodes; end

  # attr_reader constant: Prism::node?
  #
  # source://prism//lib/prism/node.rb#8245
  def constant; end

  # def copy: (?constant: Prism::node?, ?elements: Array[AssocNode], ?rest: AssocSplatNode | NoKeywordsParameterNode | nil, ?opening_loc: Location?, ?closing_loc: Location?, ?location: Location) -> HashPatternNode
  #
  # source://prism//lib/prism/node.rb#8232
  def copy(constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8213
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Prism::node?, elements: Array[AssocNode], rest: AssocSplatNode | NoKeywordsParameterNode | nil, opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#8240
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[AssocNode]
  #
  # source://prism//lib/prism/node.rb#8248
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8291
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#8281
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8254
  def opening_loc; end

  # attr_reader rest: AssocSplatNode | NoKeywordsParameterNode | nil
  #
  # source://prism//lib/prism/node.rb#8251
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8325
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8335
    def type; end
  end
end

# source://prism//lib/prism/node_ext.rb#35
module Prism::HeredocQuery
  # Returns true if this node was represented as a heredoc in the source code.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node_ext.rb#37
  def heredoc?; end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8347
class Prism::IfNode < ::Prism::Node
  # def initialize: (Location? if_keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, Prism::node? consequent, Location? end_keyword_loc, Location location) -> void
  #
  # @return [IfNode] a new instance of IfNode
  #
  # source://prism//lib/prism/node.rb#8349
  def initialize(source, if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8362
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8371
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8385
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8376
  def compact_child_nodes; end

  # attr_reader consequent: Prism::node?
  #
  # source://prism//lib/prism/node.rb#8435
  def consequent; end

  # def copy: (?if_keyword_loc: Location?, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?consequent: Prism::node?, ?end_keyword_loc: Location?, ?location: Location) -> IfNode
  #
  # source://prism//lib/prism/node.rb#8390
  def copy(if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), consequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8371
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { if_keyword_loc: Location?, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: Prism::node?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#8398
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#8462
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8438
  def end_keyword_loc; end

  # def if_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#8452
  def if_keyword; end

  # attr_reader if_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8403
  def if_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8467
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Prism::node
  #
  # source://prism//lib/prism/node.rb#8416
  def predicate; end

  # source://prism//lib/prism/node.rb#8366
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#8432
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#8457
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8419
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8503
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8513
    def type; end
  end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# source://prism//lib/prism/node.rb#8522
class Prism::ImaginaryNode < ::Prism::Node
  # def initialize: (FloatNode | IntegerNode | RationalNode numeric, Location location) -> void
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # source://prism//lib/prism/node.rb#8524
  def initialize(source, numeric, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8532
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8537
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8547
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8542
  def compact_child_nodes; end

  # def copy: (?numeric: FloatNode | IntegerNode | RationalNode, ?location: Location) -> ImaginaryNode
  #
  # source://prism//lib/prism/node.rb#8552
  def copy(numeric: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8537
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { numeric: FloatNode | IntegerNode | RationalNode, location: Location }
  #
  # source://prism//lib/prism/node.rb#8560
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8569
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: FloatNode | IntegerNode | RationalNode
  #
  # source://prism//lib/prism/node.rb#8565
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8590
  def type; end

  # Returns the value of the node as a Ruby Complex.
  #
  # source://prism//lib/prism/node_ext.rb#87
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8600
    def type; end
  end
end

# Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
#     foo in { bar: }
#              ^^^^
#
# source://prism//lib/prism/node.rb#8615
class Prism::ImplicitNode < ::Prism::Node
  # def initialize: (Prism::node value, Location location) -> void
  #
  # @return [ImplicitNode] a new instance of ImplicitNode
  #
  # source://prism//lib/prism/node.rb#8617
  def initialize(source, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8625
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8630
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8640
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8635
  def compact_child_nodes; end

  # def copy: (?value: Prism::node, ?location: Location) -> ImplicitNode
  #
  # source://prism//lib/prism/node.rb#8645
  def copy(value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8630
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#8653
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8662
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8683
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#8658
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8693
    def type; end
  end
end

# Represents using a trailing comma to indicate an implicit rest parameter.
#
#     foo { |bar,| }
#               ^
#
#     foo in [bar,]
#                ^
#
#     for foo, in bar do end
#            ^
#
#     foo, = bar
#        ^
#
# source://prism//lib/prism/node.rb#8711
class Prism::ImplicitRestNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ImplicitRestNode] a new instance of ImplicitRestNode
  #
  # source://prism//lib/prism/node.rb#8713
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8720
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8725
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8735
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8730
  def compact_child_nodes; end

  # def copy: (?location: Location) -> ImplicitRestNode
  #
  # source://prism//lib/prism/node.rb#8740
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8725
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#8748
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8754
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8773
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8783
    def type; end
  end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8792
class Prism::InNode < ::Prism::Node
  # def initialize: (Prism::node pattern, StatementsNode? statements, Location in_loc, Location? then_loc, Location location) -> void
  #
  # @return [InNode] a new instance of InNode
  #
  # source://prism//lib/prism/node.rb#8794
  def initialize(source, pattern, statements, in_loc, then_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8805
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8810
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8823
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8815
  def compact_child_nodes; end

  # def copy: (?pattern: Prism::node, ?statements: StatementsNode?, ?in_loc: Location, ?then_loc: Location?, ?location: Location) -> InNode
  #
  # source://prism//lib/prism/node.rb#8828
  def copy(pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8810
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { pattern: Prism::node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#8836
  def deconstruct_keys(keys); end

  # def in: () -> String
  #
  # source://prism//lib/prism/node.rb#8868
  def in; end

  # attr_reader in_loc: Location
  #
  # source://prism//lib/prism/node.rb#8847
  def in_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#8878
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader pattern: Prism::node
  #
  # source://prism//lib/prism/node.rb#8841
  def pattern; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#8844
  def statements; end

  # def then: () -> String?
  #
  # source://prism//lib/prism/node.rb#8873
  def then; end

  # attr_reader then_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8854
  def then_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#8907
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#8917
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call to the `[]` method.
#
#     foo.bar[baz] &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#8926
class Prism::IndexAndWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Prism::node? block, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [IndexAndWriteNode] a new instance of IndexAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8928
  def initialize(source, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#8944
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#9009
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9043
  def attribute_write?; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9019
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#9053
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#8989
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8949
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9063
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9012
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#8964
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#8954
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: Prism::node?, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> IndexAndWriteNode
  #
  # source://prism//lib/prism/node.rb#8969
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#8949
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Prism::node?, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#8977
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9048
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9073
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9058
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9002
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#9068
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9022
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#8986
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9033
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9118
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#9029
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9038
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#8982
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9128
    def type; end
  end
end

# Represents the use of an assignment operator on a call to `[]`.
#
#     foo.bar[baz] += value
#     ^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9137
class Prism::IndexOperatorWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Prism::node? block, Symbol operator, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [IndexOperatorWriteNode] a new instance of IndexOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#9139
  def initialize(source, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9156
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#9221
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9258
  def attribute_write?; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9231
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#9268
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9201
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9161
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9278
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9224
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9176
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9166
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: Prism::node?, ?operator: Symbol, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> IndexOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#9181
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9161
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Prism::node?, operator: Symbol, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#9189
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9263
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9283
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9273
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9214
  def opening_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#9234
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9237
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9198
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9248
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9329
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#9244
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9253
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#9194
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9339
    def type; end
  end
end

# Represents the use of the `||=` operator on a call to `[]`.
#
#     foo.bar[baz] ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9348
class Prism::IndexOrWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Prism::node? block, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [IndexOrWriteNode] a new instance of IndexOrWriteNode
  #
  # source://prism//lib/prism/node.rb#9350
  def initialize(source, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9366
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#9431
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9465
  def attribute_write?; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9441
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#9475
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#9411
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9371
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9485
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9434
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9386
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9376
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: Prism::node?, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> IndexOrWriteNode
  #
  # source://prism//lib/prism/node.rb#9391
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9371
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Prism::node?, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#9399
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9470
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9495
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9480
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9424
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#9490
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9444
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9408
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9455
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9540
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#9451
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9460
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#9404
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9550
    def type; end
  end
end

# Represents assigning to an index.
#
#     foo[bar], = 1
#     ^^^^^^^^
#
#     begin
#     rescue => foo[bar]
#               ^^^^^^^^
#     end
#
#     for foo[bar] in baz do end
#         ^^^^^^^^
#
# source://prism//lib/prism/node.rb#9567
class Prism::IndexTargetNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node receiver, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Prism::node? block, Location location) -> void
  #
  # @return [IndexTargetNode] a new instance of IndexTargetNode
  #
  # source://prism//lib/prism/node.rb#9569
  def initialize(source, flags, receiver, opening_loc, arguments, closing_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9582
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#9633
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9657
  def attribute_write?; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#9643
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9587
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#9672
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#9636
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9601
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9592
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?receiver: Prism::node, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: Prism::node?, ?location: Location) -> IndexTargetNode
  #
  # source://prism//lib/prism/node.rb#9606
  def copy(flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9587
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Prism::node, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Prism::node?, location: Location }
  #
  # source://prism//lib/prism/node.rb#9614
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9662
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9677
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#9667
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#9626
  def opening_loc; end

  # attr_reader receiver: Prism::node
  #
  # source://prism//lib/prism/node.rb#9623
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9647
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9714
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#9652
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#9619
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9724
    def type; end
  end
end

# InlineComment objects are the most common. They correspond to comments in
# the source file like this one that start with #.
#
# source://prism//lib/prism/parse_result.rb#305
class Prism::InlineComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism//lib/prism/parse_result.rb#313
  def inspect; end

  # Returns true if this comment happens on the same line as other code and
  # false if the comment is by itself.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#308
  def trailing?; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9733
class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [InstanceVariableAndWriteNode] a new instance of InstanceVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#9735
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9746
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9751
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9761
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9756
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> InstanceVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#9766
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9751
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#9774
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#179
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9805
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#9779
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#9782
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#9800
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9789
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9829
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#9796
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9839
    def type; end
  end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9848
class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Symbol operator, Location location) -> void
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#9850
  def initialize(source, name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9862
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9867
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9877
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9872
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?operator: Symbol, ?location: Location) -> InstanceVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#9882
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), operator: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9867
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, operator: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#9890
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#191
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#9919
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#9895
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#9898
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#9915
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#9905
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#9944
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#9912
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#9954
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#9963
class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [InstanceVariableOrWriteNode] a new instance of InstanceVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#9965
  def initialize(source, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#9976
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9981
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#9991
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#9986
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> InstanceVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#9996
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#9981
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#10004
  def deconstruct_keys(keys); end

  # source://prism//lib/prism/desugar_compiler.rb#185
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10035
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10009
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#10012
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10030
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#10019
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10059
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#10026
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10069
    def type; end
  end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# source://prism//lib/prism/node.rb#10078
class Prism::InstanceVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # source://prism//lib/prism/node.rb#10080
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10088
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10093
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10103
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10098
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> InstanceVariableReadNode
  #
  # source://prism//lib/prism/node.rb#10108
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10093
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#10116
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10129
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @x     # name `:@x`
  #
  #     @_test # name `:@_test`
  #
  # source://prism//lib/prism/node.rb#10125
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10149
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10159
    def type; end
  end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
#
# source://prism//lib/prism/node.rb#10168
class Prism::InstanceVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [InstanceVariableTargetNode] a new instance of InstanceVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#10170
  def initialize(source, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10178
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10183
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10193
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10188
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?location: Location) -> InstanceVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#10198
  def copy(name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10183
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#10206
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10215
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#10211
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10235
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10245
    def type; end
  end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#10254
class Prism::InstanceVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Prism::node value, Location operator_loc, Location location) -> void
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#10256
  def initialize(source, name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10267
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10272
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10282
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10277
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location, ?location: Location) -> InstanceVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#10287
  def copy(name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10272
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#10295
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10343
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @x = :y       # name `:@x`
  #
  #     @_foo = "bar" # name `@_foo`
  #
  # source://prism//lib/prism/node.rb#10304
  def name; end

  # The location of the variable name.
  #
  #     @_x = 1
  #     ^^^
  #
  # source://prism//lib/prism/node.rb#10310
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#10338
  def operator; end

  # The location of the `=` operator.
  #
  #     @x = y
  #        ^
  #
  # source://prism//lib/prism/node.rb#10330
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10367
  def type; end

  # The value to assign to the instance variable. Can be any node that
  # represents a non-void expression.
  #
  #     @foo = :bar
  #            ^^^^
  #
  #     @_x = 1234
  #           ^^^^
  #
  # source://prism//lib/prism/node.rb#10324
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10377
    def type; end
  end
end

# Flags for integer nodes that correspond to the base of the integer.
#
# source://prism//lib/prism/node.rb#18850
module Prism::IntegerBaseFlags; end

# 0b prefix
#
# source://prism//lib/prism/node.rb#18852
Prism::IntegerBaseFlags::BINARY = T.let(T.unsafe(nil), Integer)

# 0d or no prefix
#
# source://prism//lib/prism/node.rb#18855
Prism::IntegerBaseFlags::DECIMAL = T.let(T.unsafe(nil), Integer)

# 0x prefix
#
# source://prism//lib/prism/node.rb#18861
Prism::IntegerBaseFlags::HEXADECIMAL = T.let(T.unsafe(nil), Integer)

# 0o or 0 prefix
#
# source://prism//lib/prism/node.rb#18858
Prism::IntegerBaseFlags::OCTAL = T.let(T.unsafe(nil), Integer)

# Represents an integer number literal.
#
#     1
#     ^
#
# source://prism//lib/prism/node.rb#10386
class Prism::IntegerNode < ::Prism::Node
  # def initialize: (Integer flags, Integer value, Location location) -> void
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # source://prism//lib/prism/node.rb#10388
  def initialize(source, flags, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10397
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10438
  def binary?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10402
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10412
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10407
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?value: Integer, ?location: Location) -> IntegerNode
  #
  # source://prism//lib/prism/node.rb#10417
  def copy(flags: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10443
  def decimal?; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10402
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, value: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#10425
  def deconstruct_keys(keys); end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10453
  def hexadecimal?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10458
  def inspect(inspector = T.unsafe(nil)); end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10448
  def octal?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10480
  def type; end

  # The value of the integer literal as a number.
  #
  # source://prism//lib/prism/node.rb#10434
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#10430
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10490
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10499
class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedMatchLastLineNode] a new instance of InterpolatedMatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#10501
  def initialize(source, flags, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10512
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10597
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10522
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#10632
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#10564
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10532
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10527
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location, ?location: Location) -> InterpolatedMatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#10537
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10522
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#10545
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10592
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10577
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10617
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10622
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10612
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10572
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10637
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10582
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10587
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#10627
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#10554
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # source://prism//lib/prism/node.rb#10561
  def parts; end

  # source://prism//lib/prism/node.rb#10516
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10661
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10607
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10602
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#10550
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10671
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10680
class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#10682
  def initialize(source, flags, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10693
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10778
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10703
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#10813
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#10745
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10713
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10708
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location, ?location: Location) -> InterpolatedRegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#10718
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10703
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#10726
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10773
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10758
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10798
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10803
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10793
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10753
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10818
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10763
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10768
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#10808
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#10735
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # source://prism//lib/prism/node.rb#10742
  def parts; end

  # source://prism//lib/prism/node.rb#10697
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10842
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10788
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10783
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#10731
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#10852
    def type; end
  end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#10861
class Prism::InterpolatedStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode] parts, Location? closing_loc, Location location) -> void
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # source://prism//lib/prism/node.rb#10863
  def initialize(source, flags, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#10874
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10884
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#10961
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#10932
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#10894
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#10889
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode], ?closing_loc: Location?, ?location: Location) -> InterpolatedStringNode
  #
  # source://prism//lib/prism/node.rb#10899
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#10884
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode], closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#10907
  def deconstruct_keys(keys); end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10946
  def frozen?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#10966
  def inspect(inspector = T.unsafe(nil)); end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#10951
  def mutable?; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#10956
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#10916
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode]
  #
  # source://prism//lib/prism/node.rb#10929
  def parts; end

  # source://prism//lib/prism/node.rb#10878
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#10990
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#10912
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11000
    def type; end
  end
end

# Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
#
# source://prism//lib/prism/node.rb#18865
module Prism::InterpolatedStringNodeFlags; end

# source://prism//lib/prism/node.rb#18867
Prism::InterpolatedStringNodeFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# source://prism//lib/prism/node.rb#18870
Prism::InterpolatedStringNodeFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11009
class Prism::InterpolatedSymbolNode < ::Prism::Node
  # def initialize: (Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location? closing_loc, Location location) -> void
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # source://prism//lib/prism/node.rb#11011
  def initialize(source, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11021
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11031
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#11094
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11075
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11041
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11036
  def compact_child_nodes; end

  # def copy: (?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location?, ?location: Location) -> InterpolatedSymbolNode
  #
  # source://prism//lib/prism/node.rb#11046
  def copy(opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11031
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#11054
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11099
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#11089
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11059
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # source://prism//lib/prism/node.rb#11072
  def parts; end

  # source://prism//lib/prism/node.rb#11025
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11121
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11131
    def type; end
  end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11140
class Prism::InterpolatedXStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # source://prism//lib/prism/node.rb#11142
  def initialize(source, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11152
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11162
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#11213
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#11200
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11172
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11167
  def compact_child_nodes; end

  # def copy: (?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location, ?location: Location) -> InterpolatedXStringNode
  #
  # source://prism//lib/prism/node.rb#11177
  def copy(opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11162
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#11185
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11218
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#11208
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#11190
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # source://prism//lib/prism/node.rb#11197
  def parts; end

  # source://prism//lib/prism/node.rb#11156
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11240
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11250
    def type; end
  end
end

# Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
#
#     -> { it + it }
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11259
class Prism::ItParametersNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ItParametersNode] a new instance of ItParametersNode
  #
  # source://prism//lib/prism/node.rb#11261
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11268
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11273
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11283
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11278
  def compact_child_nodes; end

  # def copy: (?location: Location) -> ItParametersNode
  #
  # source://prism//lib/prism/node.rb#11288
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11273
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#11296
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11302
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11321
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11331
    def type; end
  end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# source://prism//lib/prism/node.rb#11340
class Prism::KeywordHashNode < ::Prism::Node
  # def initialize: (Integer flags, Array[AssocNode | AssocSplatNode] elements, Location location) -> void
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # source://prism//lib/prism/node.rb#11342
  def initialize(source, flags, elements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11351
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11356
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11366
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11361
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?elements: Array[AssocNode | AssocSplatNode], ?location: Location) -> KeywordHashNode
  #
  # source://prism//lib/prism/node.rb#11371
  def copy(flags: T.unsafe(nil), elements: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11356
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, elements: Array[AssocNode | AssocSplatNode], location: Location }
  #
  # source://prism//lib/prism/node.rb#11379
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[AssocNode | AssocSplatNode]
  #
  # source://prism//lib/prism/node.rb#11388
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11397
  def inspect(inspector = T.unsafe(nil)); end

  # def symbol_keys?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11392
  def symbol_keys?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11419
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#11384
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11429
    def type; end
  end
end

# Flags for keyword hash nodes.
#
# source://prism//lib/prism/node.rb#18874
module Prism::KeywordHashNodeFlags; end

# a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
#
# source://prism//lib/prism/node.rb#18876
Prism::KeywordHashNodeFlags::SYMBOL_KEYS = T.let(T.unsafe(nil), Integer)

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# source://prism//lib/prism/node.rb#11439
class Prism::KeywordRestParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # source://prism//lib/prism/node.rb#11441
  def initialize(source, flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11452
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11457
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11467
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11462
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location, ?location: Location) -> KeywordRestParameterNode
  #
  # source://prism//lib/prism/node.rb#11472
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11457
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#11480
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11523
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#11489
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#11492
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11518
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11505
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#11513
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11551
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#11485
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11561
    def type; end
  end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11570
class Prism::LambdaNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location operator_loc, Location opening_loc, Location closing_loc, Prism::node? parameters, Prism::node? body, Location location) -> void
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # source://prism//lib/prism/node.rb#11572
  def initialize(source, locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11585
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#11648
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11590
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#11662
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#11638
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11603
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11595
  def compact_child_nodes; end

  # def copy: (?locals: Array[Symbol], ?operator_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?parameters: Prism::node?, ?body: Prism::node?, ?location: Location) -> LambdaNode
  #
  # source://prism//lib/prism/node.rb#11608
  def copy(locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11590
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: Prism::node?, body: Prism::node?, location: Location }
  #
  # source://prism//lib/prism/node.rb#11616
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11667
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#11621
  def locals; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#11657
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#11631
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11652
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11624
  def operator_loc; end

  # attr_reader parameters: Prism::node?
  #
  # source://prism//lib/prism/node.rb#11645
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11702
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11712
    def type; end
  end
end

# This class is responsible for lexing the source using prism and then
# converting those tokens to be compatible with Ripper. In the vast majority
# of cases, this is a one-to-one mapping of the token type. Everything else
# generally lines up. However, there are a few cases that require special
# handling.
#
# source://prism//lib/prism/lex_compat.rb#12
class Prism::LexCompat
  # @return [LexCompat] a new instance of LexCompat
  #
  # source://prism//lib/prism/lex_compat.rb#602
  def initialize(source, **options); end

  # Returns the value of attribute options.
  #
  # source://prism//lib/prism/lex_compat.rb#600
  def options; end

  # source://prism//lib/prism/lex_compat.rb#607
  def result; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/lex_compat.rb#600
  def source; end
end

# Ripper doesn't include the rest of the token in the event, so we need to
# trim it down to just the content on the first line when comparing.
#
# source://prism//lib/prism/lex_compat.rb#213
class Prism::LexCompat::EndContentToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#214
  def ==(other); end
end

# A heredoc in this case is a list of tokens that belong to the body of the
# heredoc that should be appended onto the list of tokens when the heredoc
# closes.
#
# source://prism//lib/prism/lex_compat.rb#274
module Prism::LexCompat::Heredoc
  class << self
    # Here we will split between the two types of heredocs and return the
    # object that will store their tokens.
    #
    # source://prism//lib/prism/lex_compat.rb#586
    def build(opening); end
  end
end

# Dash heredocs are a little more complicated. They are a list of tokens
# that need to be split on "\\\n" to mimic Ripper's behavior. We also need
# to keep track of the state that the heredoc was opened in.
#
# source://prism//lib/prism/lex_compat.rb#298
class Prism::LexCompat::Heredoc::DashHeredoc
  # @return [DashHeredoc] a new instance of DashHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#301
  def initialize(split); end

  # source://prism//lib/prism/lex_compat.rb#306
  def <<(token); end

  # source://prism//lib/prism/lex_compat.rb#299
  def split; end

  # source://prism//lib/prism/lex_compat.rb#310
  def to_a; end

  # source://prism//lib/prism/lex_compat.rb#299
  def tokens; end
end

# Heredocs that are dedenting heredocs are a little more complicated.
# Ripper outputs on_ignored_sp tokens for the whitespace that is being
# removed from the output. prism only modifies the node itself and keeps
# the token the same. This simplifies prism, but makes comparing against
# Ripper much harder because there is a length mismatch.
#
# Fortunately, we already have to pull out the heredoc tokens in order to
# insert them into the stream in the correct order. As such, we can do
# some extra manipulation on the tokens to make them match Ripper's
# output by mirroring the dedent logic that Ripper uses.
#
# source://prism//lib/prism/lex_compat.rb#357
class Prism::LexCompat::Heredoc::DedentingHeredoc
  # @return [DedentingHeredoc] a new instance of DedentingHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#362
  def initialize; end

  # As tokens are coming in, we track the minimum amount of common leading
  # whitespace on plain string content tokens. This allows us to later
  # remove that amount of whitespace from the beginning of each line.
  #
  # source://prism//lib/prism/lex_compat.rb#373
  def <<(token); end

  # Returns the value of attribute dedent.
  #
  # source://prism//lib/prism/lex_compat.rb#360
  def dedent; end

  # Returns the value of attribute dedent_next.
  #
  # source://prism//lib/prism/lex_compat.rb#360
  def dedent_next; end

  # Returns the value of attribute embexpr_balance.
  #
  # source://prism//lib/prism/lex_compat.rb#360
  def embexpr_balance; end

  # source://prism//lib/prism/lex_compat.rb#410
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://prism//lib/prism/lex_compat.rb#360
  def tokens; end
end

# source://prism//lib/prism/lex_compat.rb#358
Prism::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# Heredocs that are no dash or tilde heredocs are just a list of tokens.
# We need to keep them around so that we can insert them in the correct
# order back into the token stream and set the state of the last token to
# the state that the heredoc was opened in.
#
# source://prism//lib/prism/lex_compat.rb#279
class Prism::LexCompat::Heredoc::PlainHeredoc
  # @return [PlainHeredoc] a new instance of PlainHeredoc
  #
  # source://prism//lib/prism/lex_compat.rb#282
  def initialize; end

  # source://prism//lib/prism/lex_compat.rb#286
  def <<(token); end

  # source://prism//lib/prism/lex_compat.rb#290
  def to_a; end

  # source://prism//lib/prism/lex_compat.rb#280
  def tokens; end
end

# Ident tokens for the most part are exactly the same, except sometimes we
# know an ident is a local when ripper doesn't (when they are introduced
# through named captures in regular expressions). In that case we don't
# compare the state.
#
# source://prism//lib/prism/lex_compat.rb#231
class Prism::LexCompat::IdentToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#232
  def ==(other); end
end

# Tokens where state should be ignored
# used for :on_comment, :on_heredoc_end, :on_embexpr_end
#
# source://prism//lib/prism/lex_compat.rb#221
class Prism::LexCompat::IgnoreStateToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#222
  def ==(other); end
end

# Ignored newlines can occasionally have a LABEL state attached to them, so
# we compare the state differently here.
#
# source://prism//lib/prism/lex_compat.rb#242
class Prism::LexCompat::IgnoredNewlineToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#243
  def ==(other); end
end

# If we have an identifier that follows a method name like:
#
#     def foo bar
#
# then Ripper will mark bar as END|LABEL if there is a local in a parent
# scope named bar because it hasn't pushed the local table yet. We do this
# more accurately, so we need to allow comparing against both END and
# END|LABEL.
#
# source://prism//lib/prism/lex_compat.rb#262
class Prism::LexCompat::ParamToken < ::Prism::LexCompat::Token
  # source://prism//lib/prism/lex_compat.rb#263
  def ==(other); end
end

# This is a mapping of prism token types to Ripper token types. This is a
# many-to-one mapping because we split up our token types, whereas Ripper
# tends to group them.
#
# source://prism//lib/prism/lex_compat.rb#16
Prism::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

# When we produce tokens, we produce the same arrays that Ripper does.
# However, we add a couple of convenience methods onto them to make them a
# little easier to work with. We delegate all other methods to the array.
#
# source://prism//lib/prism/lex_compat.rb#187
class Prism::LexCompat::Token < ::SimpleDelegator
  # The type of the token.
  #
  # source://prism//lib/prism/lex_compat.rb#196
  def event; end

  # The location of the token in the source.
  #
  # source://prism//lib/prism/lex_compat.rb#191
  def location; end

  # The state of the lexer when this token was produced.
  #
  # source://prism//lib/prism/lex_compat.rb#206
  def state; end

  # The slice of the source that this token represents.
  #
  # source://prism//lib/prism/lex_compat.rb#201
  def value; end
end

# This is a class that wraps the Ripper lexer to produce almost exactly the
# same tokens.
#
# source://prism//lib/prism/lex_compat.rb#855
class Prism::LexRipper
  # @return [LexRipper] a new instance of LexRipper
  #
  # source://prism//lib/prism/lex_compat.rb#858
  def initialize(source); end

  # source://prism//lib/prism/lex_compat.rb#862
  def result; end

  # source://prism//lib/prism/lex_compat.rb#856
  def source; end

  private

  # source://prism//lib/prism/lex_compat.rb#896
  def lex(source); end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11721
class Prism::LocalVariableAndWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableAndWriteNode] a new instance of LocalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#11723
  def initialize(source, name_loc, operator_loc, value, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11735
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11740
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11750
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11745
  def compact_child_nodes; end

  # def copy: (?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer, ?location: Location) -> LocalVariableAndWriteNode
  #
  # source://prism//lib/prism/node.rb#11755
  def copy(name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11740
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#11763
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#11788
  def depth; end

  # source://prism//lib/prism/desugar_compiler.rb#197
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11797
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#11785
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#11768
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#11792
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11775
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11822
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#11782
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11832
    def type; end
  end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11841
class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Prism::node value, Symbol name, Symbol operator, Integer depth, Location location) -> void
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#11843
  def initialize(source, name_loc, operator_loc, value, name, operator, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11856
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11861
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11871
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11866
  def compact_child_nodes; end

  # def copy: (?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?operator: Symbol, ?depth: Integer, ?location: Location) -> LocalVariableOperatorWriteNode
  #
  # source://prism//lib/prism/node.rb#11876
  def copy(name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), operator: T.unsafe(nil), depth: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11861
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, operator: Symbol, depth: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#11884
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#11912
  def depth; end

  # source://prism//lib/prism/desugar_compiler.rb#209
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#11916
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#11906
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#11889
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism//lib/prism/node.rb#11909
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#11896
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#11942
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#11903
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#11952
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#11961
class Prism::LocalVariableOrWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableOrWriteNode] a new instance of LocalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#11963
  def initialize(source, name_loc, operator_loc, value, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#11975
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11980
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#11990
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#11985
  def compact_child_nodes; end

  # def copy: (?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer, ?location: Location) -> LocalVariableOrWriteNode
  #
  # source://prism//lib/prism/node.rb#11995
  def copy(name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#11980
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#12003
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#12028
  def depth; end

  # source://prism//lib/prism/desugar_compiler.rb#203
  def desugar; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12037
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#12025
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#12008
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12032
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12015
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12062
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#12022
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12072
    def type; end
  end
end

# Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# source://prism//lib/prism/node.rb#12081
class Prism::LocalVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#12083
  def initialize(source, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12092
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12097
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12107
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12102
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?depth: Integer, ?location: Location) -> LocalVariableReadNode
  #
  # source://prism//lib/prism/node.rb#12112
  def copy(name: T.unsafe(nil), depth: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12097
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#12120
  def deconstruct_keys(keys); end

  # The number of visible scopes that should be searched to find the origin of this local variable.
  #
  #     foo = 1; foo # depth 0
  #
  #     bar = 2; tap { bar } # depth 1
  #
  # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
  #
  # source://prism//lib/prism/node.rb#12146
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12150
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     x      # name `:x`
  #
  #     _Test  # name `:_Test`
  #
  # Note that this can also be an underscore followed by a number for the default block parameters.
  #
  #     _1     # name `:_1`
  #
  # Finally, for the default `it` block parameter, the name is `0it`. This is to distinguish it from an `it` local variable that is explicitly declared.
  #
  #     it     # name `:0it`
  #
  # source://prism//lib/prism/node.rb#12137
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12171
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12181
    def type; end
  end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
#
# source://prism//lib/prism/node.rb#12190
class Prism::LocalVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableTargetNode] a new instance of LocalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#12192
  def initialize(source, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12201
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12206
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12216
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12211
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?depth: Integer, ?location: Location) -> LocalVariableTargetNode
  #
  # source://prism//lib/prism/node.rb#12221
  def copy(name: T.unsafe(nil), depth: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12206
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#12229
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#12237
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12241
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#12234
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12262
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12272
    def type; end
  end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#12281
class Prism::LocalVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location name_loc, Prism::node value, Location operator_loc, Location location) -> void
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#12283
  def initialize(source, name, depth, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12295
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12300
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12310
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12305
  def compact_child_nodes; end

  # def copy: (?name: Symbol, ?depth: Integer, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location, ?location: Location) -> LocalVariableWriteNode
  #
  # source://prism//lib/prism/node.rb#12315
  def copy(name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12300
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, name_loc: Location, value: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#12323
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism//lib/prism/node.rb#12331
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12357
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#12328
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#12334
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12352
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12344
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12382
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#12341
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12392
    def type; end
  end
end

# This represents a location in the source.
#
# source://prism//lib/prism/parse_result.rb#104
class Prism::Location
  # Create a new location object with the given source, start byte offset, and
  # byte length.
  #
  # @return [Location] a new instance of Location
  #
  # source://prism//lib/prism/parse_result.rb#119
  def initialize(source, start_offset, length); end

  # Returns true if the given other location is equal to this location.
  #
  # source://prism//lib/prism/parse_result.rb#264
  def ==(other); end

  # Returns all comments that are associated with this location (both leading
  # and trailing comments).
  #
  # source://prism//lib/prism/parse_result.rb#155
  def comments; end

  # Create a new location object with the given options.
  #
  # source://prism//lib/prism/parse_result.rb#160
  def copy(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  # Implement the hash pattern matching interface for Location.
  #
  # source://prism//lib/prism/parse_result.rb#254
  def deconstruct_keys(keys); end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#243
  def end_character_column; end

  # The character offset from the beginning of the source where this location
  # ends.
  #
  # source://prism//lib/prism/parse_result.rb#192
  def end_character_offset; end

  # The column number in code units of the given encoding where this location
  # ends from the start of the line.
  #
  # source://prism//lib/prism/parse_result.rb#249
  def end_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # source://prism//lib/prism/parse_result.rb#197
  def end_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # source://prism//lib/prism/parse_result.rb#237
  def end_column; end

  # The line number where this location ends.
  #
  # source://prism//lib/prism/parse_result.rb#213
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # source://prism//lib/prism/parse_result.rb#186
  def end_offset; end

  # Returns a string representation of this location.
  #
  # source://prism//lib/prism/parse_result.rb#165
  def inspect; end

  # Returns a new location that stretches from this location to the given
  # other location. Raises an error if this location is not before the other
  # location or if they don't share the same source.
  #
  # source://prism//lib/prism/parse_result.rb#273
  def join(other); end

  # Attach a comment to the leading comments of this location.
  #
  # source://prism//lib/prism/parse_result.rb#138
  def leading_comment(comment); end

  # These are the comments that are associated with this location that exist
  # before the start of this location.
  #
  # source://prism//lib/prism/parse_result.rb#133
  def leading_comments; end

  # The length of this location in bytes.
  #
  # source://prism//lib/prism/parse_result.rb#115
  def length; end

  # Implement the pretty print interface for Location.
  #
  # source://prism//lib/prism/parse_result.rb#259
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # source://prism//lib/prism/parse_result.rb#170
  def slice; end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#225
  def start_character_column; end

  # The character offset from the beginning of the source where this location
  # starts.
  #
  # source://prism//lib/prism/parse_result.rb#176
  def start_character_offset; end

  # The column number in code units of the given encoding where this location
  # starts from the start of the line.
  #
  # source://prism//lib/prism/parse_result.rb#231
  def start_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # source://prism//lib/prism/parse_result.rb#181
  def start_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # source://prism//lib/prism/parse_result.rb#219
  def start_column; end

  # The line number where this location starts.
  #
  # source://prism//lib/prism/parse_result.rb#202
  def start_line; end

  # The content of the line where this location starts before this location.
  #
  # source://prism//lib/prism/parse_result.rb#207
  def start_line_slice; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # source://prism//lib/prism/parse_result.rb#112
  def start_offset; end

  # Attach a comment to the trailing comments of this location.
  #
  # source://prism//lib/prism/parse_result.rb#149
  def trailing_comment(comment); end

  # These are the comments that are associated with this location that exist
  # after the end of this location.
  #
  # source://prism//lib/prism/parse_result.rb#144
  def trailing_comments; end

  protected

  # A Source object that is used to determine more information from the given
  # offset and length.
  #
  # source://prism//lib/prism/parse_result.rb#107
  def source; end
end

# Flags for while and until loop nodes.
#
# source://prism//lib/prism/node.rb#18880
module Prism::LoopFlags; end

# a loop after a begin statement, so the body is executed first before the condition
#
# source://prism//lib/prism/node.rb#18882
Prism::LoopFlags::BEGIN_MODIFIER = T.let(T.unsafe(nil), Integer)

# This represents a magic comment that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#333
class Prism::MagicComment
  # Create a new magic comment object with the given key and value locations.
  #
  # @return [MagicComment] a new instance of MagicComment
  #
  # source://prism//lib/prism/parse_result.rb#341
  def initialize(key_loc, value_loc); end

  # Implement the hash pattern matching interface for MagicComment.
  #
  # source://prism//lib/prism/parse_result.rb#357
  def deconstruct_keys(keys); end

  # Returns a string representation of this magic comment.
  #
  # source://prism//lib/prism/parse_result.rb#362
  def inspect; end

  # Returns the key of the magic comment by slicing it from the source code.
  #
  # source://prism//lib/prism/parse_result.rb#347
  def key; end

  # A Location object representing the location of the key in the source.
  #
  # source://prism//lib/prism/parse_result.rb#335
  def key_loc; end

  # Returns the value of the magic comment by slicing it from the source code.
  #
  # source://prism//lib/prism/parse_result.rb#352
  def value; end

  # A Location object representing the location of the value in the source.
  #
  # source://prism//lib/prism/parse_result.rb#338
  def value_loc; end
end

# Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo/i then end
#        ^^^^^^
#
# source://prism//lib/prism/node.rb#12401
class Prism::MatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [MatchLastLineNode] a new instance of MatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#12403
  def initialize(source, flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12415
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12502
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12420
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#12542
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#12466
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12430
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12425
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#12537
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#12459
  def content_loc; end

  # def copy: (?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String, ?location: Location) -> MatchLastLineNode
  #
  # source://prism//lib/prism/node.rb#12435
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12420
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#12443
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12497
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12482
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12522
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12527
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12517
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12477
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12547
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12487
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12492
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#12532
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#12452
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12572
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#12473
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12512
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#12507
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#12448
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12582
    def type; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12591
class Prism::MatchPredicateNode < ::Prism::Node
  # def initialize: (Prism::node value, Prism::node pattern, Location operator_loc, Location location) -> void
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # source://prism//lib/prism/node.rb#12593
  def initialize(source, value, pattern, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12603
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12608
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12618
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12613
  def compact_child_nodes; end

  # def copy: (?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location, ?location: Location) -> MatchPredicateNode
  #
  # source://prism//lib/prism/node.rb#12623
  def copy(value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12608
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Prism::node, pattern: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#12631
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12655
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12650
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12642
  def operator_loc; end

  # attr_reader pattern: Prism::node
  #
  # source://prism//lib/prism/node.rb#12639
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12679
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#12636
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12689
    def type; end
  end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12698
class Prism::MatchRequiredNode < ::Prism::Node
  # def initialize: (Prism::node value, Prism::node pattern, Location operator_loc, Location location) -> void
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # source://prism//lib/prism/node.rb#12700
  def initialize(source, value, pattern, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12710
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12715
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12725
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12720
  def compact_child_nodes; end

  # def copy: (?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location, ?location: Location) -> MatchRequiredNode
  #
  # source://prism//lib/prism/node.rb#12730
  def copy(value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12715
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Prism::node, pattern: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#12738
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12762
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#12757
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#12749
  def operator_loc; end

  # attr_reader pattern: Prism::node
  #
  # source://prism//lib/prism/node.rb#12746
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12786
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#12743
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12796
    def type; end
  end
end

# Represents writing local variables using a regular expression match with named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12805
class Prism::MatchWriteNode < ::Prism::Node
  # def initialize: (CallNode call, Array[LocalVariableTargetNode] targets, Location location) -> void
  #
  # @return [MatchWriteNode] a new instance of MatchWriteNode
  #
  # source://prism//lib/prism/node.rb#12807
  def initialize(source, call, targets, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12816
  def accept(visitor); end

  # attr_reader call: CallNode
  #
  # source://prism//lib/prism/node.rb#12849
  def call; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12821
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12831
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12826
  def compact_child_nodes; end

  # def copy: (?call: CallNode, ?targets: Array[LocalVariableTargetNode], ?location: Location) -> MatchWriteNode
  #
  # source://prism//lib/prism/node.rb#12836
  def copy(call: T.unsafe(nil), targets: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12821
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { call: CallNode, targets: Array[LocalVariableTargetNode], location: Location }
  #
  # source://prism//lib/prism/node.rb#12844
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12856
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader targets: Array[LocalVariableTargetNode]
  #
  # source://prism//lib/prism/node.rb#12852
  def targets; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12878
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12888
    def type; end
  end
end

# Represents a node that is missing from the source and results in a syntax error.
#
# source://prism//lib/prism/node.rb#12894
class Prism::MissingNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # source://prism//lib/prism/node.rb#12896
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12903
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12908
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#12918
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#12913
  def compact_child_nodes; end

  # def copy: (?location: Location) -> MissingNode
  #
  # source://prism//lib/prism/node.rb#12923
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12908
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#12931
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#12937
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#12956
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#12966
    def type; end
  end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#12975
class Prism::ModuleNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location module_keyword_loc, Prism::node constant_path, Prism::node? body, Location end_keyword_loc, Symbol name, Location location) -> void
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # source://prism//lib/prism/node.rb#12977
  def initialize(source, locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#12990
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#13039
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12995
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13008
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13000
  def compact_child_nodes; end

  # attr_reader constant_path: Prism::node
  #
  # source://prism//lib/prism/node.rb#13036
  def constant_path; end

  # def copy: (?locals: Array[Symbol], ?module_keyword_loc: Location, ?constant_path: Prism::node, ?body: Prism::node?, ?end_keyword_loc: Location, ?name: Symbol, ?location: Location) -> ModuleNode
  #
  # source://prism//lib/prism/node.rb#13013
  def copy(locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#12995
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], module_keyword_loc: Location, constant_path: Prism::node, body: Prism::node?, end_keyword_loc: Location, name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#13021
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13058
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13042
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13063
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#13026
  def locals; end

  # def module_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13053
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13029
  def module_keyword_loc; end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#13049
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13094
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13104
    def type; end
  end
end

# Represents a multi-target expression.
#
#     a, (b, c) = 1, 2, 3
#        ^^^^^^
#
# source://prism//lib/prism/node.rb#13113
class Prism::MultiTargetNode < ::Prism::Node
  # def initialize: (Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, Prism::node? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc, Location location) -> void
  #
  # @return [MultiTargetNode] a new instance of MultiTargetNode
  #
  # source://prism//lib/prism/node.rb#13115
  def initialize(source, lefts, rest, rights, lparen_loc, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13127
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13132
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13146
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13137
  def compact_child_nodes; end

  # def copy: (?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: Prism::node?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?location: Location) -> MultiTargetNode
  #
  # source://prism//lib/prism/node.rb#13151
  def copy(lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13132
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], rest: Prism::node?, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode], lparen_loc: Location?, rparen_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#13159
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13210
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
  #
  # source://prism//lib/prism/node.rb#13164
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#13200
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#13173
  def lparen_loc; end

  # attr_reader rest: Prism::node?
  #
  # source://prism//lib/prism/node.rb#13167
  def rest; end

  # attr_reader rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode]
  #
  # source://prism//lib/prism/node.rb#13170
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#13205
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#13186
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13239
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13249
    def type; end
  end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#13258
class Prism::MultiWriteNode < ::Prism::Node
  # def initialize: (Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode] lefts, Prism::node? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode] rights, Location? lparen_loc, Location? rparen_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # source://prism//lib/prism/node.rb#13260
  def initialize(source, lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13274
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13279
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13294
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13284
  def compact_child_nodes; end

  # def copy: (?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode], ?rest: Prism::node?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> MultiWriteNode
  #
  # source://prism//lib/prism/node.rb#13299
  def copy(lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13279
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode], rest: Prism::node?, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#13307
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13373
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode]
  #
  # source://prism//lib/prism/node.rb#13312
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#13358
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#13321
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#13368
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#13347
  def operator_loc; end

  # attr_reader rest: Prism::node?
  #
  # source://prism//lib/prism/node.rb#13315
  def rest; end

  # attr_reader rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode]
  #
  # source://prism//lib/prism/node.rb#13318
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#13363
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#13334
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13405
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#13354
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13415
    def type; end
  end
end

# This visitor walks through the tree and copies each node as it is being
# visited. This is useful for consumers that want to mutate the tree, as you
# can change subtrees in place without effecting the rest of the tree.
#
# source://prism//lib/prism/mutation_compiler.rb#13
class Prism::MutationCompiler < ::Prism::Compiler
  # Copy a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#15
  def visit_alias_global_variable_node(node); end

  # Copy a AliasMethodNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#20
  def visit_alias_method_node(node); end

  # Copy a AlternationPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#25
  def visit_alternation_pattern_node(node); end

  # Copy a AndNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#30
  def visit_and_node(node); end

  # Copy a ArgumentsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#35
  def visit_arguments_node(node); end

  # Copy a ArrayNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#40
  def visit_array_node(node); end

  # Copy a ArrayPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#45
  def visit_array_pattern_node(node); end

  # Copy a AssocNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#50
  def visit_assoc_node(node); end

  # Copy a AssocSplatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#55
  def visit_assoc_splat_node(node); end

  # Copy a BackReferenceReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#60
  def visit_back_reference_read_node(node); end

  # Copy a BeginNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#65
  def visit_begin_node(node); end

  # Copy a BlockArgumentNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#70
  def visit_block_argument_node(node); end

  # Copy a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#75
  def visit_block_local_variable_node(node); end

  # Copy a BlockNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#80
  def visit_block_node(node); end

  # Copy a BlockParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#85
  def visit_block_parameter_node(node); end

  # Copy a BlockParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#90
  def visit_block_parameters_node(node); end

  # Copy a BreakNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#95
  def visit_break_node(node); end

  # Copy a CallAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#100
  def visit_call_and_write_node(node); end

  # Copy a CallNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#105
  def visit_call_node(node); end

  # Copy a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#110
  def visit_call_operator_write_node(node); end

  # Copy a CallOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#115
  def visit_call_or_write_node(node); end

  # Copy a CallTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#120
  def visit_call_target_node(node); end

  # Copy a CapturePatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#125
  def visit_capture_pattern_node(node); end

  # Copy a CaseMatchNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#130
  def visit_case_match_node(node); end

  # Copy a CaseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#135
  def visit_case_node(node); end

  # Copy a ClassNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#140
  def visit_class_node(node); end

  # Copy a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#145
  def visit_class_variable_and_write_node(node); end

  # Copy a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#150
  def visit_class_variable_operator_write_node(node); end

  # Copy a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#155
  def visit_class_variable_or_write_node(node); end

  # Copy a ClassVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#160
  def visit_class_variable_read_node(node); end

  # Copy a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#165
  def visit_class_variable_target_node(node); end

  # Copy a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#170
  def visit_class_variable_write_node(node); end

  # Copy a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#175
  def visit_constant_and_write_node(node); end

  # Copy a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#180
  def visit_constant_operator_write_node(node); end

  # Copy a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#185
  def visit_constant_or_write_node(node); end

  # Copy a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#190
  def visit_constant_path_and_write_node(node); end

  # Copy a ConstantPathNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#195
  def visit_constant_path_node(node); end

  # Copy a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#200
  def visit_constant_path_operator_write_node(node); end

  # Copy a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#205
  def visit_constant_path_or_write_node(node); end

  # Copy a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#210
  def visit_constant_path_target_node(node); end

  # Copy a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#215
  def visit_constant_path_write_node(node); end

  # Copy a ConstantReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#220
  def visit_constant_read_node(node); end

  # Copy a ConstantTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#225
  def visit_constant_target_node(node); end

  # Copy a ConstantWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#230
  def visit_constant_write_node(node); end

  # Copy a DefNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#235
  def visit_def_node(node); end

  # Copy a DefinedNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#240
  def visit_defined_node(node); end

  # Copy a ElseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#245
  def visit_else_node(node); end

  # Copy a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#250
  def visit_embedded_statements_node(node); end

  # Copy a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#255
  def visit_embedded_variable_node(node); end

  # Copy a EnsureNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#260
  def visit_ensure_node(node); end

  # Copy a FalseNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#265
  def visit_false_node(node); end

  # Copy a FindPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#270
  def visit_find_pattern_node(node); end

  # Copy a FlipFlopNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#275
  def visit_flip_flop_node(node); end

  # Copy a FloatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#280
  def visit_float_node(node); end

  # Copy a ForNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#285
  def visit_for_node(node); end

  # Copy a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#290
  def visit_forwarding_arguments_node(node); end

  # Copy a ForwardingParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#295
  def visit_forwarding_parameter_node(node); end

  # Copy a ForwardingSuperNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#300
  def visit_forwarding_super_node(node); end

  # Copy a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#305
  def visit_global_variable_and_write_node(node); end

  # Copy a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#310
  def visit_global_variable_operator_write_node(node); end

  # Copy a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#315
  def visit_global_variable_or_write_node(node); end

  # Copy a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#320
  def visit_global_variable_read_node(node); end

  # Copy a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#325
  def visit_global_variable_target_node(node); end

  # Copy a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#330
  def visit_global_variable_write_node(node); end

  # Copy a HashNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#335
  def visit_hash_node(node); end

  # Copy a HashPatternNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#340
  def visit_hash_pattern_node(node); end

  # Copy a IfNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#345
  def visit_if_node(node); end

  # Copy a ImaginaryNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#350
  def visit_imaginary_node(node); end

  # Copy a ImplicitNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#355
  def visit_implicit_node(node); end

  # Copy a ImplicitRestNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#360
  def visit_implicit_rest_node(node); end

  # Copy a InNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#365
  def visit_in_node(node); end

  # Copy a IndexAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#370
  def visit_index_and_write_node(node); end

  # Copy a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#375
  def visit_index_operator_write_node(node); end

  # Copy a IndexOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#380
  def visit_index_or_write_node(node); end

  # Copy a IndexTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#385
  def visit_index_target_node(node); end

  # Copy a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#390
  def visit_instance_variable_and_write_node(node); end

  # Copy a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#395
  def visit_instance_variable_operator_write_node(node); end

  # Copy a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#400
  def visit_instance_variable_or_write_node(node); end

  # Copy a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#405
  def visit_instance_variable_read_node(node); end

  # Copy a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#410
  def visit_instance_variable_target_node(node); end

  # Copy a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#415
  def visit_instance_variable_write_node(node); end

  # Copy a IntegerNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#420
  def visit_integer_node(node); end

  # Copy a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#425
  def visit_interpolated_match_last_line_node(node); end

  # Copy a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#430
  def visit_interpolated_regular_expression_node(node); end

  # Copy a InterpolatedStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#435
  def visit_interpolated_string_node(node); end

  # Copy a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#440
  def visit_interpolated_symbol_node(node); end

  # Copy a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#445
  def visit_interpolated_x_string_node(node); end

  # Copy a ItParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#450
  def visit_it_parameters_node(node); end

  # Copy a KeywordHashNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#455
  def visit_keyword_hash_node(node); end

  # Copy a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#460
  def visit_keyword_rest_parameter_node(node); end

  # Copy a LambdaNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#465
  def visit_lambda_node(node); end

  # Copy a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#470
  def visit_local_variable_and_write_node(node); end

  # Copy a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#475
  def visit_local_variable_operator_write_node(node); end

  # Copy a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#480
  def visit_local_variable_or_write_node(node); end

  # Copy a LocalVariableReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#485
  def visit_local_variable_read_node(node); end

  # Copy a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#490
  def visit_local_variable_target_node(node); end

  # Copy a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#495
  def visit_local_variable_write_node(node); end

  # Copy a MatchLastLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#500
  def visit_match_last_line_node(node); end

  # Copy a MatchPredicateNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#505
  def visit_match_predicate_node(node); end

  # Copy a MatchRequiredNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#510
  def visit_match_required_node(node); end

  # Copy a MatchWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#515
  def visit_match_write_node(node); end

  # Copy a MissingNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#520
  def visit_missing_node(node); end

  # Copy a ModuleNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#525
  def visit_module_node(node); end

  # Copy a MultiTargetNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#530
  def visit_multi_target_node(node); end

  # Copy a MultiWriteNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#535
  def visit_multi_write_node(node); end

  # Copy a NextNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#540
  def visit_next_node(node); end

  # Copy a NilNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#545
  def visit_nil_node(node); end

  # Copy a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#550
  def visit_no_keywords_parameter_node(node); end

  # Copy a NumberedParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#555
  def visit_numbered_parameters_node(node); end

  # Copy a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#560
  def visit_numbered_reference_read_node(node); end

  # Copy a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#565
  def visit_optional_keyword_parameter_node(node); end

  # Copy a OptionalParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#570
  def visit_optional_parameter_node(node); end

  # Copy a OrNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#575
  def visit_or_node(node); end

  # Copy a ParametersNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#580
  def visit_parameters_node(node); end

  # Copy a ParenthesesNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#585
  def visit_parentheses_node(node); end

  # Copy a PinnedExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#590
  def visit_pinned_expression_node(node); end

  # Copy a PinnedVariableNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#595
  def visit_pinned_variable_node(node); end

  # Copy a PostExecutionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#600
  def visit_post_execution_node(node); end

  # Copy a PreExecutionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#605
  def visit_pre_execution_node(node); end

  # Copy a ProgramNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#610
  def visit_program_node(node); end

  # Copy a RangeNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#615
  def visit_range_node(node); end

  # Copy a RationalNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#620
  def visit_rational_node(node); end

  # Copy a RedoNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#625
  def visit_redo_node(node); end

  # Copy a RegularExpressionNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#630
  def visit_regular_expression_node(node); end

  # Copy a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#635
  def visit_required_keyword_parameter_node(node); end

  # Copy a RequiredParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#640
  def visit_required_parameter_node(node); end

  # Copy a RescueModifierNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#645
  def visit_rescue_modifier_node(node); end

  # Copy a RescueNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#650
  def visit_rescue_node(node); end

  # Copy a RestParameterNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#655
  def visit_rest_parameter_node(node); end

  # Copy a RetryNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#660
  def visit_retry_node(node); end

  # Copy a ReturnNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#665
  def visit_return_node(node); end

  # Copy a SelfNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#670
  def visit_self_node(node); end

  # Copy a ShareableConstantNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#675
  def visit_shareable_constant_node(node); end

  # Copy a SingletonClassNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#680
  def visit_singleton_class_node(node); end

  # Copy a SourceEncodingNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#685
  def visit_source_encoding_node(node); end

  # Copy a SourceFileNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#690
  def visit_source_file_node(node); end

  # Copy a SourceLineNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#695
  def visit_source_line_node(node); end

  # Copy a SplatNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#700
  def visit_splat_node(node); end

  # Copy a StatementsNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#705
  def visit_statements_node(node); end

  # Copy a StringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#710
  def visit_string_node(node); end

  # Copy a SuperNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#715
  def visit_super_node(node); end

  # Copy a SymbolNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#720
  def visit_symbol_node(node); end

  # Copy a TrueNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#725
  def visit_true_node(node); end

  # Copy a UndefNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#730
  def visit_undef_node(node); end

  # Copy a UnlessNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#735
  def visit_unless_node(node); end

  # Copy a UntilNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#740
  def visit_until_node(node); end

  # Copy a WhenNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#745
  def visit_when_node(node); end

  # Copy a WhileNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#750
  def visit_while_node(node); end

  # Copy a XStringNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#755
  def visit_x_string_node(node); end

  # Copy a YieldNode node
  #
  # source://prism//lib/prism/mutation_compiler.rb#760
  def visit_yield_node(node); end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# source://prism//lib/prism/node.rb#13424
class Prism::NextNode < ::Prism::Node
  # def initialize: (ArgumentsNode? arguments, Location keyword_loc, Location location) -> void
  #
  # @return [NextNode] a new instance of NextNode
  #
  # source://prism//lib/prism/node.rb#13426
  def initialize(source, arguments, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13435
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#13470
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13440
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13452
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13445
  def compact_child_nodes; end

  # def copy: (?arguments: ArgumentsNode?, ?keyword_loc: Location, ?location: Location) -> NextNode
  #
  # source://prism//lib/prism/node.rb#13457
  def copy(arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13440
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { arguments: ArgumentsNode?, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#13465
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13486
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13481
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13473
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13512
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13522
    def type; end
  end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# source://prism//lib/prism/node.rb#13531
class Prism::NilNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [NilNode] a new instance of NilNode
  #
  # source://prism//lib/prism/node.rb#13533
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13540
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13545
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13555
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13550
  def compact_child_nodes; end

  # def copy: (?location: Location) -> NilNode
  #
  # source://prism//lib/prism/node.rb#13560
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13545
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#13568
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13574
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13593
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13603
    def type; end
  end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# source://prism//lib/prism/node.rb#13613
class Prism::NoKeywordsParameterNode < ::Prism::Node
  # def initialize: (Location operator_loc, Location keyword_loc, Location location) -> void
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # source://prism//lib/prism/node.rb#13615
  def initialize(source, operator_loc, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13624
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13629
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13639
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13634
  def compact_child_nodes; end

  # def copy: (?operator_loc: Location, ?keyword_loc: Location, ?location: Location) -> NoKeywordsParameterNode
  #
  # source://prism//lib/prism/node.rb#13644
  def copy(operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13629
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#13652
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13682
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#13677
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#13664
  def keyword_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#13672
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#13657
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13703
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13713
    def type; end
  end
end

# This represents a node in the tree. It is the parent class of all of the
# various node types.
#
# source://prism//lib/prism/node.rb#12
class Prism::Node
  # Accepts a visitor and calls back into the specialized visit function.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#79
  def accept(visitor); end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#85
  def child_nodes; end

  # Returns an array of child nodes and locations that could potentially have
  # comments attached to them.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#99
  def comment_targets; end

  # Returns an array of child nodes, excluding any `nil`s in the place of
  # optional nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#93
  def compact_child_nodes; end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#85
  def deconstruct; end

  # The end offset of the node in the source. This method is effectively a
  # delegate method to the location object.
  #
  # source://prism//lib/prism/node.rb#34
  def end_offset; end

  # Returns a string representation of the node.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#110
  def inspect(inspector = T.unsafe(nil)); end

  # A Location instance that represents the location of this node in the
  # source.
  #
  # source://prism//lib/prism/node.rb#19
  def location; end

  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#39
  def newline?; end

  # Similar to inspect, but respects the current level of indentation given by
  # the pretty print object.
  #
  # source://prism//lib/prism/node.rb#58
  def pretty_print(q); end

  # source://prism//lib/prism/node.rb#43
  def set_newline_flag(newline_marked); end

  # Slice the location of the node from the source.
  #
  # source://prism//lib/prism/node.rb#52
  def slice; end

  # The start offset of the node in the source. This method is effectively a
  # delegate method to the location object.
  #
  # source://prism//lib/prism/node.rb#27
  def start_offset; end

  # Convert this node into a graphviz dot graph string.
  #
  # source://prism//lib/prism/node.rb#66
  def to_dot; end

  # Returns a symbol symbolizing the type of node that this represents. This
  # is particularly useful for case statements and array comparisons.
  #
  # @raise [NoMethodError]
  #
  # source://prism//lib/prism/node.rb#105
  def type; end

  private

  # A pointer to the source that this node was created from.
  #
  # source://prism//lib/prism/node.rb#14
  def source; end
end

# This object is responsible for generating the output for the inspect method
# implementations of child nodes.
#
# source://prism//lib/prism/node_inspector.rb#6
class Prism::NodeInspector
  # @return [NodeInspector] a new instance of NodeInspector
  #
  # source://prism//lib/prism/node_inspector.rb#9
  def initialize(prefix = T.unsafe(nil)); end

  # Appends a line to the output with the current prefix.
  #
  # source://prism//lib/prism/node_inspector.rb#15
  def <<(line); end

  # Returns a new inspector that can be used to inspect a child node.
  #
  # source://prism//lib/prism/node_inspector.rb#59
  def child_inspector(append); end

  # Generates a string that represents a child node.
  #
  # source://prism//lib/prism/node_inspector.rb#54
  def child_node(node, append); end

  # This generates a string that is used as the header of the inspect output
  # for any given node.
  #
  # source://prism//lib/prism/node_inspector.rb#21
  def header(node); end

  # Generates a string that represents a list of nodes. It handles properly
  # using the box drawing characters to make the output look nice.
  #
  # source://prism//lib/prism/node_inspector.rb#31
  def list(prefix, nodes); end

  # Generates a string that represents a location field on a node.
  #
  # source://prism//lib/prism/node_inspector.rb#45
  def location(value); end

  # source://prism//lib/prism/node_inspector.rb#7
  def output; end

  # source://prism//lib/prism/node_inspector.rb#7
  def prefix; end

  # Returns the output as a string.
  #
  # source://prism//lib/prism/node_inspector.rb#64
  def to_str; end
end

# Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
#
#     -> { _1 + _2 }
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#13722
class Prism::NumberedParametersNode < ::Prism::Node
  # def initialize: (Integer maximum, Location location) -> void
  #
  # @return [NumberedParametersNode] a new instance of NumberedParametersNode
  #
  # source://prism//lib/prism/node.rb#13724
  def initialize(source, maximum, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13732
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13737
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13747
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13742
  def compact_child_nodes; end

  # def copy: (?maximum: Integer, ?location: Location) -> NumberedParametersNode
  #
  # source://prism//lib/prism/node.rb#13752
  def copy(maximum: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13737
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { maximum: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#13760
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13769
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader maximum: Integer
  #
  # source://prism//lib/prism/node.rb#13765
  def maximum; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13789
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13799
    def type; end
  end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# source://prism//lib/prism/node.rb#13808
class Prism::NumberedReferenceReadNode < ::Prism::Node
  # def initialize: (Integer number, Location location) -> void
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#13810
  def initialize(source, number, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13818
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13823
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13833
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13828
  def compact_child_nodes; end

  # def copy: (?number: Integer, ?location: Location) -> NumberedReferenceReadNode
  #
  # source://prism//lib/prism/node.rb#13838
  def copy(number: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13823
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { number: Integer, location: Location }
  #
  # source://prism//lib/prism/node.rb#13846
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13861
  def inspect(inspector = T.unsafe(nil)); end

  # The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.
  #
  #     $1          # number `1`
  #
  #     $5432       # number `5432`
  #
  #     $4294967296 # number `0`
  #
  # source://prism//lib/prism/node.rb#13857
  def number; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13881
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#13891
    def type; end
  end
end

# Represents an optional keyword parameter to a method, block, or lambda definition.
#
#     def a(b: 1)
#           ^^^^
#     end
#
# source://prism//lib/prism/node.rb#13901
class Prism::OptionalKeywordParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Prism::node value, Location location) -> void
  #
  # @return [OptionalKeywordParameterNode] a new instance of OptionalKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#13903
  def initialize(source, flags, name, name_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#13914
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13919
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#13929
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#13924
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?location: Location) -> OptionalKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#13934
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#13919
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#13942
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#13970
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#13951
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#13954
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#13965
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#13995
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#13961
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#13947
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14005
    def type; end
  end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# source://prism//lib/prism/node.rb#14015
class Prism::OptionalParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value, Location location) -> void
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # source://prism//lib/prism/node.rb#14017
  def initialize(source, flags, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14029
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14034
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14044
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14039
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?location: Location) -> OptionalParameterNode
  #
  # source://prism//lib/prism/node.rb#14049
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14034
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#14057
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14097
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#14066
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#14069
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14092
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#14076
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#14087
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14123
  def type; end

  # attr_reader value: Prism::node
  #
  # source://prism//lib/prism/node.rb#14083
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#14062
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14133
    def type; end
  end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14142
class Prism::OrNode < ::Prism::Node
  # def initialize: (Prism::node left, Prism::node right, Location operator_loc, Location location) -> void
  #
  # @return [OrNode] a new instance of OrNode
  #
  # source://prism//lib/prism/node.rb#14144
  def initialize(source, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14154
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14159
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14169
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14164
  def compact_child_nodes; end

  # def copy: (?left: Prism::node, ?right: Prism::node, ?operator_loc: Location, ?location: Location) -> OrNode
  #
  # source://prism//lib/prism/node.rb#14174
  def copy(left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14159
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Prism::node, right: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14182
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14221
  def inspect(inspector = T.unsafe(nil)); end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left or right
  #     ^^^^
  #
  #     1 || 2
  #     ^
  #
  # source://prism//lib/prism/node.rb#14193
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14216
  def operator; end

  # The location of the `or` keyword or the `||` operator.
  #
  #     left or right
  #          ^^
  #
  # source://prism//lib/prism/node.rb#14208
  def operator_loc; end

  # Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left || right
  #             ^^^^^
  #
  #     1 or 2
  #          ^
  #
  # source://prism//lib/prism/node.rb#14202
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14245
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14255
    def type; end
  end
end

# A parser for the pack template language.
#
# source://prism//lib/prism/pack.rb#6
module Prism::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

# source://prism//lib/prism/pack.rb#56
Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# A directive in the pack template language.
#
# source://prism//lib/prism/pack.rb#60
class Prism::Pack::Directive
  # Initialize a new directive with the given values.
  #
  # @return [Directive] a new instance of Directive
  #
  # source://prism//lib/prism/pack.rb#89
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # Provide a human-readable description of the directive.
  #
  # source://prism//lib/prism/pack.rb#131
  def describe; end

  # The type of endianness of the directive.
  #
  # source://prism//lib/prism/pack.rb#77
  def endian; end

  # The length of this directive (used for integers).
  #
  # source://prism//lib/prism/pack.rb#86
  def length; end

  # The length type of this directive (used for integers).
  #
  # source://prism//lib/prism/pack.rb#83
  def length_type; end

  # The type of signedness of the directive.
  #
  # source://prism//lib/prism/pack.rb#74
  def signed; end

  # The size of the directive.
  #
  # source://prism//lib/prism/pack.rb#80
  def size; end

  # A byteslice of the source string that this directive represents.
  #
  # source://prism//lib/prism/pack.rb#68
  def source; end

  # The type of the directive.
  #
  # source://prism//lib/prism/pack.rb#71
  def type; end

  # A symbol representing whether or not we are packing or unpacking.
  #
  # source://prism//lib/prism/pack.rb#65
  def variant; end

  # A symbol representing the version of Ruby.
  #
  # source://prism//lib/prism/pack.rb#62
  def version; end
end

# The descriptions of the various types of endianness.
#
# source://prism//lib/prism/pack.rb#102
Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of signedness.
#
# source://prism//lib/prism/pack.rb#111
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of sizes.
#
# source://prism//lib/prism/pack.rb#118
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# The result of parsing a pack template.
#
# source://prism//lib/prism/pack.rb#198
class Prism::Pack::Format
  # Create a new Format with the given directives and encoding.
  #
  # @return [Format] a new instance of Format
  #
  # source://prism//lib/prism/pack.rb#206
  def initialize(directives, encoding); end

  # Provide a human-readable description of the format.
  #
  # source://prism//lib/prism/pack.rb#212
  def describe; end

  # A list of the directives in the template.
  #
  # source://prism//lib/prism/pack.rb#200
  def directives; end

  # The encoding of the template.
  #
  # source://prism//lib/prism/pack.rb#203
  def encoding; end
end

# source://prism//lib/prism/pack.rb#56
Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism//lib/prism/pack.rb#56
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Flags for parameter nodes.
#
# source://prism//lib/prism/node.rb#18886
module Prism::ParameterFlags; end

# a parameter name that has been repeated in the method signature
#
# source://prism//lib/prism/node.rb#18888
Prism::ParameterFlags::REPEATED_PARAMETER = T.let(T.unsafe(nil), Integer)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#14265
class Prism::ParametersNode < ::Prism::Node
  # def initialize: (Array[RequiredParameterNode | MultiTargetNode] requireds, Array[OptionalParameterNode] optionals, RestParameterNode | ImplicitRestNode | nil rest, Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode] posts, Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode] keywords, KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil keyword_rest, BlockParameterNode? block, Location location) -> void
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # source://prism//lib/prism/node.rb#14267
  def initialize(source, requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14281
  def accept(visitor); end

  # attr_reader block: BlockParameterNode?
  #
  # source://prism//lib/prism/node.rb#14340
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14286
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14304
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14291
  def compact_child_nodes; end

  # def copy: (?requireds: Array[RequiredParameterNode | MultiTargetNode], ?optionals: Array[OptionalParameterNode], ?rest: RestParameterNode | ImplicitRestNode | nil, ?posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode], ?keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], ?keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, ?block: BlockParameterNode?, ?location: Location) -> ParametersNode
  #
  # source://prism//lib/prism/node.rb#14309
  def copy(requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14286
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { requireds: Array[RequiredParameterNode | MultiTargetNode], optionals: Array[OptionalParameterNode], rest: RestParameterNode | ImplicitRestNode | nil, posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode], keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, block: BlockParameterNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#14317
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14344
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil
  #
  # source://prism//lib/prism/node.rb#14337
  def keyword_rest; end

  # attr_reader keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]
  #
  # source://prism//lib/prism/node.rb#14334
  def keywords; end

  # attr_reader optionals: Array[OptionalParameterNode]
  #
  # source://prism//lib/prism/node.rb#14325
  def optionals; end

  # attr_reader posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode]
  #
  # source://prism//lib/prism/node.rb#14331
  def posts; end

  # attr_reader requireds: Array[RequiredParameterNode | MultiTargetNode]
  #
  # source://prism//lib/prism/node.rb#14322
  def requireds; end

  # attr_reader rest: RestParameterNode | ImplicitRestNode | nil
  #
  # source://prism//lib/prism/node.rb#14328
  def rest; end

  # Mirrors the Method#parameters method.
  #
  # source://prism//lib/prism/node_ext.rb#210
  def signature; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14385
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14395
    def type; end
  end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14404
class Prism::ParenthesesNode < ::Prism::Node
  # def initialize: (Prism::node? body, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # source://prism//lib/prism/node.rb#14406
  def initialize(source, body, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14416
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#14455
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14425
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#14478
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#14465
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14437
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14430
  def compact_child_nodes; end

  # def copy: (?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location, ?location: Location) -> ParenthesesNode
  #
  # source://prism//lib/prism/node.rb#14442
  def copy(body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14425
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { body: Prism::node?, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14450
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14483
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#14473
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#14458
  def opening_loc; end

  # source://prism//lib/prism/node.rb#14420
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14510
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14520
    def type; end
  end
end

# This represents an error that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#368
class Prism::ParseError
  # Create a new error object with the given message and location.
  #
  # @return [ParseError] a new instance of ParseError
  #
  # source://prism//lib/prism/parse_result.rb#383
  def initialize(type, message, location, level); end

  # Implement the hash pattern matching interface for ParseError.
  #
  # source://prism//lib/prism/parse_result.rb#391
  def deconstruct_keys(keys); end

  # Returns a string representation of this error.
  #
  # source://prism//lib/prism/parse_result.rb#396
  def inspect; end

  # The level of this error.
  #
  # source://prism//lib/prism/parse_result.rb#380
  def level; end

  # A Location object representing the location of this error in the source.
  #
  # source://prism//lib/prism/parse_result.rb#377
  def location; end

  # The message associated with this error.
  #
  # source://prism//lib/prism/parse_result.rb#374
  def message; end

  # The type of error. This is an _internal_ symbol that is used for
  # communicating with translation layers. It is not meant to be public API.
  #
  # source://prism//lib/prism/parse_result.rb#371
  def type; end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the AST, any comments that were encounters, and any errors that were
# encountered.
#
# source://prism//lib/prism/parse_result.rb#438
class Prism::ParseResult
  # Create a new parse result object with the given values.
  #
  # @return [ParseResult] a new instance of ParseResult
  #
  # source://prism//lib/prism/parse_result.rb#465
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Attach the list of comments to their respective locations in the tree.
  #
  # source://prism//lib/prism/parse_result/comments.rb#190
  def attach_comments!; end

  # The list of comments that were encountered during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#445
  def comments; end

  # An optional location that represents the location of the __END__ marker
  # and the rest of the content of the file. This content is loaded into the
  # DATA constant when the file being parsed is the main file being executed.
  #
  # source://prism//lib/prism/parse_result.rb#453
  def data_loc; end

  # Implement the hash pattern matching interface for ParseResult.
  #
  # source://prism//lib/prism/parse_result.rb#476
  def deconstruct_keys(keys); end

  # Returns the encoding of the source code that was parsed.
  #
  # source://prism//lib/prism/parse_result.rb#481
  def encoding; end

  # The list of errors that were generated during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#456
  def errors; end

  # Returns true if there were errors during parsing and false if there were
  # not.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#493
  def failure?; end

  # The list of magic comments that were encountered during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#448
  def magic_comments; end

  # Walk the tree and mark nodes that are on a new line.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#60
  def mark_newlines!; end

  # A Source instance that represents the source code that was parsed.
  #
  # source://prism//lib/prism/parse_result.rb#462
  def source; end

  # Returns true if there were no errors during parsing and false if there
  # were.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result.rb#487
  def success?; end

  # The value that was generated by parsing. Normally this holds the AST, but
  # it can sometimes how a list of tokens or other results passed back from
  # the parser.
  #
  # source://prism//lib/prism/parse_result.rb#442
  def value; end

  # The list of warnings that were generated during parsing.
  #
  # source://prism//lib/prism/parse_result.rb#459
  def warnings; end
end

# When we've parsed the source, we have both the syntax tree and the list of
# comments that we found in the source. This class is responsible for
# walking the tree and finding the nearest location to attach each comment.
#
# It does this by first finding the nearest locations to each comment.
# Locations can either come from nodes directly or from location fields on
# nodes. For example, a `ClassNode` has an overall location encompassing the
# entire class, but it also has a location for the `class` keyword.
#
# Once the nearest locations are found, it determines which one to attach
# to. If it's a trailing comment (a comment on the same line as other source
# code), it will favor attaching to the nearest location that occurs before
# the comment. Otherwise it will favor attaching to the nearest location
# that is after the comment.
#
# source://prism//lib/prism/parse_result/comments.rb#19
class Prism::ParseResult::Comments
  # Create a new Comments object that will attach comments to the given
  # parse result.
  #
  # @return [Comments] a new instance of Comments
  #
  # source://prism//lib/prism/parse_result/comments.rb#86
  def initialize(parse_result); end

  # Attach the comments to their respective locations in the tree by
  # mutating the parse result.
  #
  # source://prism//lib/prism/parse_result/comments.rb#92
  def attach!; end

  # The parse result that we are attaching comments to.
  #
  # source://prism//lib/prism/parse_result/comments.rb#82
  def parse_result; end

  private

  # Responsible for finding the nearest targets to the given comment within
  # the context of the given encapsulating node.
  #
  # source://prism//lib/prism/parse_result/comments.rb#119
  def nearest_targets(node, comment); end
end

# A target for attaching comments that is based on a location field on a
# node. For example, the `end` token of a ClassNode.
#
# source://prism//lib/prism/parse_result/comments.rb#53
class Prism::ParseResult::Comments::LocationTarget
  # @return [LocationTarget] a new instance of LocationTarget
  #
  # source://prism//lib/prism/parse_result/comments.rb#56
  def initialize(location); end

  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result/comments.rb#68
  def encloses?(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#64
  def end_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#72
  def leading_comment(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#54
  def location; end

  # source://prism//lib/prism/parse_result/comments.rb#60
  def start_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#76
  def trailing_comment(comment); end
end

# A target for attaching comments that is based on a specific node's
# location.
#
# source://prism//lib/prism/parse_result/comments.rb#22
class Prism::ParseResult::Comments::NodeTarget
  # @return [NodeTarget] a new instance of NodeTarget
  #
  # source://prism//lib/prism/parse_result/comments.rb#25
  def initialize(node); end

  # @return [Boolean]
  #
  # source://prism//lib/prism/parse_result/comments.rb#37
  def encloses?(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#33
  def end_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#42
  def leading_comment(comment); end

  # source://prism//lib/prism/parse_result/comments.rb#23
  def node; end

  # source://prism//lib/prism/parse_result/comments.rb#29
  def start_offset; end

  # source://prism//lib/prism/parse_result/comments.rb#46
  def trailing_comment(comment); end
end

# The :line tracepoint event gets fired whenever the Ruby VM encounters an
# expression on a new line. The types of expressions that can trigger this
# event are:
#
# * if statements
# * unless statements
# * nodes that are children of statements lists
#
# In order to keep track of the newlines, we have a list of offsets that
# come back from the parser. We assign these offsets to the first nodes that
# we find in the tree that are on those lines.
#
# Note that the logic in this file should be kept in sync with the Java
# MarkNewlinesVisitor, since that visitor is responsible for marking the
# newlines for JRuby/TruffleRuby.
#
# source://prism//lib/prism/parse_result/newlines.rb#20
class Prism::ParseResult::Newlines < ::Prism::Visitor
  # Create a new Newlines visitor with the given newline offsets.
  #
  # @return [Newlines] a new instance of Newlines
  #
  # source://prism//lib/prism/parse_result/newlines.rb#22
  def initialize(newline_marked); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#27
  def visit_block_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#41
  def visit_if_node(node); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#27
  def visit_lambda_node(node); end

  # Permit statements lists to mark newlines within themselves.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#49
  def visit_statements_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism//lib/prism/parse_result/newlines.rb#41
  def visit_unless_node(node); end
end

# This represents a warning that was encountered during parsing.
#
# source://prism//lib/prism/parse_result.rb#402
class Prism::ParseWarning
  # Create a new warning object with the given message and location.
  #
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # source://prism//lib/prism/parse_result.rb#417
  def initialize(type, message, location, level); end

  # Implement the hash pattern matching interface for ParseWarning.
  #
  # source://prism//lib/prism/parse_result.rb#425
  def deconstruct_keys(keys); end

  # Returns a string representation of this warning.
  #
  # source://prism//lib/prism/parse_result.rb#430
  def inspect; end

  # The level of this warning.
  #
  # source://prism//lib/prism/parse_result.rb#414
  def level; end

  # A Location object representing the location of this warning in the source.
  #
  # source://prism//lib/prism/parse_result.rb#411
  def location; end

  # The message associated with this warning.
  #
  # source://prism//lib/prism/parse_result.rb#408
  def message; end

  # The type of warning. This is an _internal_ symbol that is used for
  # communicating with translation layers. It is not meant to be public API.
  #
  # source://prism//lib/prism/parse_result.rb#405
  def type; end
end

# A pattern is an object that wraps a Ruby pattern matching expression. The
# expression would normally be passed to an `in` clause within a `case`
# expression or a rightward assignment expression. For example, in the
# following snippet:
#
#     case node
#     in ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]
#     end
#
# the pattern is the <tt>ConstantPathNode[...]</tt> expression.
#
# The pattern gets compiled into an object that responds to #call by running
# the #compile method. This method itself will run back through Prism to
# parse the expression into a tree, then walk the tree to generate the
# necessary callable objects. For example, if you wanted to compile the
# expression above into a callable, you would:
#
#     callable = Prism::Pattern.new("ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]").compile
#     callable.call(node)
#
# The callable object returned by #compile is guaranteed to respond to #call
# with a single argument, which is the node to match against. It also is
# guaranteed to respond to #===, which means it itself can be used in a `case`
# expression, as in:
#
#     case node
#     when callable
#     end
#
# If the query given to the initializer cannot be compiled into a valid
# matcher (either because of a syntax error or because it is using syntax we
# do not yet support) then a Prism::Pattern::CompilationError will be
# raised.
#
# source://prism//lib/prism/pattern.rb#37
class Prism::Pattern
  # Create a new pattern with the given query. The query should be a string
  # containing a Ruby pattern matching expression.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://prism//lib/prism/pattern.rb#63
  def initialize(query); end

  # Compile the query into a callable object that can be used to match against
  # nodes.
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/pattern.rb#70
  def compile; end

  # The query that this pattern was initialized with.
  #
  # source://prism//lib/prism/pattern.rb#59
  def query; end

  # Scan the given node and all of its children for nodes that match the
  # pattern. If a block is given, it will be called with each node that
  # matches the pattern. If no block is given, an enumerator will be returned
  # that will yield each node that matches the pattern.
  #
  # source://prism//lib/prism/pattern.rb#86
  def scan(root); end

  private

  # Shortcut for combining two procs into one that returns true if both return
  # true.
  #
  # source://prism//lib/prism/pattern.rb#102
  def combine_and(left, right); end

  # Shortcut for combining two procs into one that returns true if either
  # returns true.
  #
  # source://prism//lib/prism/pattern.rb#108
  def combine_or(left, right); end

  # in foo | bar
  #
  # source://prism//lib/prism/pattern.rb#143
  def compile_alternation_pattern_node(node); end

  # in [foo, bar, baz]
  #
  # source://prism//lib/prism/pattern.rb#118
  def compile_array_pattern_node(node); end

  # in Prism::ConstantReadNode
  #
  # source://prism//lib/prism/pattern.rb#148
  def compile_constant_path_node(node); end

  # in ConstantReadNode
  # in String
  #
  # source://prism//lib/prism/pattern.rb#160
  def compile_constant_read_node(node); end

  # Raise an error because the given node is not supported.
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/pattern.rb#113
  def compile_error(node); end

  # in InstanceVariableReadNode[name: Symbol]
  # in { name: Symbol }
  #
  # source://prism//lib/prism/pattern.rb#178
  def compile_hash_pattern_node(node); end

  # in nil
  #
  # source://prism//lib/prism/pattern.rb#208
  def compile_nil_node(node); end

  # Compile any kind of node. Dispatch out to the individual compilation
  # methods based on the type of node.
  #
  # source://prism//lib/prism/pattern.rb#237
  def compile_node(node); end

  # in /foo/
  #
  # source://prism//lib/prism/pattern.rb#213
  def compile_regular_expression_node(node); end

  # in ""
  # in "foo"
  #
  # source://prism//lib/prism/pattern.rb#221
  def compile_string_node(node); end

  # in :+
  # in :foo
  #
  # source://prism//lib/prism/pattern.rb#229
  def compile_symbol_node(node); end
end

# Raised when the query given to a pattern is either invalid Ruby syntax or
# is using syntax that we don't yet support.
#
# source://prism//lib/prism/pattern.rb#40
class Prism::Pattern::CompilationError < ::StandardError
  # Create a new CompilationError with the given representation of the node
  # that caused the error.
  #
  # @return [CompilationError] a new instance of CompilationError
  #
  # source://prism//lib/prism/pattern.rb#43
  def initialize(repr); end
end

# Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# source://prism//lib/prism/node.rb#14529
class Prism::PinnedExpressionNode < ::Prism::Node
  # def initialize: (Prism::node expression, Location operator_loc, Location lparen_loc, Location rparen_loc, Location location) -> void
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # source://prism//lib/prism/node.rb#14531
  def initialize(source, expression, operator_loc, lparen_loc, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14542
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14547
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14557
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14552
  def compact_child_nodes; end

  # def copy: (?expression: Prism::node, ?operator_loc: Location, ?lparen_loc: Location, ?rparen_loc: Location, ?location: Location) -> PinnedExpressionNode
  #
  # source://prism//lib/prism/node.rb#14562
  def copy(expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14547
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Prism::node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14570
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node
  #
  # source://prism//lib/prism/node.rb#14575
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14615
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String
  #
  # source://prism//lib/prism/node.rb#14605
  def lparen; end

  # attr_reader lparen_loc: Location
  #
  # source://prism//lib/prism/node.rb#14585
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14600
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#14578
  def operator_loc; end

  # def rparen: () -> String
  #
  # source://prism//lib/prism/node.rb#14610
  def rparen; end

  # attr_reader rparen_loc: Location
  #
  # source://prism//lib/prism/node.rb#14592
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14639
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14649
    def type; end
  end
end

# Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
#
#     foo in ^bar
#            ^^^^
#
# source://prism//lib/prism/node.rb#14658
class Prism::PinnedVariableNode < ::Prism::Node
  # def initialize: (Prism::node variable, Location operator_loc, Location location) -> void
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # source://prism//lib/prism/node.rb#14660
  def initialize(source, variable, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14669
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14674
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14684
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14679
  def compact_child_nodes; end

  # def copy: (?variable: Prism::node, ?operator_loc: Location, ?location: Location) -> PinnedVariableNode
  #
  # source://prism//lib/prism/node.rb#14689
  def copy(variable: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14674
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { variable: Prism::node, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14697
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14718
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#14713
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#14705
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14740
  def type; end

  # attr_reader variable: Prism::node
  #
  # source://prism//lib/prism/node.rb#14702
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14750
    def type; end
  end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14759
class Prism::PostExecutionNode < ::Prism::Node
  # def initialize: (StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # source://prism//lib/prism/node.rb#14761
  def initialize(source, statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14772
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14777
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#14842
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#14824
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14789
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14782
  def compact_child_nodes; end

  # def copy: (?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?location: Location) -> PostExecutionNode
  #
  # source://prism//lib/prism/node.rb#14794
  def copy(statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14777
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14802
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14847
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14832
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14810
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#14837
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#14817
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#14807
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#14875
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#14885
    def type; end
  end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#14894
class Prism::PreExecutionNode < ::Prism::Node
  # def initialize: (StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # source://prism//lib/prism/node.rb#14896
  def initialize(source, statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#14907
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14912
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#14977
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#14959
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#14924
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#14917
  def compact_child_nodes; end

  # def copy: (?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?location: Location) -> PreExecutionNode
  #
  # source://prism//lib/prism/node.rb#14929
  def copy(statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#14912
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#14937
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#14982
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#14967
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#14945
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#14972
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#14952
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#14942
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15010
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15020
    def type; end
  end
end

# The top level node of any parse tree.
#
# source://prism//lib/prism/node.rb#15026
class Prism::ProgramNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, StatementsNode statements, Location location) -> void
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # source://prism//lib/prism/node.rb#15028
  def initialize(source, locals, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15037
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15042
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15052
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15047
  def compact_child_nodes; end

  # def copy: (?locals: Array[Symbol], ?statements: StatementsNode, ?location: Location) -> ProgramNode
  #
  # source://prism//lib/prism/node.rb#15057
  def copy(locals: T.unsafe(nil), statements: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15042
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], statements: StatementsNode, location: Location }
  #
  # source://prism//lib/prism/node.rb#15065
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15077
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#15070
  def locals; end

  # attr_reader statements: StatementsNode
  #
  # source://prism//lib/prism/node.rb#15073
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15099
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15109
    def type; end
  end
end

# Flags for range and flip-flop nodes.
#
# source://prism//lib/prism/node.rb#18892
module Prism::RangeFlags; end

# ... operator
#
# source://prism//lib/prism/node.rb#18894
Prism::RangeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15121
class Prism::RangeNode < ::Prism::Node
  # def initialize: (Integer flags, Prism::node? left, Prism::node? right, Location operator_loc, Location location) -> void
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # source://prism//lib/prism/node.rb#15123
  def initialize(source, flags, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15134
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15139
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15152
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15144
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location, ?location: Location) -> RangeNode
  #
  # source://prism//lib/prism/node.rb#15157
  def copy(flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15139
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, left: Prism::node?, right: Prism::node?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#15165
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15201
  def exclude_end?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15211
  def inspect(inspector = T.unsafe(nil)); end

  # The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     1...
  #     ^
  #
  #     hello...goodbye
  #     ^^^^^
  #
  # source://prism//lib/prism/node.rb#15180
  def left; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#15206
  def operator; end

  # The location of the `..` or `...` operator.
  #
  # source://prism//lib/prism/node.rb#15193
  def operator_loc; end

  # The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     ..5
  #       ^
  #
  #     1...foo
  #         ^^^
  # If neither right-hand or left-hand side was included, this will be a MissingNode.
  #
  # source://prism//lib/prism/node.rb#15190
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15245
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#15170
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15255
    def type; end
  end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# source://prism//lib/prism/node.rb#15264
class Prism::RationalNode < ::Prism::Node
  # def initialize: (Prism::node numeric, Location location) -> void
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # source://prism//lib/prism/node.rb#15266
  def initialize(source, numeric, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15274
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15279
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15289
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15284
  def compact_child_nodes; end

  # def copy: (?numeric: Prism::node, ?location: Location) -> RationalNode
  #
  # source://prism//lib/prism/node.rb#15294
  def copy(numeric: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15279
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { numeric: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#15302
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15311
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Prism::node
  #
  # source://prism//lib/prism/node.rb#15307
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15332
  def type; end

  # Returns the value of the node as a Ruby Rational.
  #
  # source://prism//lib/prism/node_ext.rb#94
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15342
    def type; end
  end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# source://prism//lib/prism/node.rb#15351
class Prism::RedoNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # source://prism//lib/prism/node.rb#15353
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15360
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15365
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15375
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15370
  def compact_child_nodes; end

  # def copy: (?location: Location) -> RedoNode
  #
  # source://prism//lib/prism/node.rb#15380
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15365
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#15388
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15394
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15413
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15423
    def type; end
  end
end

# Flags for regular expression and match last line nodes.
#
# source://prism//lib/prism/node.rb#18898
module Prism::RegularExpressionFlags; end

# n - forces the ASCII-8BIT encoding
#
# source://prism//lib/prism/node.rb#18915
Prism::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)

# e - forces the EUC-JP encoding
#
# source://prism//lib/prism/node.rb#18912
Prism::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)

# x - ignores whitespace and allows comments in regular expressions
#
# source://prism//lib/prism/node.rb#18903
Prism::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to binary
#
# source://prism//lib/prism/node.rb#18927
Prism::RegularExpressionFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# source://prism//lib/prism/node.rb#18930
Prism::RegularExpressionFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism//lib/prism/node.rb#18924
Prism::RegularExpressionFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# i - ignores the case of characters when matching
#
# source://prism//lib/prism/node.rb#18900
Prism::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)

# m - allows $ to match the end of lines within strings
#
# source://prism//lib/prism/node.rb#18906
Prism::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)

# o - only interpolates values into the regular expression once
#
# source://prism//lib/prism/node.rb#18909
Prism::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)

# u - forces the UTF-8 encoding
#
# source://prism//lib/prism/node.rb#18921
Prism::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)

# s - forces the Windows-31J encoding
#
# source://prism//lib/prism/node.rb#18918
Prism::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# source://prism//lib/prism/node.rb#15432
class Prism::RegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#15434
  def initialize(source, flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15446
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15533
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15451
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#15573
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#15497
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15461
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15456
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#15568
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#15490
  def content_loc; end

  # def copy: (?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String, ?location: Location) -> RegularExpressionNode
  #
  # source://prism//lib/prism/node.rb#15466
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15451
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#15474
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15528
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15513
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15553
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15558
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15548
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15508
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15578
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15518
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15523
  def once?; end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#15563
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#15483
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15603
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#15504
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15543
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15538
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#15479
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15613
    def type; end
  end
end

# source://prism//lib/prism/node_ext.rb#6
module Prism::RegularExpressionOptions
  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # source://prism//lib/prism/node_ext.rb#9
  def options; end
end

# Represents a required keyword parameter to a method, block, or lambda definition.
#
#     def a(b: )
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#15623
class Prism::RequiredKeywordParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Location location) -> void
  #
  # @return [RequiredKeywordParameterNode] a new instance of RequiredKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#15625
  def initialize(source, flags, name, name_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15635
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15640
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15650
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15645
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol, ?name_loc: Location, ?location: Location) -> RequiredKeywordParameterNode
  #
  # source://prism//lib/prism/node.rb#15655
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15640
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#15663
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15688
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#15672
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism//lib/prism/node.rb#15675
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15683
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15711
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#15668
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15721
    def type; end
  end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# source://prism//lib/prism/node.rb#15731
class Prism::RequiredParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location location) -> void
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # source://prism//lib/prism/node.rb#15733
  def initialize(source, flags, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15742
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15747
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15757
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15752
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol, ?location: Location) -> RequiredParameterNode
  #
  # source://prism//lib/prism/node.rb#15762
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15747
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, location: Location }
  #
  # source://prism//lib/prism/node.rb#15770
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15788
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism//lib/prism/node.rb#15779
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#15783
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15810
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#15775
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15820
    def type; end
  end
end

# Represents an expression modified with a rescue.
#
#     foo rescue nil
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#15829
class Prism::RescueModifierNode < ::Prism::Node
  # def initialize: (Prism::node expression, Location keyword_loc, Prism::node rescue_expression, Location location) -> void
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # source://prism//lib/prism/node.rb#15831
  def initialize(source, expression, keyword_loc, rescue_expression, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15841
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15850
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15860
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15855
  def compact_child_nodes; end

  # def copy: (?expression: Prism::node, ?keyword_loc: Location, ?rescue_expression: Prism::node, ?location: Location) -> RescueModifierNode
  #
  # source://prism//lib/prism/node.rb#15865
  def copy(expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15850
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Prism::node, keyword_loc: Location, rescue_expression: Prism::node, location: Location }
  #
  # source://prism//lib/prism/node.rb#15873
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node
  #
  # source://prism//lib/prism/node.rb#15878
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#15897
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#15892
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15881
  def keyword_loc; end

  # attr_reader rescue_expression: Prism::node
  #
  # source://prism//lib/prism/node.rb#15888
  def rescue_expression; end

  # source://prism//lib/prism/node.rb#15845
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#15921
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#15931
    def type; end
  end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#       foo
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `exception` field.
#
# source://prism//lib/prism/node.rb#15945
class Prism::RescueNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Array[Prism::node] exceptions, Location? operator_loc, Prism::node? reference, StatementsNode? statements, RescueNode? consequent, Location location) -> void
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # source://prism//lib/prism/node.rb#15947
  def initialize(source, keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#15960
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15965
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#15980
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#15970
  def compact_child_nodes; end

  # attr_reader consequent: RescueNode?
  #
  # source://prism//lib/prism/node.rb#16027
  def consequent; end

  # def copy: (?keyword_loc: Location, ?exceptions: Array[Prism::node], ?operator_loc: Location?, ?reference: Prism::node?, ?statements: StatementsNode?, ?consequent: RescueNode?, ?location: Location) -> RescueNode
  #
  # source://prism//lib/prism/node.rb#15985
  def copy(keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), statements: T.unsafe(nil), consequent: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#15965
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, exceptions: Array[Prism::node], operator_loc: Location?, reference: Prism::node?, statements: StatementsNode?, consequent: RescueNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#15993
  def deconstruct_keys(keys); end

  # attr_reader exceptions: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#16005
  def exceptions; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16041
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16031
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#15998
  def keyword_loc; end

  # def operator: () -> String?
  #
  # source://prism//lib/prism/node.rb#16036
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism//lib/prism/node.rb#16008
  def operator_loc; end

  # attr_reader reference: Prism::node?
  #
  # source://prism//lib/prism/node.rb#16021
  def reference; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#16024
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16081
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16091
    def type; end
  end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# source://prism//lib/prism/node.rb#16101
class Prism::RestParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # source://prism//lib/prism/node.rb#16103
  def initialize(source, flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16114
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16119
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16129
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16124
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location, ?location: Location) -> RestParameterNode
  #
  # source://prism//lib/prism/node.rb#16134
  def copy(flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16119
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#16142
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16185
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism//lib/prism/node.rb#16151
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism//lib/prism/node.rb#16154
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#16180
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#16167
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16175
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16213
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#16147
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16223
    def type; end
  end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# source://prism//lib/prism/node.rb#16232
class Prism::RetryNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # source://prism//lib/prism/node.rb#16234
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16241
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16246
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16256
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16251
  def compact_child_nodes; end

  # def copy: (?location: Location) -> RetryNode
  #
  # source://prism//lib/prism/node.rb#16261
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16246
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#16269
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16275
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16294
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16304
    def type; end
  end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#16313
class Prism::ReturnNode < ::Prism::Node
  # def initialize: (Location keyword_loc, ArgumentsNode? arguments, Location location) -> void
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # source://prism//lib/prism/node.rb#16315
  def initialize(source, keyword_loc, arguments, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16324
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#16366
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16329
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16341
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16334
  def compact_child_nodes; end

  # def copy: (?keyword_loc: Location, ?arguments: ArgumentsNode?, ?location: Location) -> ReturnNode
  #
  # source://prism//lib/prism/node.rb#16346
  def copy(keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16329
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, arguments: ArgumentsNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#16354
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16375
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16370
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16359
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16401
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16411
    def type; end
  end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# source://prism//lib/prism/node.rb#16420
class Prism::SelfNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # source://prism//lib/prism/node.rb#16422
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16429
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16434
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16444
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16439
  def compact_child_nodes; end

  # def copy: (?location: Location) -> SelfNode
  #
  # source://prism//lib/prism/node.rb#16449
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16434
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#16457
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16463
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16482
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16492
    def type; end
  end
end

# A module responsible for deserializing parse results.
#
# source://prism//lib/prism/serialize.rb#14
module Prism::Serialize
  class << self
    # Deserialize the AST represented by the given string into a parse result.
    #
    # source://prism//lib/prism/serialize.rb#28
    def load(input, serialized); end

    # Deserialize the tokens represented by the given string into a parse
    # result.
    #
    # source://prism//lib/prism/serialize.rb#40
    def load_tokens(source, serialized); end
  end
end

# source://prism//lib/prism/serialize.rb#44
class Prism::Serialize::Loader
  # @return [Loader] a new instance of Loader
  #
  # source://prism//lib/prism/serialize.rb#80
  def initialize(source, serialized); end

  # Returns the value of attribute constant_pool.
  #
  # source://prism//lib/prism/serialize.rb#77
  def constant_pool; end

  # Returns the value of attribute constant_pool_offset.
  #
  # source://prism//lib/prism/serialize.rb#77
  def constant_pool_offset; end

  # Returns the value of attribute encoding.
  #
  # source://prism//lib/prism/serialize.rb#76
  def encoding; end

  # Returns the value of attribute input.
  #
  # source://prism//lib/prism/serialize.rb#76
  def input; end

  # Returns the value of attribute io.
  #
  # source://prism//lib/prism/serialize.rb#76
  def io; end

  # source://prism//lib/prism/serialize.rb#118
  def load_comments; end

  # source://prism//lib/prism/serialize.rb#104
  def load_encoding; end

  # source://prism//lib/prism/serialize.rb#95
  def load_header; end

  # source://prism//lib/prism/serialize.rb#114
  def load_line_offsets; end

  # source://prism//lib/prism/serialize.rb#402
  def load_metadata; end

  # source://prism//lib/prism/serialize.rb#436
  def load_nodes; end

  # source://prism//lib/prism/serialize.rb#450
  def load_result; end

  # source://prism//lib/prism/serialize.rb#110
  def load_start_line; end

  # source://prism//lib/prism/serialize.rb#411
  def load_tokens; end

  # source://prism//lib/prism/serialize.rb#424
  def load_tokens_result; end

  # Returns the value of attribute serialized.
  #
  # source://prism//lib/prism/serialize.rb#76
  def serialized; end

  # Returns the value of attribute source.
  #
  # source://prism//lib/prism/serialize.rb#77
  def source; end

  # Returns the value of attribute start_line.
  #
  # source://prism//lib/prism/serialize.rb#78
  def start_line; end

  private

  # source://prism//lib/prism/serialize.rb#536
  def load_constant(index); end

  # source://prism//lib/prism/serialize.rb#489
  def load_double; end

  # source://prism//lib/prism/serialize.rb#504
  def load_embedded_string; end

  # source://prism//lib/prism/serialize.rb#566
  def load_error_level; end

  # source://prism//lib/prism/serialize.rb#478
  def load_integer; end

  # source://prism//lib/prism/serialize.rb#520
  def load_location; end

  # source://prism//lib/prism/serialize.rb#524
  def load_location_object; end

  # source://prism//lib/prism/serialize.rb#595
  def load_node; end

  # source://prism//lib/prism/serialize.rb#561
  def load_optional_constant; end

  # source://prism//lib/prism/serialize.rb#528
  def load_optional_location; end

  # source://prism//lib/prism/serialize.rb#532
  def load_optional_location_object; end

  # source://prism//lib/prism/serialize.rb#497
  def load_optional_node; end

  # source://prism//lib/prism/serialize.rb#557
  def load_required_constant; end

  # source://prism//lib/prism/serialize.rb#508
  def load_string; end

  # source://prism//lib/prism/serialize.rb#493
  def load_uint32; end

  # source://prism//lib/prism/serialize.rb#473
  def load_varsint; end

  # variable-length integer using https://en.wikipedia.org/wiki/LEB128
  # This is also what protobuf uses: https://protobuf.dev/programming-guides/encoding/#varints
  #
  # source://prism//lib/prism/serialize.rb#459
  def load_varuint; end

  # source://prism//lib/prism/serialize.rb#581
  def load_warning_level; end
end

# source://prism//lib/prism/serialize.rb#127
Prism::Serialize::Loader::DIAGNOSTIC_TYPES = T.let(T.unsafe(nil), Array)

# StringIO is synchronized and that adds a high overhead on TruffleRuby.
#
# source://prism//lib/prism/serialize.rb#72
Prism::Serialize::Loader::FastStringIO = StringIO

# The major version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#17
Prism::Serialize::MAJOR_VERSION = T.let(T.unsafe(nil), Integer)

# The minor version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#21
Prism::Serialize::MINOR_VERSION = T.let(T.unsafe(nil), Integer)

# The patch version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism//lib/prism/serialize.rb#25
Prism::Serialize::PATCH_VERSION = T.let(T.unsafe(nil), Integer)

# The token types that can be indexed by their enum values.
#
# source://prism//lib/prism/serialize.rb#1819
Prism::Serialize::TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
#
#     C = { a: 1 }
#     ^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#16502
class Prism::ShareableConstantNode < ::Prism::Node
  # def initialize: (Integer flags, ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode write, Location location) -> void
  #
  # @return [ShareableConstantNode] a new instance of ShareableConstantNode
  #
  # source://prism//lib/prism/node.rb#16504
  def initialize(source, flags, write, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16513
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16518
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16528
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16523
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode, ?location: Location) -> ShareableConstantNode
  #
  # source://prism//lib/prism/node.rb#16533
  def copy(flags: T.unsafe(nil), write: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16518
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode, location: Location }
  #
  # source://prism//lib/prism/node.rb#16541
  def deconstruct_keys(keys); end

  # def experimental_copy?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16564
  def experimental_copy?; end

  # def experimental_everything?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16559
  def experimental_everything?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16569
  def inspect(inspector = T.unsafe(nil)); end

  # def literal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16554
  def literal?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16592
  def type; end

  # The constant write that should be modified with the shareability state.
  #
  # source://prism//lib/prism/node.rb#16550
  def write; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#16546
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16602
    def type; end
  end
end

# Flags for shareable constant nodes.
#
# source://prism//lib/prism/node.rb#18934
module Prism::ShareableConstantNodeFlags; end

# constant writes that should be modified with shareable constant value experimental copy
#
# source://prism//lib/prism/node.rb#18942
Prism::ShareableConstantNodeFlags::EXPERIMENTAL_COPY = T.let(T.unsafe(nil), Integer)

# constant writes that should be modified with shareable constant value experimental everything
#
# source://prism//lib/prism/node.rb#18939
Prism::ShareableConstantNodeFlags::EXPERIMENTAL_EVERYTHING = T.let(T.unsafe(nil), Integer)

# constant writes that should be modified with shareable constant value literal
#
# source://prism//lib/prism/node.rb#18936
Prism::ShareableConstantNodeFlags::LITERAL = T.let(T.unsafe(nil), Integer)

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#16611
class Prism::SingletonClassNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location class_keyword_loc, Location operator_loc, Prism::node expression, Prism::node? body, Location end_keyword_loc, Location location) -> void
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # source://prism//lib/prism/node.rb#16613
  def initialize(source, locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16626
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # source://prism//lib/prism/node.rb#16682
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16631
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16693
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16665
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16644
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16636
  def compact_child_nodes; end

  # def copy: (?locals: Array[Symbol], ?class_keyword_loc: Location, ?operator_loc: Location, ?expression: Prism::node, ?body: Prism::node?, ?end_keyword_loc: Location, ?location: Location) -> SingletonClassNode
  #
  # source://prism//lib/prism/node.rb#16649
  def copy(locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16631
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Prism::node, body: Prism::node?, end_keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#16657
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#16703
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#16685
  def end_keyword_loc; end

  # attr_reader expression: Prism::node
  #
  # source://prism//lib/prism/node.rb#16679
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16708
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism//lib/prism/node.rb#16662
  def locals; end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#16698
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#16672
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16739
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16749
    def type; end
  end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# source://prism//lib/prism/parse_result.rb#7
class Prism::Source
  # Create a new source object with the given source code.
  #
  # @return [Source] a new instance of Source
  #
  # source://prism//lib/prism/parse_result.rb#18
  def initialize(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end

  # Return the column number in characters for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#59
  def character_column(byte_offset); end

  # Return the character offset for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#54
  def character_offset(byte_offset); end

  # Returns the column number in code units for the given encoding for the
  # given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#76
  def code_units_column(byte_offset, encoding); end

  # Returns the offset from the start of the file for the given byte offset
  # counting in code units for the given encoding.
  #
  # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
  # concept of code units that differs from the number of characters in other
  # encodings, it is not captured here.
  #
  # source://prism//lib/prism/parse_result.rb#69
  def code_units_offset(byte_offset, encoding); end

  # Return the column number for the given byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#49
  def column(byte_offset); end

  # Returns the encoding of the source code, which is set by parameters to the
  # parser or by the encoding magic comment.
  #
  # source://prism//lib/prism/parse_result.rb#26
  def encoding; end

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#38
  def line(byte_offset); end

  # Return the byte offset of the start of the line corresponding to the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#44
  def line_start(byte_offset); end

  # The list of newline byte offsets in the source code.
  #
  # source://prism//lib/prism/parse_result.rb#15
  def offsets; end

  # Perform a byteslice on the source code using the given byte offset and
  # byte length.
  #
  # source://prism//lib/prism/parse_result.rb#32
  def slice(byte_offset, length); end

  # The source code that this source object represents.
  #
  # source://prism//lib/prism/parse_result.rb#9
  def source; end

  # The line number where this source starts.
  #
  # source://prism//lib/prism/parse_result.rb#12
  def start_line; end

  private

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism//lib/prism/parse_result.rb#84
  def find_line(byte_offset); end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#16758
class Prism::SourceEncodingNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # source://prism//lib/prism/node.rb#16760
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16767
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16772
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16782
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16777
  def compact_child_nodes; end

  # def copy: (?location: Location) -> SourceEncodingNode
  #
  # source://prism//lib/prism/node.rb#16787
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16772
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#16795
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16801
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16820
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16830
    def type; end
  end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#16839
class Prism::SourceFileNode < ::Prism::Node
  # def initialize: (Integer flags, String filepath, Location location) -> void
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # source://prism//lib/prism/node.rb#16841
  def initialize(source, flags, filepath, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16850
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16855
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16865
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16860
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?filepath: String, ?location: Location) -> SourceFileNode
  #
  # source://prism//lib/prism/node.rb#16870
  def copy(flags: T.unsafe(nil), filepath: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16855
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, filepath: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#16878
  def deconstruct_keys(keys); end

  # attr_reader filepath: String
  #
  # source://prism//lib/prism/node.rb#16887
  def filepath; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16896
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16891
  def forced_utf8_encoding?; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16901
  def frozen?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16911
  def inspect(inspector = T.unsafe(nil)); end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#16906
  def mutable?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#16933
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#16883
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#16943
    def type; end
  end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# source://prism//lib/prism/node.rb#16952
class Prism::SourceLineNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # source://prism//lib/prism/node.rb#16954
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#16961
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16966
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#16976
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#16971
  def compact_child_nodes; end

  # def copy: (?location: Location) -> SourceLineNode
  #
  # source://prism//lib/prism/node.rb#16981
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#16966
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#16989
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#16995
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17014
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17024
    def type; end
  end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# source://prism//lib/prism/node.rb#17033
class Prism::SplatNode < ::Prism::Node
  # def initialize: (Location operator_loc, Prism::node? expression, Location location) -> void
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # source://prism//lib/prism/node.rb#17035
  def initialize(source, operator_loc, expression, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17044
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17049
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17061
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17054
  def compact_child_nodes; end

  # def copy: (?operator_loc: Location, ?expression: Prism::node?, ?location: Location) -> SplatNode
  #
  # source://prism//lib/prism/node.rb#17066
  def copy(operator_loc: T.unsafe(nil), expression: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17049
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, expression: Prism::node?, location: Location }
  #
  # source://prism//lib/prism/node.rb#17074
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node?
  #
  # source://prism//lib/prism/node.rb#17086
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17095
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism//lib/prism/node.rb#17090
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism//lib/prism/node.rb#17079
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17121
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17131
    def type; end
  end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#17140
class Prism::StatementsNode < ::Prism::Node
  # def initialize: (Array[Prism::node] body, Location location) -> void
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # source://prism//lib/prism/node.rb#17142
  def initialize(source, body, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17150
  def accept(visitor); end

  # attr_reader body: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#17183
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17155
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17165
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17160
  def compact_child_nodes; end

  # def copy: (?body: Array[Prism::node], ?location: Location) -> StatementsNode
  #
  # source://prism//lib/prism/node.rb#17170
  def copy(body: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17155
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { body: Array[Prism::node], location: Location }
  #
  # source://prism//lib/prism/node.rb#17178
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17187
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17207
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17217
    def type; end
  end
end

# Flags for string nodes.
#
# source://prism//lib/prism/node.rb#18946
module Prism::StringFlags; end

# internal bytes forced the encoding to binary
#
# source://prism//lib/prism/node.rb#18951
Prism::StringFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism//lib/prism/node.rb#18948
Prism::StringFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# source://prism//lib/prism/node.rb#18954
Prism::StringFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# source://prism//lib/prism/node.rb#18957
Prism::StringFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

# Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# source://prism//lib/prism/node.rb#17232
class Prism::StringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Integer flags, Location? opening_loc, Location content_loc, Location? closing_loc, String unescaped, Location location) -> void
  #
  # @return [StringNode] a new instance of StringNode
  #
  # source://prism//lib/prism/node.rb#17234
  def initialize(source, flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17246
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17251
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#17350
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17303
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17261
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17256
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#17345
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#17296
  def content_loc; end

  # def copy: (?flags: Integer, ?opening_loc: Location?, ?content_loc: Location, ?closing_loc: Location?, ?unescaped: String, ?location: Location) -> StringNode
  #
  # source://prism//lib/prism/node.rb#17266
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17251
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#17274
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17325
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17320
  def forced_utf8_encoding?; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17330
  def frozen?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17355
  def inspect(inspector = T.unsafe(nil)); end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17335
  def mutable?; end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#17340
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17283
  def opening_loc; end

  # Occasionally it's helpful to treat a string as if it were interpolated so
  # that there's a consistent interface for working with strings.
  #
  # source://prism//lib/prism/node_ext.rb#55
  def to_interpolated; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17380
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#17316
  def unescaped; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#17279
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17390
    def type; end
  end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#17402
class Prism::SuperNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, Prism::node? block, Location location) -> void
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://prism//lib/prism/node.rb#17404
  def initialize(source, keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17416
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#17472
  def arguments; end

  # attr_reader block: Prism::node?
  #
  # source://prism//lib/prism/node.rb#17488
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17421
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17434
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17426
  def compact_child_nodes; end

  # def copy: (?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?block: Prism::node?, ?location: Location) -> SuperNode
  #
  # source://prism//lib/prism/node.rb#17439
  def copy(keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17421
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Prism::node?, location: Location }
  #
  # source://prism//lib/prism/node.rb#17447
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17507
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#17492
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#17452
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#17497
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17459
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#17502
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17475
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17541
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17551
    def type; end
  end
end

# Flags for symbol nodes.
#
# source://prism//lib/prism/node.rb#18961
module Prism::SymbolFlags; end

# internal bytes forced the encoding to binary
#
# source://prism//lib/prism/node.rb#18966
Prism::SymbolFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# source://prism//lib/prism/node.rb#18969
Prism::SymbolFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism//lib/prism/node.rb#18963
Prism::SymbolFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# source://prism//lib/prism/node.rb#17563
class Prism::SymbolNode < ::Prism::Node
  # def initialize: (Integer flags, Location? opening_loc, Location? value_loc, Location? closing_loc, String unescaped, Location location) -> void
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # source://prism//lib/prism/node.rb#17565
  def initialize(source, flags, opening_loc, value_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17577
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17582
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#17682
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17640
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17592
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17587
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?opening_loc: Location?, ?value_loc: Location?, ?closing_loc: Location?, ?unescaped: String, ?location: Location) -> SymbolNode
  #
  # source://prism//lib/prism/node.rb#17597
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17582
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#17605
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17662
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17667
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#17657
  def forced_utf8_encoding?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17687
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism//lib/prism/node.rb#17672
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17614
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17712
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#17653
  def unescaped; end

  # def value: () -> String?
  #
  # source://prism//lib/prism/node.rb#17677
  def value; end

  # attr_reader value_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17627
  def value_loc; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#17610
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17722
    def type; end
  end
end

# This represents a token from the Ruby source.
#
# source://prism//lib/prism/parse_result.rb#499
class Prism::Token
  # Create a new token object with the given type, value, and location.
  #
  # @return [Token] a new instance of Token
  #
  # source://prism//lib/prism/parse_result.rb#511
  def initialize(source, type, value, location); end

  # Returns true if the given other token is equal to this token.
  #
  # source://prism//lib/prism/parse_result.rb#546
  def ==(other); end

  # Implement the hash pattern matching interface for Token.
  #
  # source://prism//lib/prism/parse_result.rb#519
  def deconstruct_keys(keys); end

  # A Location object representing the location of this token in the source.
  #
  # source://prism//lib/prism/parse_result.rb#524
  def location; end

  # Implement the pretty print interface for Token.
  #
  # source://prism//lib/prism/parse_result.rb#531
  def pretty_print(q); end

  # The type of token that this token is.
  #
  # source://prism//lib/prism/parse_result.rb#505
  def type; end

  # A byteslice of the source that this token represents.
  #
  # source://prism//lib/prism/parse_result.rb#508
  def value; end

  private

  # The Source object that represents the source this token came from.
  #
  # source://prism//lib/prism/parse_result.rb#501
  def source; end
end

# This module is responsible for converting the prism syntax tree into other
# syntax trees.
#
# source://prism//lib/prism/translation.rb#6
module Prism::Translation; end

# This class is the entry-point for converting a prism syntax tree into the
# whitequark/parser gem's syntax tree. It inherits from the base parser for
# the parser gem, and overrides the parse* methods to parse with prism and
# then translate.
#
# source://prism//lib/prism/translation/parser.rb#11
class Prism::Translation::Parser < ::Parser::Base
  # The default encoding for Ruby files is UTF-8.
  #
  # source://prism//lib/prism/translation/parser.rb#36
  def default_encoding; end

  # Parses a source buffer and returns the AST.
  #
  # source://prism//lib/prism/translation/parser.rb#44
  def parse(source_buffer); end

  # Parses a source buffer and returns the AST and the source code comments.
  #
  # source://prism//lib/prism/translation/parser.rb#57
  def parse_with_comments(source_buffer); end

  # Parses a source buffer and returns the AST, the source code comments,
  # and the tokens emitted by the lexer.
  #
  # source://prism//lib/prism/translation/parser.rb#74
  def tokenize(source_buffer, recover = T.unsafe(nil)); end

  # Since prism resolves num params for us, we don't need to support this
  # kind of logic here.
  #
  # source://prism//lib/prism/translation/parser.rb#100
  def try_declare_numparam(node); end

  # source://prism//lib/prism/translation/parser.rb#31
  def version; end

  # source://prism//lib/prism/translation/parser.rb#40
  def yyerror; end

  private

  # Build the parser gem AST from the prism AST.
  #
  # source://prism//lib/prism/translation/parser.rb#258
  def build_ast(program, offset_cache); end

  # Build the parser gem comments from the prism comments.
  #
  # source://prism//lib/prism/translation/parser.rb#263
  def build_comments(comments, offset_cache); end

  # Prism deals with offsets in bytes, while the parser gem deals with
  # offsets in characters. We need to handle this conversion in order to
  # build the parser gem AST.
  #
  # If the bytesize of the source is the same as the length, then we can
  # just use the offset directly. Otherwise, we build an array where the
  # index is the byte offset and the value is the character offset.
  #
  # source://prism//lib/prism/translation/parser.rb#241
  def build_offset_cache(source); end

  # Build a range from a prism location.
  #
  # source://prism//lib/prism/translation/parser.rb#275
  def build_range(location, offset_cache); end

  # Build the parser gem tokens from the prism tokens.
  #
  # source://prism//lib/prism/translation/parser.rb#270
  def build_tokens(tokens, offset_cache); end

  # Converts the version format handled by Parser to the format handled by Prism.
  #
  # source://prism//lib/prism/translation/parser.rb#284
  def convert_for_prism(version); end

  # Build a diagnostic from the given prism parse error.
  #
  # source://prism//lib/prism/translation/parser.rb#119
  def error_diagnostic(error, offset_cache); end

  # If there was a error generated during the parse, then raise an
  # appropriate syntax error. Otherwise return the result.
  #
  # source://prism//lib/prism/translation/parser.rb#219
  def unwrap(result, offset_cache); end

  # This is a hook to allow consumers to disable some errors if they don't
  # want them to block creating the syntax tree.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/parser.rb#108
  def valid_error?(error); end

  # This is a hook to allow consumers to disable some warnings if they don't
  # want them to block creating the syntax tree.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/parser.rb#114
  def valid_warning?(warning); end

  # Build a diagnostic from the given prism parse warning.
  #
  # source://prism//lib/prism/translation/parser.rb#192
  def warning_diagnostic(warning, offset_cache); end
end

# This class is the entry-point for Ruby 3.3 of `Prism::Translation::Parser`.
#
# source://prism//lib/prism/translation/parser33.rb#6
class Prism::Translation::Parser33 < ::Prism::Translation::Parser
  # source://prism//lib/prism/translation/parser33.rb#7
  def version; end
end

# This class is the entry-point for Ruby 3.4 of `Prism::Translation::Parser`.
#
# source://prism//lib/prism/translation/parser34.rb#6
class Prism::Translation::Parser34 < ::Prism::Translation::Parser
  # source://prism//lib/prism/translation/parser34.rb#7
  def version; end
end

# A visitor that knows how to convert a prism syntax tree into the
# whitequark/parser gem's syntax tree.
#
# source://prism//lib/prism/translation/parser/compiler.rb#8
class Prism::Translation::Parser::Compiler < ::Prism::Compiler
  # Initialize a new compiler with the given parser, offset cache, and
  # options.
  #
  # @return [Compiler] a new instance of Compiler
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#39
  def initialize(parser, offset_cache, forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # The Parser::Builders::Default instance that is being used to build the
  # AST.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#18
  def builder; end

  # The types of values that can be forwarded in the current scope.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#29
  def forwarding; end

  # Whether or not the current node is in a destructure.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#32
  def in_destructure; end

  # Whether or not the current node is in a pattern.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#35
  def in_pattern; end

  # The offset cache that is used to map between byte and character
  # offsets in the file.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#26
  def offset_cache; end

  # The Parser::Base instance that is being used to build the AST.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#14
  def parser; end

  # The Parser::Source::Buffer instance that is holding a reference to the
  # source code.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#22
  def source_buffer; end

  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#58
  def visit_alias_global_variable_node(node); end

  # alias foo bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#52
  def visit_alias_method_node(node); end

  # foo => bar | baz
  #        ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#64
  def visit_alternation_pattern_node(node); end

  # a and b
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#70
  def visit_and_node(node); end

  # foo(bar)
  #     ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#101
  def visit_arguments_node(node); end

  # []
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#76
  def visit_array_node(node); end

  # foo => [bar]
  #        ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#82
  def visit_array_pattern_node(node); end

  # { a: 1 }
  #   ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#107
  def visit_assoc_node(node); end

  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#148
  def visit_assoc_splat_node(node); end

  # $+
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#158
  def visit_back_reference_read_node(node); end

  # begin end
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#164
  def visit_begin_node(node); end

  # foo(&bar)
  #     ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#202
  def visit_block_argument_node(node); end

  # foo { |; bar| }
  #          ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#208
  def visit_block_local_variable_node(node); end

  # A block on a keyword or method call.
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#213
  def visit_block_node(node); end

  # def foo(&bar); end
  #         ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#219
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#224
  def visit_block_parameters_node(node); end

  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#233
  def visit_break_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#319
  def visit_call_and_write_node(node); end

  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#245
  def visit_call_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#319
  def visit_call_operator_write_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#319
  def visit_call_or_write_node(node); end

  # foo.bar, = 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#346
  def visit_call_target_node(node); end

  # foo => bar => baz
  #        ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#358
  def visit_capture_pattern_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#377
  def visit_case_match_node(node); end

  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#364
  def visit_case_node(node); end

  # class Foo; end
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#390
  def visit_class_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#419
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#419
  def visit_class_variable_operator_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#419
  def visit_class_variable_or_write_node(node); end

  # @@foo
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#403
  def visit_class_variable_read_node(node); end

  # @@foo, = bar
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#437
  def visit_class_variable_target_node(node); end

  # @@foo = 1
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#409
  def visit_class_variable_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  # Foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#458
  def visit_constant_and_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#458
  def visit_constant_operator_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  # Foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#458
  def visit_constant_or_write_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#512
  def visit_constant_path_and_write_node(node); end

  # Foo::Bar
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#482
  def visit_constant_path_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#512
  def visit_constant_path_operator_write_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#512
  def visit_constant_path_or_write_node(node); end

  # Foo::Bar, = baz
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#530
  def visit_constant_path_target_node(node); end

  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#502
  def visit_constant_path_write_node(node); end

  # Foo
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#443
  def visit_constant_read_node(node); end

  # Foo, = bar
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#476
  def visit_constant_target_node(node); end

  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#452
  def visit_constant_write_node(node); end

  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#539
  def visit_def_node(node); end

  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#586
  def visit_defined_node(node); end

  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#598
  def visit_else_node(node); end

  # "foo #{bar}"
  #      ^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#604
  def visit_embedded_statements_node(node); end

  # "foo #@bar"
  #      ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#614
  def visit_embedded_variable_node(node); end

  # begin; foo; ensure; bar; end
  #             ^^^^^^^^^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#620
  def visit_ensure_node(node); end

  # false
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#626
  def visit_false_node(node); end

  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#632
  def visit_find_pattern_node(node); end

  # 0..5
  # ^^^^
  # if foo .. bar; end
  #    ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1323
  def visit_flip_flop_node(node); end

  # 1.0
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#644
  def visit_float_node(node); end

  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#650
  def visit_for_node(node); end

  # def foo(...); bar(...); end
  #                   ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#668
  def visit_forwarding_arguments_node(node); end

  # def foo(...); end
  #         ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#674
  def visit_forwarding_parameter_node(node); end

  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#683
  def visit_forwarding_super_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  # $foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#711
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#711
  def visit_global_variable_operator_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  # $foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#711
  def visit_global_variable_or_write_node(node); end

  # $foo
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#695
  def visit_global_variable_read_node(node); end

  # $foo, = bar
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#729
  def visit_global_variable_target_node(node); end

  # $foo = 1
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#701
  def visit_global_variable_write_node(node); end

  # {}
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#735
  def visit_hash_node(node); end

  # foo => {}
  #        ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#745
  def visit_hash_pattern_node(node); end

  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#763
  def visit_if_node(node); end

  # 1i
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#805
  def visit_imaginary_node(node); end

  # { foo: }
  #   ^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#811
  def visit_implicit_node(node); end

  # foo { |bar,| }
  #           ^
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#817
  def visit_implicit_rest_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#823
  def visit_in_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#849
  def visit_index_and_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#849
  def visit_index_operator_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#849
  def visit_index_or_write_node(node); end

  # foo[bar], = 1
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#875
  def visit_index_target_node(node); end

  # ^^^^^^^^^^^
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#902
  def visit_instance_variable_and_write_node(node); end

  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#902
  def visit_instance_variable_operator_write_node(node); end

  # ^^^^^^^^^^^
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#902
  def visit_instance_variable_or_write_node(node); end

  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#886
  def visit_instance_variable_read_node(node); end

  # @foo, = bar
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#920
  def visit_instance_variable_target_node(node); end

  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#892
  def visit_instance_variable_write_node(node); end

  # 1
  # ^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#926
  def visit_integer_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#932
  def visit_interpolated_match_last_line_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#932
  def visit_interpolated_regular_expression_node(node); end

  # "foo #{bar}"
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#947
  def visit_interpolated_string_node(node); end

  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#983
  def visit_interpolated_symbol_node(node); end

  # `foo #{bar}`
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#993
  def visit_interpolated_x_string_node(node); end

  # foo(bar: baz)
  #     ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1008
  def visit_keyword_hash_node(node); end

  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1017
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1026
  def visit_lambda_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  # foo &&= bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1067
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1067
  def visit_local_variable_operator_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  # foo ||= bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1067
  def visit_local_variable_or_write_node(node); end

  # foo
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1051
  def visit_local_variable_read_node(node); end

  # foo, = bar
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1085
  def visit_local_variable_target_node(node); end

  # foo = 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1057
  def visit_local_variable_write_node(node); end

  # /foo/
  # ^^^^^
  # if /foo/ then end
  #    ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1357
  def visit_match_last_line_node(node); end

  # foo in bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1095
  def visit_match_predicate_node(node); end

  # foo => bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1105
  def visit_match_required_node(node); end

  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1115
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error. The parser gem doesn't have such a concept, so
  # we invent our own here.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1126
  def visit_missing_node(node); end

  # module Foo; end
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1132
  def visit_module_node(node); end

  # foo, bar = baz
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1143
  def visit_multi_target_node(node); end

  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1157
  def visit_multi_write_node(node); end

  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1178
  def visit_next_node(node); end

  # nil
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1190
  def visit_nil_node(node); end

  # def foo(**nil); end
  #         ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1196
  def visit_no_keywords_parameter_node(node); end

  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1206
  def visit_numbered_parameters_node(node); end

  # $1
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1212
  def visit_numbered_reference_read_node(node); end

  # def foo(bar: baz); end
  #         ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1218
  def visit_optional_keyword_parameter_node(node); end

  # def foo(bar = 1); end
  #         ^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1224
  def visit_optional_parameter_node(node); end

  # a or b
  # ^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1230
  def visit_or_node(node); end

  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1236
  def visit_parameters_node(node); end

  # ()
  # ^^
  #
  # (1)
  # ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1275
  def visit_parentheses_node(node); end

  # foo => ^(bar)
  #        ^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1285
  def visit_pinned_expression_node(node); end

  # foo = 1 and bar => ^foo
  #                    ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1292
  def visit_pinned_variable_node(node); end

  # END {}
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1297
  def visit_post_execution_node(node); end

  # BEGIN {}
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1307
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1317
  def visit_program_node(node); end

  # 0..5
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1323
  def visit_range_node(node); end

  # 1r
  # ^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1345
  def visit_rational_node(node); end

  # redo
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1351
  def visit_redo_node(node); end

  # /foo/
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1357
  def visit_regular_expression_node(node); end

  # def foo(bar:); end
  #         ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1372
  def visit_required_keyword_parameter_node(node); end

  # def foo(bar); end
  #         ^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1378
  def visit_required_parameter_node(node); end

  # foo rescue bar
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1384
  def visit_rescue_modifier_node(node); end

  # begin; rescue; end
  #        ^^^^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1402
  def visit_rescue_node(node); end

  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1411
  def visit_rest_parameter_node(node); end

  # retry
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1417
  def visit_retry_node(node); end

  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1426
  def visit_return_node(node); end

  # self
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1438
  def visit_self_node(node); end

  # A shareable constant.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1443
  def visit_shareable_constant_node(node); end

  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1449
  def visit_singleton_class_node(node); end

  # __ENCODING__
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1461
  def visit_source_encoding_node(node); end

  # __FILE__
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1467
  def visit_source_file_node(node); end

  # __LINE__
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1473
  def visit_source_line_node(node); end

  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1485
  def visit_splat_node(node); end

  # A list of statements.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1498
  def visit_statements_node(node); end

  # "foo"
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1504
  def visit_string_node(node); end

  # super(foo)
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1535
  def visit_super_node(node); end

  # :foo
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1558
  def visit_symbol_node(node); end

  # true
  # ^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1590
  def visit_true_node(node); end

  # undef foo
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1596
  def visit_undef_node(node); end

  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1605
  def visit_unless_node(node); end

  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1635
  def visit_until_node(node); end

  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1657
  def visit_when_node(node); end

  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1675
  def visit_while_node(node); end

  # `foo`
  # ^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1697
  def visit_x_string_node(node); end

  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1729
  def visit_yield_node(node); end

  private

  # Initialize a new compiler with the given option overrides, used to
  # visit a subtree with the given options.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1743
  def copy_compiler(forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # When *, **, &, or ... are used as an argument in a method call, we
  # check if they were allowed by the current context. To determine that
  # we build this lookup table.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1750
  def find_forwarding(node); end

  # Because we have mutated the AST to allow for newlines in the middle of
  # a rational, we need to manually handle the value here.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1764
  def imaginary_value(node); end

  # Negate the value of a numeric node. This is a special case where you
  # have a negative sign on one line and then a number on the next line.
  # In normal Ruby, this will always be a method call. The parser gem,
  # however, marks this as a numeric literal. We have to massage the tree
  # here to get it into the correct form.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1773
  def numeric_negate(message_loc, receiver); end

  # Blocks can have a special set of parameters that automatically expand
  # when given arrays if they have a single required parameter and no
  # other parameters.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1785
  def procarg0?(parameters); end

  # Because we have mutated the AST to allow for newlines in the middle of
  # a rational, we need to manually handle the value here.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1798
  def rational_value(node); end

  # Constructs a new source range from the given start and end offsets.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1812
  def srange(location); end

  # Constructs a new source range by finding the given tokens between the
  # given start offset and end offset. If the needle is not found, it
  # returns nil.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1824
  def srange_find(start_offset, end_offset, tokens); end

  # Constructs a new source range from the given start and end offsets.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1817
  def srange_offsets(start_offset, end_offset); end

  # Transform a location into a token that the parser gem expects.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1833
  def token(location); end

  # Visit a block node on a call.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1838
  def visit_block(call, block); end

  # Visit a heredoc that can be either a string or an xstring.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1871
  def visit_heredoc(node); end

  # Visit a numeric node and account for the optional sign.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1917
  def visit_numeric(node, value); end

  # Within the given block, track that we're within a pattern.
  #
  # source://prism//lib/prism/translation/parser/compiler.rb#1929
  def within_pattern; end
end

# Raised when the tree is malformed or there is a bug in the compiler.
#
# source://prism//lib/prism/translation/parser/compiler.rb#10
class Prism::Translation::Parser::Compiler::CompilationError < ::StandardError; end

# Locations in the parser gem AST are generated using this class. We
# store a reference to its constant to make it slightly faster to look
# up.
#
# source://prism//lib/prism/translation/parser/compiler.rb#1809
Prism::Translation::Parser::Compiler::Range = Parser::Source::Range

# source://prism//lib/prism/translation/parser.rb#12
Prism::Translation::Parser::Diagnostic = Parser::Diagnostic

# Accepts a list of prism tokens and converts them into the expected
# format for the parser gem.
#
# source://prism//lib/prism/translation/parser/lexer.rb#8
class Prism::Translation::Parser::Lexer
  # Initialize the lexer with the given source buffer, prism tokens, and
  # offset cache.
  #
  # @return [Lexer] a new instance of Lexer
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#204
  def initialize(source_buffer, lexed, offset_cache); end

  # An array of tuples that contain prism tokens and their associated lex
  # state when they were lexed.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#197
  def lexed; end

  # A hash that maps offsets in bytes to offsets in characters.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#200
  def offset_cache; end

  # The Parser::Source::Buffer that the tokens were lexed from.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#193
  def source_buffer; end

  # Convert the prism tokens into the expected format for the parser gem.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#214
  def to_a; end

  private

  # Parse a complex from the string representation.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#387
  def parse_complex(value); end

  # Parse a float from the string representation.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#380
  def parse_float(value); end

  # Parse an integer from the string representation.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#373
  def parse_integer(value); end

  # Parse a rational from the string representation.
  #
  # source://prism//lib/prism/translation/parser/lexer.rb#402
  def parse_rational(value); end
end

# These constants represent flags in our lex state. We really, really
# don't want to be using them and we really, really don't want to be
# exposing them as part of our public API. Unfortunately, we don't have
# another way of matching the exact tokens that the parser gem expects
# without them. We should find another way to do this, but in the
# meantime we'll hide them from the documentation and mark them as
# private constants.
#
# source://prism//lib/prism/translation/parser/lexer.rb#187
Prism::Translation::Parser::Lexer::EXPR_BEG = T.let(T.unsafe(nil), Integer)

# source://prism//lib/prism/translation/parser/lexer.rb#188
Prism::Translation::Parser::Lexer::EXPR_LABEL = T.let(T.unsafe(nil), Integer)

# source://prism//lib/prism/translation/parser/lexer.rb#210
Prism::Translation::Parser::Lexer::Range = Parser::Source::Range

# The direct translating of types between the two lexers.
#
# source://prism//lib/prism/translation/parser/lexer.rb#10
Prism::Translation::Parser::Lexer::TYPES = T.let(T.unsafe(nil), Hash)

# The parser gem has a list of diagnostics with a hard-coded set of error
# messages. We create our own diagnostic class in order to set our own
# error messages.
#
# source://prism//lib/prism/translation/parser.rb#18
class Prism::Translation::Parser::PrismDiagnostic < ::Parser::Diagnostic
  # Initialize a new diagnostic with the given message and location.
  #
  # @return [PrismDiagnostic] a new instance of PrismDiagnostic
  #
  # source://prism//lib/prism/translation/parser.rb#23
  def initialize(message, level, reason, location); end

  # This is the cached message coming from prism.
  #
  # source://prism//lib/prism/translation/parser.rb#20
  def message; end
end

# source://prism//lib/prism/translation/parser.rb#29
Prism::Translation::Parser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)

# This class provides a compatibility layer between prism and Ripper. It
# functions by parsing the entire tree first and then walking it and
# executing each of the Ripper callbacks as it goes. To use this class, you
# treat `Prism::Translation::Ripper` effectively as you would treat the
# `Ripper` class.
#
# Note that this class will serve the most common use cases, but Ripper's
# API is extensive and undocumented. It relies on reporting the state of the
# parser at any given time. We do our best to replicate that here, but
# because it is a different architecture it is not possible to perfectly
# replicate the behavior of Ripper.
#
# The main known difference is that we may omit dispatching some events in
# some cases. This impacts the following events:
#
# * on_assign_error
# * on_comma
# * on_ignored_nl
# * on_ignored_sp
# * on_kw
# * on_label_end
# * on_lbrace
# * on_lbracket
# * on_lparen
# * on_nl
# * on_op
# * on_operator_ambiguous
# * on_rbrace
# * on_rbracket
# * on_rparen
# * on_semicolon
# * on_sp
# * on_symbeg
# * on_tstring_beg
# * on_tstring_end
#
# source://prism//lib/prism/translation/ripper.rb#43
class Prism::Translation::Ripper < ::Prism::Compiler
  # Create a new Translation::Ripper object with the given source.
  #
  # @return [Ripper] a new instance of Ripper
  #
  # source://prism//lib/prism/translation/ripper.rb#444
  def initialize(source, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

  # The current column number of the parser.
  #
  # source://prism//lib/prism/translation/ripper.rb#441
  def column; end

  # True if the parser encountered an error during parsing.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/ripper.rb#457
  def error?; end

  # The filename of the source being parsed.
  #
  # source://prism//lib/prism/translation/ripper.rb#435
  def filename; end

  # The current line number of the parser.
  #
  # source://prism//lib/prism/translation/ripper.rb#438
  def lineno; end

  # Parse the source and return the result.
  #
  # source://prism//lib/prism/translation/ripper.rb#462
  def parse; end

  # The source that is being parsed.
  #
  # source://prism//lib/prism/translation/ripper.rb#432
  def source; end

  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#561
  def visit_alias_global_variable_node(node); end

  # alias foo bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#551
  def visit_alias_method_node(node); end

  # foo => bar | baz
  #        ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#585
  def visit_alternation_pattern_node(node); end

  # a and b
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#605
  def visit_and_node(node); end

  # foo(bar)
  #     ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#796
  def visit_arguments_node(node); end

  # []
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#615
  def visit_array_node(node); end

  # foo => [bar]
  #        ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#775
  def visit_array_pattern_node(node); end

  # { a: 1 }
  #   ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#803
  def visit_assoc_node(node); end

  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#816
  def visit_assoc_splat_node(node); end

  # $+
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#825
  def visit_back_reference_read_node(node); end

  # begin end
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#832
  def visit_begin_node(node); end

  # foo(&bar)
  #     ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#896
  def visit_block_argument_node(node); end

  # foo { |; bar| }
  #          ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#902
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode.
  #
  # source://prism//lib/prism/translation/ripper.rb#908
  def visit_block_node(node); end

  # def foo(&bar); end
  #         ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#944
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # source://prism//lib/prism/translation/ripper.rb#958
  def visit_block_parameters_node(node); end

  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#982
  def visit_break_node(node); end

  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1194
  def visit_call_and_write_node(node); end

  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1002
  def visit_call_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1172
  def visit_call_operator_write_node(node); end

  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1216
  def visit_call_or_write_node(node); end

  # foo.bar, = 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1238
  def visit_call_target_node(node); end

  # foo => bar => baz
  #        ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1263
  def visit_capture_pattern_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1286
  def visit_case_match_node(node); end

  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1273
  def visit_case_node(node); end

  # class Foo; end
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1299
  def visit_class_node(node); end

  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1352
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1338
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1366
  def visit_class_variable_or_write_node(node); end

  # @@foo
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1317
  def visit_class_variable_read_node(node); end

  # @@foo, = bar
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1380
  def visit_class_variable_target_node(node); end

  # @@foo = 1
  # ^^^^^^^^^
  #
  # @@foo, @@bar = 1
  # ^^^^^  ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1327
  def visit_class_variable_write_node(node); end

  # Foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1422
  def visit_constant_and_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1408
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1436
  def visit_constant_or_write_node(node); end

  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1523
  def visit_constant_path_and_write_node(node); end

  # Foo::Bar
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1457
  def visit_constant_path_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1509
  def visit_constant_path_operator_write_node(node); end

  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1537
  def visit_constant_path_or_write_node(node); end

  # Foo::Bar, = baz
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1551
  def visit_constant_path_target_node(node); end

  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1480
  def visit_constant_path_write_node(node); end

  # Foo
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1387
  def visit_constant_read_node(node); end

  # Foo, = bar
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1450
  def visit_constant_target_node(node); end

  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1397
  def visit_constant_write_node(node); end

  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1560
  def visit_def_node(node); end

  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1607
  def visit_defined_node(node); end

  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1614
  def visit_else_node(node); end

  # "foo #{bar}"
  #      ^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1630
  def visit_embedded_statements_node(node); end

  # "foo #@bar"
  #      ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1651
  def visit_embedded_variable_node(node); end

  # Visit an EnsureNode node.
  #
  # source://prism//lib/prism/translation/ripper.rb#1662
  def visit_ensure_node(node); end

  # false
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1680
  def visit_false_node(node); end

  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1687
  def visit_find_pattern_node(node); end

  # if foo .. bar; end
  #    ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1712
  def visit_flip_flop_node(node); end

  # 1.0
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1726
  def visit_float_node(node); end

  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1732
  def visit_for_node(node); end

  # def foo(...); bar(...); end
  #                   ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1749
  def visit_forwarding_arguments_node(node); end

  # def foo(...); end
  #         ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1756
  def visit_forwarding_parameter_node(node); end

  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1766
  def visit_forwarding_super_node(node); end

  # $foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1815
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1801
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1829
  def visit_global_variable_or_write_node(node); end

  # $foo
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1780
  def visit_global_variable_read_node(node); end

  # $foo, = bar
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1843
  def visit_global_variable_target_node(node); end

  # $foo = 1
  # ^^^^^^^^
  #
  # $foo, $bar = 1
  # ^^^^  ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1790
  def visit_global_variable_write_node(node); end

  # {}
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1850
  def visit_hash_node(node); end

  # foo => {}
  #        ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1865
  def visit_hash_pattern_node(node); end

  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1907
  def visit_if_node(node); end

  # 1i
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1943
  def visit_imaginary_node(node); end

  # { foo: }
  #   ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1949
  def visit_implicit_node(node); end

  # foo { |bar,| }
  #           ^
  #
  # source://prism//lib/prism/translation/ripper.rb#1954
  def visit_implicit_rest_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1961
  def visit_in_node(node); end

  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1996
  def visit_index_and_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#1979
  def visit_index_operator_write_node(node); end

  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2013
  def visit_index_or_write_node(node); end

  # foo[bar], = 1
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2030
  def visit_index_target_node(node); end

  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2072
  def visit_instance_variable_and_write_node(node); end

  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2058
  def visit_instance_variable_operator_write_node(node); end

  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2086
  def visit_instance_variable_or_write_node(node); end

  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2040
  def visit_instance_variable_read_node(node); end

  # @foo, = bar
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2100
  def visit_instance_variable_target_node(node); end

  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2047
  def visit_instance_variable_write_node(node); end

  # 1
  # ^
  #
  # source://prism//lib/prism/translation/ripper.rb#2107
  def visit_integer_node(node); end

  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2113
  def visit_interpolated_match_last_line_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2132
  def visit_interpolated_regular_expression_node(node); end

  # "foo #{bar}"
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2151
  def visit_interpolated_string_node(node); end

  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2179
  def visit_interpolated_symbol_node(node); end

  # `foo #{bar}`
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2192
  def visit_interpolated_x_string_node(node); end

  # -> { it }
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2222
  def visit_it_parameters_node(node); end

  # foo(bar: baz)
  #     ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2227
  def visit_keyword_hash_node(node); end

  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2239
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  #
  # source://prism//lib/prism/translation/ripper.rb#2253
  def visit_lambda_node(node); end

  # foo &&= bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2350
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2336
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  # ^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2364
  def visit_local_variable_or_write_node(node); end

  # foo
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2313
  def visit_local_variable_read_node(node); end

  # foo, = bar
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2378
  def visit_local_variable_target_node(node); end

  # foo = 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2325
  def visit_local_variable_write_node(node); end

  # if /foo/ then end
  #    ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2385
  def visit_match_last_line_node(node); end

  # foo in bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2400
  def visit_match_predicate_node(node); end

  # foo => bar
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2409
  def visit_match_required_node(node); end

  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2418
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error.
  #
  # source://prism//lib/prism/translation/ripper.rb#2424
  def visit_missing_node(node); end

  # module Foo; end
  # ^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2430
  def visit_module_node(node); end

  # (foo, bar), bar = qux
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2447
  def visit_multi_target_node(node); end

  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2501
  def visit_multi_write_node(node); end

  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2521
  def visit_next_node(node); end

  # nil
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2535
  def visit_nil_node(node); end

  # def foo(**nil); end
  #         ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2542
  def visit_no_keywords_parameter_node(node); end

  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2551
  def visit_numbered_parameters_node(node); end

  # $1
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2556
  def visit_numbered_reference_read_node(node); end

  # def foo(bar: baz); end
  #         ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2563
  def visit_optional_keyword_parameter_node(node); end

  # def foo(bar = 1); end
  #         ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2573
  def visit_optional_parameter_node(node); end

  # a or b
  # ^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2583
  def visit_or_node(node); end

  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2593
  def visit_parameters_node(node); end

  # ()
  # ^^
  #
  # (1)
  # ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2620
  def visit_parentheses_node(node); end

  # foo => ^(bar)
  #        ^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2634
  def visit_pinned_expression_node(node); end

  # foo = 1 and bar => ^foo
  #                    ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2643
  def visit_pinned_variable_node(node); end

  # END {}
  # ^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2649
  def visit_post_execution_node(node); end

  # BEGIN {}
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2664
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # source://prism//lib/prism/translation/ripper.rb#2678
  def visit_program_node(node); end

  # 0..5
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2689
  def visit_range_node(node); end

  # 1r
  # ^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2703
  def visit_rational_node(node); end

  # redo
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2709
  def visit_redo_node(node); end

  # /foo/
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2716
  def visit_regular_expression_node(node); end

  # def foo(bar:); end
  #         ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2738
  def visit_required_keyword_parameter_node(node); end

  # def foo(bar); end
  #         ^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2745
  def visit_required_parameter_node(node); end

  # foo rescue bar
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2752
  def visit_rescue_modifier_node(node); end

  # begin; rescue; end
  #        ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2762
  def visit_rescue_node(node); end

  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  #
  # source://prism//lib/prism/translation/ripper.rb#2820
  def visit_rest_parameter_node(node); end

  # retry
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2832
  def visit_retry_node(node); end

  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2842
  def visit_return_node(node); end

  # self
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2856
  def visit_self_node(node); end

  # A shareable constant.
  #
  # source://prism//lib/prism/translation/ripper.rb#2862
  def visit_shareable_constant_node(node); end

  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2868
  def visit_singleton_class_node(node); end

  # __ENCODING__
  # ^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2878
  def visit_source_encoding_node(node); end

  # __FILE__
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2885
  def visit_source_file_node(node); end

  # __LINE__
  # ^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2892
  def visit_source_line_node(node); end

  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  #
  # source://prism//lib/prism/translation/ripper.rb#2905
  def visit_splat_node(node); end

  # A list of statements.
  #
  # source://prism//lib/prism/translation/ripper.rb#2910
  def visit_statements_node(node); end

  # "foo"
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#2927
  def visit_string_node(node); end

  # super(foo)
  # ^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3059
  def visit_super_node(node); end

  # :foo
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3080
  def visit_symbol_node(node); end

  # true
  # ^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3104
  def visit_true_node(node); end

  # undef foo
  # ^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3111
  def visit_undef_node(node); end

  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3123
  def visit_unless_node(node); end

  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3151
  def visit_until_node(node); end

  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3175
  def visit_when_node(node); end

  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3196
  def visit_while_node(node); end

  # `foo`
  # ^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3220
  def visit_x_string_node(node); end

  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  #
  # source://prism//lib/prism/translation/ripper.rb#3243
  def visit_yield_node(node); end

  private

  # :stopdoc:
  #
  # source://prism//lib/prism/translation/ripper.rb#3383
  def _dispatch_0; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def _dispatch_1(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def _dispatch_2(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def _dispatch_3(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def _dispatch_4(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3388
  def _dispatch_5(_, _, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3389
  def _dispatch_7(_, _, _, _, _, _, _); end

  # This method is responsible for updating lineno and column information
  # to reflect the current node.
  #
  # This method could be drastically improved with some caching on the start
  # of every line, but for now it's good enough.
  #
  # source://prism//lib/prism/translation/ripper.rb#3373
  def bounds(location); end

  # Returns true if the given node is a command node.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/ripper.rb#1163
  def command?(node); end

  # This method is called when the parser found syntax error.
  #
  # source://prism//lib/prism/translation/ripper.rb#3411
  def compile_error(msg); end

  # This method is provided by the Ripper C extension. It is called when a
  # string needs to be dedented because of a tilde heredoc. It is expected
  # that it will modify the string in place and return the number of bytes
  # that were removed.
  #
  # source://prism//lib/prism/translation/ripper.rb#3426
  def dedent_string(string, width); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_BEGIN(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_CHAR(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_END(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on___end__(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_alias(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_alias_error(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_aref(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_aref_field(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_arg_ambiguous(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_arg_paren(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_args_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_args_add_block(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_args_add_star(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_args_forward; end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_args_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_array(_); end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def on_aryptn(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_assign(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_assign_error(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_assoc_new(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_assoc_splat(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_assoclist_from_args(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_backref(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_backtick(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_bare_assoc_hash(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_begin(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_binary(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_block_var(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_blockarg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def on_bodystmt(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_brace_block(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_break(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_call(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_case(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_class(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_class_name_error(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_comma(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_command(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def on_command_call(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_comment(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_const(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_const_path_field(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_const_path_ref(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_const_ref(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_cvar(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_def(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_defined(_); end

  # source://prism//lib/prism/translation/ripper.rb#3388
  def on_defs(_, _, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_do_block(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_dot2(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_dot3(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_dyna_symbol(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_else(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_elsif(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embdoc(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embdoc_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embdoc_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embexpr_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embexpr_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_embvar(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_ensure(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_excessed_comma; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_fcall(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_field(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_float(_); end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def on_fndptn(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_for(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_gvar(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_hash(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_heredoc_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_heredoc_dedent(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_heredoc_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_hshptn(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_ident(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_if(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_if_mod(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_ifop(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_ignored_nl(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_ignored_sp(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_imaginary(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_in(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_int(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_ivar(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_kw(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_kwrest_param(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_label(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_label_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_lambda(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_lbrace(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_lbracket(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_lparen(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_magic_comment(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_massign(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_method_add_arg(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_method_add_block(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_mlhs_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_mlhs_add_post(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_mlhs_add_star(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_mlhs_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_mlhs_paren(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_module(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_mrhs_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_mrhs_add_star(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_mrhs_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_mrhs_new_from_args(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_next(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_nl(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_nokw_param(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_op(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_opassign(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_operator_ambiguous(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_param_error(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3389
  def on_params(_, _, _, _, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_paren(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_parse_error(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_period(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_program(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_qsymbols_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_qsymbols_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_qsymbols_new; end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_qwords_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_qwords_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_qwords_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_rational(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_rbrace(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_rbracket(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_redo; end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_regexp_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_regexp_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_regexp_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_regexp_literal(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_regexp_new; end

  # source://prism//lib/prism/translation/ripper.rb#3387
  def on_rescue(_, _, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_rescue_mod(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_rest_param(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_retry; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_return(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_return0; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_rparen(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_sclass(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_semicolon(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_sp(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_stmts_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_stmts_new; end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_string_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_string_concat(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_string_content; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_string_dvar(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_string_embexpr(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_string_literal(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_super(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_symbeg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_symbol(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_symbol_literal(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_symbols_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_symbols_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_symbols_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_tlambda(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_tlambeg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_top_const_field(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_top_const_ref(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_tstring_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_tstring_content(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_tstring_end(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_unary(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_undef(_); end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_unless(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_unless_mod(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_until(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_until_mod(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_var_alias(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_var_field(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_var_ref(_); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_vcall(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_void_stmt; end

  # source://prism//lib/prism/translation/ripper.rb#3386
  def on_when(_, _, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_while(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_while_mod(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_word_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_word_new; end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_words_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_words_beg(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_words_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_words_sep(_); end

  # source://prism//lib/prism/translation/ripper.rb#3385
  def on_xstring_add(_, _); end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_xstring_literal(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_xstring_new; end

  # source://prism//lib/prism/translation/ripper.rb#3384
  def on_yield(_); end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_yield0; end

  # source://prism//lib/prism/translation/ripper.rb#3383
  def on_zsuper; end

  # Lazily initialize the parse result.
  #
  # source://prism//lib/prism/translation/ripper.rb#3269
  def result; end

  # Returns true if there is a comma between the two locations.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/ripper.rb#3278
  def trailing_comma?(left, right); end

  # Visit one side of an alias global variable node.
  #
  # source://prism//lib/prism/translation/ripper.rb#570
  def visit_alias_global_variable_node_value(node); end

  # Visit a list of elements, like the elements of an array or arguments.
  #
  # source://prism//lib/prism/translation/ripper.rb#756
  def visit_arguments(elements); end

  # Visit the clauses of a begin node to form an on_bodystmt call.
  #
  # source://prism//lib/prism/translation/ripper.rb#840
  def visit_begin_node_clauses(location, node, allow_newline); end

  # Visit the body of a structure that can have either a set of statements
  # or statements wrapped in rescue/else/ensure.
  #
  # source://prism//lib/prism/translation/ripper.rb#875
  def visit_body_node(location, node, allow_newline = T.unsafe(nil)); end

  # Visit the arguments and block of a call node and return the arguments
  # and block as they should be used.
  #
  # source://prism//lib/prism/translation/ripper.rb#1136
  def visit_call_node_arguments(arguments_node, block_node, trailing_comma); end

  # Visit a constant path that is part of a write node.
  #
  # source://prism//lib/prism/translation/ripper.rb#1489
  def visit_constant_path_write_node_target(node); end

  # Visit a destructured positional parameter node.
  #
  # source://prism//lib/prism/translation/ripper.rb#2607
  def visit_destructured_parameter_node(node); end

  # Visit a string that is expressed using a <<~ heredoc.
  #
  # source://prism//lib/prism/translation/ripper.rb#2978
  def visit_heredoc_node(parts, base); end

  # Ripper gives back the escaped string content but strips out the common
  # leading whitespace. Prism gives back the unescaped string content and
  # a location for the escaped string content. Unfortunately these don't
  # work well together, so here we need to re-derive the common leading
  # whitespace.
  #
  # source://prism//lib/prism/translation/ripper.rb#2953
  def visit_heredoc_node_whitespace(parts); end

  # Visit a heredoc node that is representing a string.
  #
  # source://prism//lib/prism/translation/ripper.rb#3024
  def visit_heredoc_string_node(node); end

  # Visit a heredoc node that is representing an xstring.
  #
  # source://prism//lib/prism/translation/ripper.rb#3041
  def visit_heredoc_x_string_node(node); end

  # Visit the targets of a multi-target node.
  #
  # source://prism//lib/prism/translation/ripper.rb#2460
  def visit_multi_target_node_targets(lefts, rest, rights, skippable); end

  # Visit a node that represents a number. We need to explicitly handle the
  # unary - operator.
  #
  # source://prism//lib/prism/translation/ripper.rb#3317
  def visit_number_node(node); end

  # Visit a pattern within a pattern match. This is used to bypass the
  # parenthesis node that can be used to wrap patterns.
  #
  # source://prism//lib/prism/translation/ripper.rb#595
  def visit_pattern_node(node); end

  # Visit the list of statements of a statements node. We support nil
  # statements in the list. This would normally not be allowed by the
  # structure of the prism parse tree, but we manually add them here so that
  # we can mirror Ripper's void stmt.
  #
  # source://prism//lib/prism/translation/ripper.rb#2919
  def visit_statements_node_body(body); end

  # Visit an individual part of a string-like node.
  #
  # source://prism//lib/prism/translation/ripper.rb#2211
  def visit_string_content(part); end

  # Visit the string content of a particular node. This method is used to
  # split into the various token types.
  #
  # source://prism//lib/prism/translation/ripper.rb#3290
  def visit_token(token, allow_keywords = T.unsafe(nil)); end

  # Dispatch a words_sep event that contains the space between the elements
  # of list literals.
  #
  # source://prism//lib/prism/translation/ripper.rb#745
  def visit_words_sep(opening_loc, previous, current); end

  # Visit a node that represents a write value. This is used to handle the
  # special case of an implicit array that is generated without brackets.
  #
  # source://prism//lib/prism/translation/ripper.rb#3335
  def visit_write_value(node); end

  # Returns true if there is a semicolon between the two locations.
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/translation/ripper.rb#3283
  def void_stmt?(left, right, allow_newline); end

  # This method is called when weak warning is produced by the parser.
  # +fmt+ and +args+ is printf style.
  #
  # source://prism//lib/prism/translation/ripper.rb#3402
  def warn(fmt, *args); end

  # This method is called when strong warning is produced by the parser.
  # +fmt+ and +args+ is printf style.
  #
  # source://prism//lib/prism/translation/ripper.rb#3407
  def warning(fmt, *args); end

  class << self
    # Tokenizes the Ruby program and returns an array of an array,
    # which is formatted like
    # <code>[[lineno, column], type, token, state]</code>.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # use the +raise_errors+ keyword to raise a SyntaxError for an error in +src+.
    #
    #   require 'ripper'
    #   require 'pp'
    #
    #   pp Ripper.lex("def m(a) nil end")
    #   #=> [[[1,  0], :on_kw,     "def", FNAME    ],
    #        [[1,  3], :on_sp,     " ",   FNAME    ],
    #        [[1,  4], :on_ident,  "m",   ENDFN    ],
    #        [[1,  5], :on_lparen, "(",   BEG|LABEL],
    #        [[1,  6], :on_ident,  "a",   ARG      ],
    #        [[1,  7], :on_rparen, ")",   ENDFN    ],
    #        [[1,  8], :on_sp,     " ",   BEG      ],
    #        [[1,  9], :on_kw,     "nil", END      ],
    #        [[1, 12], :on_sp,     " ",   END      ],
    #        [[1, 13], :on_kw,     "end", END      ]]
    #
    # source://prism//lib/prism/translation/ripper.rb#72
    def lex(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end

    # Parses the given Ruby program read from +src+.
    # +src+ must be a String or an IO or a object with a #gets method.
    #
    # source://prism//lib/prism/translation/ripper.rb#46
    def parse(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

    # Parses +src+ and create S-exp tree.
    # Returns more readable tree rather than Ripper.sexp_raw.
    # This method is mainly for developer use.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # returning +nil+ in such cases. Use the +raise_errors+ keyword
    # to raise a SyntaxError for an error in +src+.
    #
    #   require "ripper"
    #   require "pp"
    #
    #   pp Ripper.sexp("def m(a) nil end")
    #     #=> [:program,
    #          [[:def,
    #           [:@ident, "m", [1, 4]],
    #           [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil, nil, nil, nil]],
    #           [:bodystmt, [[:var_ref, [:@kw, "nil", [1, 9]]]], nil, nil, nil]]]]
    #
    # source://prism//lib/prism/translation/ripper.rb#381
    def sexp(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end

    # Parses +src+ and create S-exp tree.
    # This method is mainly for developer use.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # returning +nil+ in such cases. Use the +raise_errors+ keyword
    # to raise a SyntaxError for an error in +src+.
    #
    #   require 'ripper'
    #   require 'pp'
    #
    #   pp Ripper.sexp_raw("def m(a) nil end")
    #     #=> [:program,
    #          [:stmts_add,
    #           [:stmts_new],
    #           [:def,
    #            [:@ident, "m", [1, 4]],
    #            [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil]],
    #            [:bodystmt,
    #             [:stmts_add, [:stmts_new], [:var_ref, [:@kw, "nil", [1, 9]]]],
    #             nil,
    #             nil,
    #             nil]]]]
    #
    # source://prism//lib/prism/translation/ripper.rb#416
    def sexp_raw(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
  end
end

# A list of all of the Ruby binary operators.
#
# source://prism//lib/prism/translation/ripper.rb#337
Prism::Translation::Ripper::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)

# This array contains name of all ripper events.
#
# source://prism//lib/prism/translation/ripper.rb#289
Prism::Translation::Ripper::EVENTS = T.let(T.unsafe(nil), Array)

# A list of all of the Ruby keywords.
#
# source://prism//lib/prism/translation/ripper.rb#292
Prism::Translation::Ripper::KEYWORDS = T.let(T.unsafe(nil), Array)

# This array contains name of parser events.
#
# source://prism//lib/prism/translation/ripper.rb#283
Prism::Translation::Ripper::PARSER_EVENTS = T.let(T.unsafe(nil), Array)

# This contains a table of all of the parser events and their
# corresponding arity.
#
# source://prism//lib/prism/translation/ripper.rb#84
Prism::Translation::Ripper::PARSER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

# This array contains name of scanner events.
#
# source://prism//lib/prism/translation/ripper.rb#286
Prism::Translation::Ripper::SCANNER_EVENTS = T.let(T.unsafe(nil), Array)

# This contains a table of all of the scanner events and their
# corresponding arity.
#
# source://prism//lib/prism/translation/ripper.rb#227
Prism::Translation::Ripper::SCANNER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

# This class mirrors the ::Ripper::SexpBuilder subclass of ::Ripper that
# returns the arrays of [type, *children].
#
# source://prism//lib/prism/translation/ripper/sexp.rb#10
class Prism::Translation::Ripper::SexpBuilder < ::Prism::Translation::Ripper
  # :stopdoc:
  #
  # source://prism//lib/prism/translation/ripper/sexp.rb#13
  def error; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_BEGIN(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_CHAR(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_END(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on___end__(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_alias(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_alias_error(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_aref(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_aref_field(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_arg_ambiguous(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_arg_paren(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_args_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_args_add_block(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_args_add_star(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_args_forward(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_args_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_array(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_aryptn(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_assign(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_assign_error(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_assoc_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_assoc_splat(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_assoclist_from_args(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_backref(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_backtick(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_bare_assoc_hash(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_begin(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_binary(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_block_var(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_blockarg(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_bodystmt(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_brace_block(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_break(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_call(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_case(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_class(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_class_name_error(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_comma(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_command(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_command_call(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_comment(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_const(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_const_path_field(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_const_path_ref(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_const_ref(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_cvar(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_def(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_defined(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_defs(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_do_block(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_dot2(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_dot3(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_dyna_symbol(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_else(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_elsif(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embdoc(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embdoc_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embdoc_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embexpr_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embexpr_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_embvar(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_ensure(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_excessed_comma(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_fcall(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_field(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_float(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_fndptn(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_for(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_gvar(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_hash(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_heredoc_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_heredoc_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_hshptn(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_ident(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_if(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_if_mod(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_ifop(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_ignored_nl(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_ignored_sp(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_imaginary(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_in(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_int(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_ivar(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_kw(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_kwrest_param(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_label(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_label_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_lambda(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_lbrace(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_lbracket(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_lparen(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_magic_comment(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_massign(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_method_add_arg(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_method_add_block(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mlhs_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mlhs_add_post(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mlhs_add_star(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mlhs_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mlhs_paren(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_module(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mrhs_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mrhs_add_star(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mrhs_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_mrhs_new_from_args(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_next(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_nl(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_nokw_param(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_op(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_opassign(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_operator_ambiguous(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_param_error(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_params(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_paren(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_period(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_program(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_qsymbols_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_qsymbols_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_qsymbols_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_qwords_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_qwords_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_qwords_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_rational(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_rbrace(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_rbracket(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_redo(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_regexp_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_regexp_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_regexp_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_regexp_literal(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_regexp_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_rescue(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_rescue_mod(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_rest_param(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_retry(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_return(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_return0(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_rparen(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_sclass(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_semicolon(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_sp(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_stmts_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_stmts_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_concat(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_content(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_dvar(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_embexpr(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_string_literal(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_super(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_symbeg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_symbol(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_symbol_literal(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_symbols_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_symbols_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_symbols_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_tlambda(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_tlambeg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_top_const_field(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_top_const_ref(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_tstring_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_tstring_content(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_tstring_end(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_unary(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_undef(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_unless(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_unless_mod(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_until(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_until_mod(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_var_alias(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_var_field(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_var_ref(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_vcall(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_void_stmt(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_when(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_while(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_while_mod(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_word_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_word_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_words_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_words_beg(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_words_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#55
  def on_words_sep(tok); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_xstring_add(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_xstring_literal(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_xstring_new(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_yield(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_yield0(*args); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#47
  def on_zsuper(*args); end

  private

  # source://prism//lib/prism/translation/ripper/sexp.rb#61
  def compile_error(mesg); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#17
  def dedent_element(e, width); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#61
  def on_error(mesg); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#24
  def on_heredoc_dedent(val, width); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#61
  def on_parse_error(mesg); end
end

# This class mirrors the ::Ripper::SexpBuilderPP subclass of ::Ripper that
# returns the same values as ::Ripper::SexpBuilder except with a couple of
# niceties that flatten linked lists into arrays.
#
# source://prism//lib/prism/translation/ripper/sexp.rb#74
class Prism::Translation::Ripper::SexpBuilderPP < ::Prism::Translation::Ripper::SexpBuilder
  private

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def _dispatch_event_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def _dispatch_event_push(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_args_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_args_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#79
  def on_heredoc_dedent(val, width); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_mlhs_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#109
  def on_mlhs_add_post(list, post); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#105
  def on_mlhs_add_star(list, star); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_mlhs_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#101
  def on_mlhs_paren(list); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_mrhs_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_mrhs_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_qsymbols_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_qsymbols_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_qwords_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_qwords_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_regexp_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_regexp_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_stmts_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_stmts_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_string_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_symbols_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_symbols_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_word_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_word_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_words_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_words_new; end

  # source://prism//lib/prism/translation/ripper/sexp.rb#96
  def on_xstring_add(list, item); end

  # source://prism//lib/prism/translation/ripper/sexp.rb#92
  def on_xstring_new; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# source://prism//lib/prism/node.rb#17731
class Prism::TrueNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # source://prism//lib/prism/node.rb#17733
  def initialize(source, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17740
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17745
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17755
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17750
  def compact_child_nodes; end

  # def copy: (?location: Location) -> TrueNode
  #
  # source://prism//lib/prism/node.rb#17760
  def copy(location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17745
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism//lib/prism/node.rb#17768
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17774
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17793
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17803
    def type; end
  end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#17812
class Prism::UndefNode < ::Prism::Node
  # def initialize: (Array[SymbolNode | InterpolatedSymbolNode] names, Location keyword_loc, Location location) -> void
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # source://prism//lib/prism/node.rb#17814
  def initialize(source, names, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17823
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17828
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17838
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17833
  def compact_child_nodes; end

  # def copy: (?names: Array[SymbolNode | InterpolatedSymbolNode], ?keyword_loc: Location, ?location: Location) -> UndefNode
  #
  # source://prism//lib/prism/node.rb#17843
  def copy(names: T.unsafe(nil), keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17828
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { names: Array[SymbolNode | InterpolatedSymbolNode], keyword_loc: Location, location: Location }
  #
  # source://prism//lib/prism/node.rb#17851
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#17872
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#17867
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#17859
  def keyword_loc; end

  # attr_reader names: Array[SymbolNode | InterpolatedSymbolNode]
  #
  # source://prism//lib/prism/node.rb#17856
  def names; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#17893
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#17903
    def type; end
  end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#17915
class Prism::UnlessNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode? consequent, Location? end_keyword_loc, Location location) -> void
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # source://prism//lib/prism/node.rb#17917
  def initialize(source, keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#17930
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17939
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#17953
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#17944
  def compact_child_nodes; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism//lib/prism/node.rb#17997
  def consequent; end

  # def copy: (?keyword_loc: Location, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?consequent: ElseNode?, ?end_keyword_loc: Location?, ?location: Location) -> UnlessNode
  #
  # source://prism//lib/prism/node.rb#17958
  def copy(keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), consequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#17939
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#17966
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#18024
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18000
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18029
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#18014
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#17971
  def keyword_loc; end

  # attr_reader predicate: Prism::node
  #
  # source://prism//lib/prism/node.rb#17978
  def predicate; end

  # source://prism//lib/prism/node.rb#17934
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#17994
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#18019
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#17981
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18065
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18075
    def type; end
  end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#18087
class Prism::UntilNode < ::Prism::Node
  # def initialize: (Integer flags, Location keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements, Location location) -> void
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # source://prism//lib/prism/node.rb#18089
  def initialize(source, flags, keyword_loc, closing_loc, predicate, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#18101
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#18172
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18110
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#18182
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18152
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#18123
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#18115
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?keyword_loc: Location, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?, ?location: Location) -> UntilNode
  #
  # source://prism//lib/prism/node.rb#18128
  def copy(flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18110
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, keyword_loc: Location, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#18136
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18187
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#18177
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#18145
  def keyword_loc; end

  # attr_reader predicate: Prism::node
  #
  # source://prism//lib/prism/node.rb#18165
  def predicate; end

  # source://prism//lib/prism/node.rb#18105
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#18168
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18218
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#18141
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18228
    def type; end
  end
end

# The version constant is set by reading the result of calling pm_version.
Prism::VERSION = T.let(T.unsafe(nil), String)

# A visitor is a class that provides a default implementation for every accept
# method defined on the nodes. This means it can walk a tree without the
# caller needing to define any special handling. This allows you to handle a
# subset of the tree, while still walking the whole tree.
#
# For example, to find all of the method calls that call the `foo` method, you
# could write:
#
#     class FooCalls < Prism::Visitor
#       def visit_call_node(node)
#         if node.name == "foo"
#           # Do something with the node
#         end
#
#         # Call super so that the visitor continues walking the tree
#         super
#       end
#     end
#
# source://prism//lib/prism/visitor.rb#54
class Prism::Visitor < ::Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_case_match_node(node); end

  # Visit a CaseNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_implicit_rest_node(node); end

  # Visit a InNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_interpolated_x_string_node(node); end

  # Visit a ItParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_it_parameters_node(node); end

  # Visit a KeywordHashNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_self_node(node); end

  # Visit a ShareableConstantNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_shareable_constant_node(node); end

  # Visit a SingletonClassNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_statements_node(node); end

  # Visit a StringNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # source://prism//lib/prism/visitor.rb#29
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
#
# source://prism//lib/prism/node.rb#18239
class Prism::WhenNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Array[Prism::node] conditions, Location? then_keyword_loc, StatementsNode? statements, Location location) -> void
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # source://prism//lib/prism/node.rb#18241
  def initialize(source, keyword_loc, conditions, then_keyword_loc, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#18252
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18257
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#18270
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#18262
  def compact_child_nodes; end

  # attr_reader conditions: Array[Prism::node]
  #
  # source://prism//lib/prism/node.rb#18295
  def conditions; end

  # def copy: (?keyword_loc: Location, ?conditions: Array[Prism::node], ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?location: Location) -> WhenNode
  #
  # source://prism//lib/prism/node.rb#18275
  def copy(keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18257
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, conditions: Array[Prism::node], then_keyword_loc: Location?, statements: StatementsNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#18283
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18325
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#18315
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#18288
  def keyword_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#18311
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism//lib/prism/node.rb#18320
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18298
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18353
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18363
    def type; end
  end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism//lib/prism/node.rb#18375
class Prism::WhileNode < ::Prism::Node
  # def initialize: (Integer flags, Location keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements, Location location) -> void
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # source://prism//lib/prism/node.rb#18377
  def initialize(source, flags, keyword_loc, closing_loc, predicate, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#18389
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#18460
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18398
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism//lib/prism/node.rb#18470
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18440
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#18411
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#18403
  def compact_child_nodes; end

  # def copy: (?flags: Integer, ?keyword_loc: Location, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?, ?location: Location) -> WhileNode
  #
  # source://prism//lib/prism/node.rb#18416
  def copy(flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18398
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, keyword_loc: Location, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode?, location: Location }
  #
  # source://prism//lib/prism/node.rb#18424
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18475
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#18465
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#18433
  def keyword_loc; end

  # attr_reader predicate: Prism::node
  #
  # source://prism//lib/prism/node.rb#18453
  def predicate; end

  # source://prism//lib/prism/node.rb#18393
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism//lib/prism/node.rb#18456
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18506
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#18429
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18516
    def type; end
  end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# source://prism//lib/prism/node.rb#18525
class Prism::XStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # source://prism//lib/prism/node.rb#18527
  def initialize(source, flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#18539
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18544
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism//lib/prism/node.rb#18621
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism//lib/prism/node.rb#18590
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#18554
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#18549
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism//lib/prism/node.rb#18616
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism//lib/prism/node.rb#18583
  def content_loc; end

  # def copy: (?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String, ?location: Location) -> XStringNode
  #
  # source://prism//lib/prism/node.rb#18559
  def copy(flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18544
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism//lib/prism/node.rb#18567
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#18606
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism//lib/prism/node.rb#18601
  def forced_utf8_encoding?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18626
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism//lib/prism/node.rb#18611
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism//lib/prism/node.rb#18576
  def opening_loc; end

  # Occasionally it's helpful to treat a string as if it were interpolated so
  # that there's a consistent interface for working with strings.
  #
  # source://prism//lib/prism/node_ext.rb#72
  def to_interpolated; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18651
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism//lib/prism/node.rb#18597
  def unescaped; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism//lib/prism/node.rb#18572
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18661
    def type; end
  end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# source://prism//lib/prism/node.rb#18670
class Prism::YieldNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, Location location) -> void
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # source://prism//lib/prism/node.rb#18672
  def initialize(source, keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism//lib/prism/node.rb#18683
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism//lib/prism/node.rb#18738
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18688
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism//lib/prism/node.rb#18700
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism//lib/prism/node.rb#18693
  def compact_child_nodes; end

  # def copy: (?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?location: Location) -> YieldNode
  #
  # source://prism//lib/prism/node.rb#18705
  def copy(keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), location: T.unsafe(nil)); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism//lib/prism/node.rb#18688
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location }
  #
  # source://prism//lib/prism/node.rb#18713
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism//lib/prism/node.rb#18770
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism//lib/prism/node.rb#18755
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism//lib/prism/node.rb#18718
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#18760
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18725
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism//lib/prism/node.rb#18765
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism//lib/prism/node.rb#18741
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism//lib/prism/node.rb#18798
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism//lib/prism/node.rb#18808
    def type; end
  end
end
