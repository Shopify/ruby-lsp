# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `spoom` gem.
# Please instead update this file by running `bin/tapioca gem spoom`.


# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `spoom` gem.
# Please instead update this file by running `spoom srb sigs export`.

# source://spoom//lib/spoom.rb#7
module Spoom
  class << self
    # : (String ruby, file: String) -> Prism::Node
    #
    # source://spoom//lib/spoom/parse.rb#11
    sig { params(ruby: ::String, file: ::String).returns(::Prism::Node) }
    def parse_ruby(ruby, file:); end

    # : (String ruby, file: String) -> [Prism::Node, Array[Prism::Comment]]
    #
    # source://spoom//lib/spoom/parse.rb#27
    sig { params(ruby: ::String, file: ::String).returns([::Prism::Node, T::Array[::Prism::Comment]]) }
    def parse_ruby_with_comments(ruby, file:); end
  end
end

# source://spoom//lib/spoom/backtrace_filter/minitest.rb#7
module Spoom::BacktraceFilter; end

# source://spoom//lib/spoom/backtrace_filter/minitest.rb#8
class Spoom::BacktraceFilter::Minitest < ::Minitest::BacktraceFilter
  # : (Array[String]? bt) -> Array[String]
  #
  # source://spoom//lib/spoom/backtrace_filter/minitest.rb#13
  def filter(bt); end
end

# source://spoom//lib/spoom/backtrace_filter/minitest.rb#9
Spoom::BacktraceFilter::Minitest::SORBET_PATHS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/cli/helper.rb#9
module Spoom::Cli; end

# source://spoom//lib/spoom/cli/deadcode.rb#8
class Spoom::Cli::Deadcode < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # : (*String paths) -> void
  #
  # source://spoom//lib/spoom/cli/deadcode.rb#51
  sig { params(paths: ::String).void }
  def deadcode(*paths); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/deadcode.rb#153
  def remove(location_string); end
end

# source://spoom//lib/spoom/cli/helper.rb#10
module Spoom::Cli::Helper
  include ::Spoom::Colorize

  requires_ancestor { Thor }

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#147
  sig { params(string: ::String).returns(::String) }
  def blue(string); end

  # Collect files from `paths`, defaulting to `exec_path`
  # : (Array[String] paths) -> Array[String]
  #
  # source://spoom//lib/spoom/cli/helper.rb#85
  # Collect files from `paths`, defaulting to `exec_path`
  sig { params(paths: T::Array[::String]).returns(T::Array[::String]) }
  def collect_files(paths); end

  # Is the `--color` option true?
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/cli/helper.rb#111
  # Is the `--color` option true?
  sig { returns(T::Boolean) }
  def color?; end

  # Colorize a string if `color?`
  # : (String string, *Color color) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#140
  # Colorize a string if `color?`
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def colorize(string, *color); end

  # Returns the context at `--path` (by default the current working directory)
  # : -> Context
  #
  # source://spoom//lib/spoom/cli/helper.rb#58
  # Returns the context at `--path` (by default the current working directory)
  sig { returns(::Spoom::Context) }
  def context; end

  # Raise if `spoom` is not ran inside a context with a `sorbet/config` file
  # : -> Context
  #
  # source://spoom//lib/spoom/cli/helper.rb#64
  # Raise if `spoom` is not ran inside a context with a `sorbet/config` file
  sig { returns(::Spoom::Context) }
  def context_requiring_sorbet!; end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#152
  sig { params(string: ::String).returns(::String) }
  def cyan(string); end

  # Return the path specified through `--path`
  # : -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#79
  # Return the path specified through `--path`
  sig { returns(::String) }
  def exec_path; end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#157
  sig { params(string: ::String).returns(::String) }
  def gray(string); end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#162
  sig { params(string: ::String).returns(::String) }
  def green(string); end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#116
  sig { params(string: ::String).returns(::String) }
  def highlight(string); end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#167
  sig { params(string: ::String).returns(::String) }
  def red(string); end

  # Print `message` on `$stdout`
  # : (String message) -> void
  #
  # source://spoom//lib/spoom/cli/helper.rb#19
  # Print `message` on `$stdout`
  sig { params(message: ::String).void }
  def say(message); end

  # Print `message` on `$stderr`
  #
  # The message is prefixed by a status (default: `Error`).
  # : (String message, ?status: String?, ?nl: bool) -> void
  #
  # source://spoom//lib/spoom/cli/helper.rb#32
  # Print `message` on `$stderr`
  # The message is prefixed by a status (default: `Error`).
  sig { params(message: ::String, status: T.nilable(::String), nl: T::Boolean).void }
  def say_error(message, status: T.unsafe(nil), nl: T.unsafe(nil)); end

  # Print `message` on `$stderr`
  #
  # The message is prefixed by a status (default: `Warning`).
  # : (String message, ?status: String?, ?nl: bool) -> void
  #
  # source://spoom//lib/spoom/cli/helper.rb#46
  # Print `message` on `$stderr`
  # The message is prefixed by a status (default: `Warning`).
  sig { params(message: ::String, status: T.nilable(::String), nl: T::Boolean).void }
  def say_warning(message, status: T.unsafe(nil), nl: T.unsafe(nil)); end

  # : (String string) -> String
  #
  # source://spoom//lib/spoom/cli/helper.rb#172
  sig { params(string: ::String).returns(::String) }
  def yellow(string); end
end

# source://spoom//lib/spoom/cli.rb#12
class Spoom::Cli::Main < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom//lib/spoom/cli.rb#100
  def __print_version; end

  # : (?String directory) -> void
  #
  # source://spoom//lib/spoom/cli.rb#57
  sig { params(directory: ::String).void }
  def bump(directory = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli.rb#64
  def coverage(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def deadcode(*args); end

  # source://spoom//lib/spoom/cli.rb#74
  def lsp(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def srb(*args); end

  # source://spoom//lib/spoom/cli.rb#93
  def tc(*paths_to_select); end

  class << self
    # @return [Boolean]
    #
    # source://spoom//lib/spoom/cli.rb#107
    def exit_on_failure?; end
  end
end

# source://spoom//lib/spoom/cli.rb#80
Spoom::Cli::Main::SORT_CODE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/cli.rb#82
Spoom::Cli::Main::SORT_ENUM = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/cli.rb#81
Spoom::Cli::Main::SORT_LOC = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/cli/srb/assertions.rb#6
module Spoom::Cli::Srb; end

# source://spoom//lib/spoom/cli/srb/assertions.rb#7
class Spoom::Cli::Srb::Assertions < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/assertions.rb#29
  def transform_files(files, &block); end

  # source://spoom//lib/spoom/cli/srb/assertions.rb#13
  def translate(*paths); end
end

# source://spoom//lib/spoom/cli/srb/bump.rb#10
class Spoom::Cli::Srb::Bump < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # : (?String directory) -> void
  #
  # source://spoom//lib/spoom/cli/srb/bump.rb#49
  sig { params(directory: ::String).void }
  def bump(directory = T.unsafe(nil)); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/bump.rb#170
  def print_changes(files, command:, from: T.unsafe(nil), to: T.unsafe(nil), dry: T.unsafe(nil), path: T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/bump.rb#192
  def undo_changes(files, from_strictness); end
end

# source://spoom//lib/spoom/cli/srb/coverage.rb#10
class Spoom::Cli::Srb::Coverage < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom//lib/spoom/cli/srb/coverage.rb#199
  def bundle_install(path, sha); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#211
  def message_no_data(file); end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#174
  def open(file = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#190
  def parse_time(string, option); end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#143
  def report; end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#21
  def snapshot; end

  # source://spoom//lib/spoom/cli/srb/coverage.rb#43
  def timeline; end
end

# source://spoom//lib/spoom/cli/srb/coverage.rb#13
Spoom::Cli::Srb::Coverage::DATA_DIR = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/cli/srb/lsp.rb#11
class Spoom::Cli::Srb::LSP < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#45
  def defs(file, line, col); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#55
  def find(query); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#31
  def hover(file, line, col); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#16
  def list; end

  # source://spoom//lib/spoom/cli/srb/lsp.rb#104
  def lsp_client; end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#75
  def refs(file, line, col); end

  # source://spoom//lib/spoom/cli/srb/lsp.rb#127
  def run(&block); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#85
  def sigs(file, line, col); end

  # source://spoom//lib/spoom/cli/srb/lsp.rb#119
  def symbol_printer; end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#65
  def symbols(file); end

  # source://spoom//lib/spoom/cli/srb/lsp.rb#152
  def to_uri(path); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom//lib/spoom/cli/srb/lsp.rb#95
  def types(file, line, col); end
end

# source://spoom//lib/spoom/cli/srb.rb#14
class Spoom::Cli::Srb::Main < ::Thor
  # source://thor/1.3.2/lib/thor.rb#334
  def assertions(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def bump(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def coverage(*args); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://thor/1.3.2/lib/thor.rb#334
  def lsp(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def sigs(*args); end

  # source://thor/1.3.2/lib/thor.rb#334
  def tc(*args); end
end

# source://spoom//lib/spoom/cli/srb/sigs.rb#9
class Spoom::Cli::Srb::Sigs < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom//lib/spoom/cli/srb/sigs.rb#197
  def exec(context, command); end

  # source://spoom//lib/spoom/cli/srb/sigs.rb#68
  def export(output_path = T.unsafe(nil)); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/sigs.rb#49
  def strip(*paths); end

  # source://spoom//lib/spoom/cli/srb/sigs.rb#174
  def transform_files(files, &block); end

  # source://spoom//lib/spoom/cli/srb/sigs.rb#20
  def translate(*paths); end
end

# source://spoom//lib/spoom/cli/srb/tc.rb#7
class Spoom::Cli::Srb::Tc < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom//lib/spoom/cli/srb/tc.rb#132
  def colorize_message(message); end

  # source://spoom//lib/spoom/cli/srb/tc.rb#123
  def format_error(error, format); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom//lib/spoom/cli/srb/tc.rb#27
  def tc(*paths_to_select); end
end

# source://spoom//lib/spoom/cli/srb/tc.rb#16
Spoom::Cli::Srb::Tc::DEFAULT_FORMAT = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/cli/srb/tc.rb#12
Spoom::Cli::Srb::Tc::SORT_CODE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/cli/srb/tc.rb#14
Spoom::Cli::Srb::Tc::SORT_ENUM = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/cli/srb/tc.rb#13
Spoom::Cli::Srb::Tc::SORT_LOC = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/colors.rb#5
class Spoom::Color < ::T::Enum
  enums do
    BLACK = new
    BLUE = new
    BOLD = new
    CLEAR = new
    CYAN = new
    GREEN = new
    LIGHT_BLACK = new
    LIGHT_BLUE = new
    LIGHT_CYAN = new
    LIGHT_GREEN = new
    LIGHT_MAGENTA = new
    LIGHT_RED = new
    LIGHT_WHITE = new
    LIGHT_YELLOW = new
    MAGENTA = new
    RED = new
    WHITE = new
    YELLOW = new
  end

  # : -> String
  #
  # source://spoom//lib/spoom/colors.rb#30
  sig { returns(::String) }
  def ansi_code; end
end

# source://spoom//lib/spoom/colors.rb#35
module Spoom::Colorize
  # : (String string, *Color color) -> String
  #
  # source://spoom//lib/spoom/colors.rb#37
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def set_color(string, *color); end
end

# An abstraction to a Ruby project context
#
# A context maps to a directory in the file system.
# It is used to manipulate files and run commands in the context of this directory.
#
# source://spoom//lib/spoom/context/bundle.rb#5
# An abstraction to a Ruby project context
# A context maps to a directory in the file system.
class Spoom::Context
  include ::Spoom::Context::Bundle
  include ::Spoom::Context::Exec
  include ::Spoom::Context::FileSystem
  include ::Spoom::Context::Git
  include ::Spoom::Context::Sorbet

  # Create a new context about `absolute_path`
  #
  # The directory will not be created if it doesn't exist.
  # Call `#make!` to create it.
  # : (String absolute_path) -> void
  #
  # @return [Context] a new instance of Context
  #
  # source://spoom//lib/spoom/context.rb#47
  # Create a new context about `absolute_path`
  # The directory will not be created if it doesn't exist.
  # Call `#make!` to create it.
  sig { params(absolute_path: ::String).void }
  def initialize(absolute_path); end

  # The absolute path to the directory this context is about
  # : String
  #
  # source://spoom//lib/spoom/context.rb#40
  # The absolute path to the directory this context is about
  sig { returns(::String) }
  def absolute_path; end

  class << self
    # Create a new context in the system's temporary directory
    #
    # `name` is used as prefix to the temporary directory name.
    # The directory will be created if it doesn't exist.
    # : (?String? name) -> instance
    #
    # source://spoom//lib/spoom/context.rb#33
    # Create a new context in the system's temporary directory
    # `name` is used as prefix to the temporary directory name.
    # The directory will be created if it doesn't exist.
    sig { params(name: T.nilable(::String)).returns(T.attached_class) }
    def mktmp!(name = T.unsafe(nil)); end
  end
end

# Bundle features for a context
#
# source://spoom//lib/spoom/context/bundle.rb#7
module Spoom::Context::Bundle
  requires_ancestor { Spoom::Context }

  # Run a command with `bundle` in this context directory
  # : (String command, ?version: String?, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/bundle.rb#32
  # Run a command with `bundle` in this context directory
  sig { params(command: ::String, version: T.nilable(::String), capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def bundle(command, version: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # Run a command `bundle exec` in this context directory
  # : (String command, ?version: String?, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/bundle.rb#45
  # Run a command `bundle exec` in this context directory
  sig { params(command: ::String, version: T.nilable(::String), capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def bundle_exec(command, version: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # Run `bundle install` in this context directory
  # : (?version: String?, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/bundle.rb#39
  # Run `bundle install` in this context directory
  sig { params(version: T.nilable(::String), capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def bundle_install!(version: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # Get `gem` version from the `Gemfile.lock` content
  #
  # Returns `nil` if `gem` cannot be found in the Gemfile.
  # : (String gem) -> Gem::Version?
  #
  # source://spoom//lib/spoom/context/bundle.rb#61
  # Get `gem` version from the `Gemfile.lock` content
  # Returns `nil` if `gem` cannot be found in the Gemfile.
  sig { params(gem: ::String).returns(T.nilable(::Gem::Version)) }
  def gem_version_from_gemfile_lock(gem); end

  # : -> Hash[String, Bundler::LazySpecification]
  #
  # source://spoom//lib/spoom/context/bundle.rb#50
  sig { returns(T::Hash[::String, ::Bundler::LazySpecification]) }
  def gemfile_lock_specs; end

  # Read the contents of the Gemfile in this context directory
  # : -> String?
  #
  # source://spoom//lib/spoom/context/bundle.rb#14
  # Read the contents of the Gemfile in this context directory
  sig { returns(T.nilable(::String)) }
  def read_gemfile; end

  # Read the contents of the Gemfile.lock in this context directory
  # : -> String?
  #
  # source://spoom//lib/spoom/context/bundle.rb#20
  # Read the contents of the Gemfile.lock in this context directory
  sig { returns(T.nilable(::String)) }
  def read_gemfile_lock; end

  # Set the `contents` of the Gemfile in this context directory
  # : (String contents, ?append: bool) -> void
  #
  # source://spoom//lib/spoom/context/bundle.rb#26
  # Set the `contents` of the Gemfile in this context directory
  sig { params(contents: ::String, append: T::Boolean).void }
  def write_gemfile!(contents, append: T.unsafe(nil)); end
end

# Execution features for a context
#
# source://spoom//lib/spoom/context/exec.rb#25
module Spoom::Context::Exec
  requires_ancestor { Spoom::Context }

  # Run a command in this context directory
  # : (String command, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/exec.rb#32
  # Run a command in this context directory
  sig { params(command: ::String, capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def exec(command, capture_err: T.unsafe(nil)); end
end

# File System features for a context
#
# source://spoom//lib/spoom/context/file_system.rb#7
module Spoom::Context::FileSystem
  requires_ancestor { Spoom::Context }

  # Returns the absolute path to `relative_path` in the context's directory
  # : (String relative_path) -> String
  #
  # source://spoom//lib/spoom/context/file_system.rb#14
  # Returns the absolute path to `relative_path` in the context's directory
  sig { params(relative_path: ::String).returns(::String) }
  def absolute_path_to(relative_path); end

  # : (?allow_extensions: Array[String], ?allow_mime_types: Array[String], ?exclude_patterns: Array[String]) -> Array[String]
  #
  # source://spoom//lib/spoom/context/file_system.rb#46
  sig do
    params(
      allow_extensions: T::Array[::String],
      allow_mime_types: T::Array[::String],
      exclude_patterns: T::Array[::String]
    ).returns(T::Array[::String])
  end
  def collect_files(allow_extensions: T.unsafe(nil), allow_mime_types: T.unsafe(nil), exclude_patterns: T.unsafe(nil)); end

  # Delete this context and its content
  #
  # Warning: it will `rm -rf` the context directory on the file system.
  # : -> void
  #
  # source://spoom//lib/spoom/context/file_system.rb#98
  # Delete this context and its content
  # Warning: it will `rm -rf` the context directory on the file system.
  sig { void }
  def destroy!; end

  # Does the context directory at `absolute_path` exist and is a directory?
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/context/file_system.rb#20
  # Does the context directory at `absolute_path` exist and is a directory?
  sig { returns(T::Boolean) }
  def exist?; end

  # Does `relative_path` point to an existing file in this context directory?
  # : (String relative_path) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/context/file_system.rb#58
  # Does `relative_path` point to an existing file in this context directory?
  sig { params(relative_path: ::String).returns(T::Boolean) }
  def file?(relative_path); end

  # List all files in this context matching `pattern`
  # : (?String pattern) -> Array[String]
  #
  # source://spoom//lib/spoom/context/file_system.rb#33
  # List all files in this context matching `pattern`
  sig { params(pattern: ::String).returns(T::Array[::String]) }
  def glob(pattern = T.unsafe(nil)); end

  # List all files at the top level of this context directory
  # : -> Array[String]
  #
  # source://spoom//lib/spoom/context/file_system.rb#41
  # List all files at the top level of this context directory
  sig { returns(T::Array[::String]) }
  def list; end

  # Create the context directory at `absolute_path`
  # : -> void
  #
  # source://spoom//lib/spoom/context/file_system.rb#26
  # Create the context directory at `absolute_path`
  sig { void }
  def mkdir!; end

  # Move the file or directory from `from_relative_path` to `to_relative_path`
  # : (String from_relative_path, String to_relative_path) -> void
  #
  # source://spoom//lib/spoom/context/file_system.rb#88
  # Move the file or directory from `from_relative_path` to `to_relative_path`
  sig { params(from_relative_path: ::String, to_relative_path: ::String).void }
  def move!(from_relative_path, to_relative_path); end

  # Return the contents of the file at `relative_path` in this context directory
  #
  # Will raise if the file doesn't exist.
  # : (String relative_path) -> String
  #
  # source://spoom//lib/spoom/context/file_system.rb#66
  # Return the contents of the file at `relative_path` in this context directory
  # Will raise if the file doesn't exist.
  sig { params(relative_path: ::String).returns(::String) }
  def read(relative_path); end

  # Remove the path at `relative_path` (recursive + force) in this context directory
  # : (String relative_path) -> void
  #
  # source://spoom//lib/spoom/context/file_system.rb#82
  # Remove the path at `relative_path` (recursive + force) in this context directory
  sig { params(relative_path: ::String).void }
  def remove!(relative_path); end

  # Write `contents` in the file at `relative_path` in this context directory
  #
  # Append to the file if `append` is true.
  # : (String relative_path, ?String contents, ?append: bool) -> void
  #
  # source://spoom//lib/spoom/context/file_system.rb#74
  # Write `contents` in the file at `relative_path` in this context directory
  # Append to the file if `append` is true.
  sig { params(relative_path: ::String, contents: ::String, append: T::Boolean).void }
  def write!(relative_path, contents = T.unsafe(nil), append: T.unsafe(nil)); end
end

# Git features for a context
#
# source://spoom//lib/spoom/context/git.rb#31
module Spoom::Context::Git
  requires_ancestor { Spoom::Context }

  # Run a command prefixed by `git` in this context directory
  # : (String command) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#38
  # Run a command prefixed by `git` in this context directory
  sig { params(command: ::String).returns(::Spoom::ExecResult) }
  def git(command); end

  # Run `git checkout` in this context directory
  # : (?ref: String) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#57
  # Run `git checkout` in this context directory
  sig { params(ref: ::String).returns(::Spoom::ExecResult) }
  def git_checkout!(ref: T.unsafe(nil)); end

  # Run `git checkout -b <branch-name> <ref>` in this context directory
  # : (String branch_name, ?ref: String?) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#63
  # Run `git checkout -b <branch-name> <ref>` in this context directory
  sig { params(branch_name: ::String, ref: T.nilable(::String)).returns(::Spoom::ExecResult) }
  def git_checkout_new_branch!(branch_name, ref: T.unsafe(nil)); end

  # Run `git add . && git commit` in this context directory
  # : (?message: String, ?time: Time, ?allow_empty: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#73
  # Run `git add . && git commit` in this context directory
  sig { params(message: ::String, time: ::Time, allow_empty: T::Boolean).returns(::Spoom::ExecResult) }
  def git_commit!(message: T.unsafe(nil), time: T.unsafe(nil), allow_empty: T.unsafe(nil)); end

  # Get the current git branch in this context directory
  # : -> String?
  #
  # source://spoom//lib/spoom/context/git.rb#84
  # Get the current git branch in this context directory
  sig { returns(T.nilable(::String)) }
  def git_current_branch; end

  # Run `git diff` in this context directory
  # : (*String arg) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#93
  # Run `git diff` in this context directory
  sig { params(arg: ::String).returns(::Spoom::ExecResult) }
  def git_diff(*arg); end

  # Run `git init` in this context directory
  #
  # Warning: passing a branch will run `git init -b <branch>` which is only available in git 2.28+.
  # In older versions, use `git_init!` followed by `git("checkout -b <branch>")`.
  # : (?branch: String?) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#47
  # Run `git init` in this context directory
  # Warning: passing a branch will run `git init -b <branch>` which is only available in git 2.28+.
  # In older versions, use `git_init!` followed by `git("checkout -b <branch>")`.
  sig { params(branch: T.nilable(::String)).returns(::Spoom::ExecResult) }
  def git_init!(branch: T.unsafe(nil)); end

  # Get the last commit in the currently checked out branch
  # : (?short_sha: bool) -> Spoom::Git::Commit?
  #
  # source://spoom//lib/spoom/context/git.rb#99
  # Get the last commit in the currently checked out branch
  sig { params(short_sha: T::Boolean).returns(T.nilable(::Spoom::Git::Commit)) }
  def git_last_commit(short_sha: T.unsafe(nil)); end

  # : (*String arg) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#110
  sig { params(arg: ::String).returns(::Spoom::ExecResult) }
  def git_log(*arg); end

  # Run `git push <remote> <ref>` in this context directory
  # : (String remote, String ref, ?force: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#116
  # Run `git push <remote> <ref>` in this context directory
  sig { params(remote: ::String, ref: ::String, force: T::Boolean).returns(::Spoom::ExecResult) }
  def git_push!(remote, ref, force: T.unsafe(nil)); end

  # : (*String arg) -> ExecResult
  #
  # source://spoom//lib/spoom/context/git.rb#121
  sig { params(arg: ::String).returns(::Spoom::ExecResult) }
  def git_show(*arg); end

  # Is there uncommitted changes in this context directory?
  # : (?path: String) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/context/git.rb#127
  # Is there uncommitted changes in this context directory?
  sig { params(path: ::String).returns(T::Boolean) }
  def git_workdir_clean?(path: T.unsafe(nil)); end
end

# Sorbet features for a context
#
# source://spoom//lib/spoom/context/sorbet.rb#7
module Spoom::Context::Sorbet
  requires_ancestor { Spoom::Context }

  # Does this context has a `sorbet/config` file?
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/context/sorbet.rb#106
  # Does this context has a `sorbet/config` file?
  sig { returns(T::Boolean) }
  def has_sorbet_config?; end

  # Read the strictness sigil from the file at `relative_path` (returns `nil` if no sigil)
  # : (String relative_path) -> String?
  #
  # source://spoom//lib/spoom/context/sorbet.rb#129
  # Read the strictness sigil from the file at `relative_path` (returns `nil` if no sigil)
  sig { params(relative_path: ::String).returns(T.nilable(::String)) }
  def read_file_strictness(relative_path); end

  # Read the contents of `sorbet/config` in this context directory
  # : -> String
  #
  # source://spoom//lib/spoom/context/sorbet.rb#117
  # Read the contents of `sorbet/config` in this context directory
  sig { returns(::String) }
  def read_sorbet_config; end

  # : -> Spoom::Sorbet::Config
  #
  # source://spoom//lib/spoom/context/sorbet.rb#111
  sig { returns(::Spoom::Sorbet::Config) }
  def sorbet_config; end

  # Get the commit introducing the `sorbet/config` file
  # : -> Spoom::Git::Commit?
  #
  # source://spoom//lib/spoom/context/sorbet.rb#135
  # Get the commit introducing the `sorbet/config` file
  sig { returns(T.nilable(::Spoom::Git::Commit)) }
  def sorbet_intro_commit; end

  # Get the commit removing the `sorbet/config` file
  # : -> Spoom::Git::Commit?
  #
  # source://spoom//lib/spoom/context/sorbet.rb#147
  # Get the commit removing the `sorbet/config` file
  sig { returns(T.nilable(::Spoom::Git::Commit)) }
  def sorbet_removal_commit; end

  # Run `bundle exec srb` in this context directory
  # : (*String arg, ?sorbet_bin: String?, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/sorbet.rb#14
  # Run `bundle exec srb` in this context directory
  sig { params(arg: ::String, sorbet_bin: T.nilable(::String), capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def srb(*arg, sorbet_bin: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # List all files typechecked by Sorbet from its `config`
  # : (?with_config: Spoom::Sorbet::Config?, ?include_rbis: bool) -> Array[String]
  #
  # source://spoom//lib/spoom/context/sorbet.rb#58
  # List all files typechecked by Sorbet from its `config`
  sig { params(with_config: T.nilable(::Spoom::Sorbet::Config), include_rbis: T::Boolean).returns(T::Array[::String]) }
  def srb_files(with_config: T.unsafe(nil), include_rbis: T.unsafe(nil)); end

  # List all files typechecked by Sorbet from its `config` that matches `strictness`
  # : (String strictness, ?with_config: Spoom::Sorbet::Config?, ?include_rbis: bool) -> Array[String]
  #
  # source://spoom//lib/spoom/context/sorbet.rb#91
  # List all files typechecked by Sorbet from its `config` that matches `strictness`
  sig do
    params(
      strictness: ::String,
      with_config: T.nilable(::Spoom::Sorbet::Config),
      include_rbis: T::Boolean
    ).returns(T::Array[::String])
  end
  def srb_files_with_strictness(strictness, with_config: T.unsafe(nil), include_rbis: T.unsafe(nil)); end

  # : (*String arg, ?sorbet_bin: String?, ?capture_err: bool) -> Hash[String, Integer]?
  #
  # source://spoom//lib/spoom/context/sorbet.rb#38
  sig do
    params(
      arg: ::String,
      sorbet_bin: T.nilable(::String),
      capture_err: T::Boolean
    ).returns(T.nilable(T::Hash[::String, ::Integer]))
  end
  def srb_metrics(*arg, sorbet_bin: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # : (*String arg, ?sorbet_bin: String?, ?capture_err: bool) -> ExecResult
  #
  # source://spoom//lib/spoom/context/sorbet.rb#32
  sig { params(arg: ::String, sorbet_bin: T.nilable(::String), capture_err: T::Boolean).returns(::Spoom::ExecResult) }
  def srb_tc(*arg, sorbet_bin: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # : (*String arg, ?sorbet_bin: String?, ?capture_err: bool) -> String?
  #
  # source://spoom//lib/spoom/context/sorbet.rb#97
  sig { params(arg: ::String, sorbet_bin: T.nilable(::String), capture_err: T::Boolean).returns(T.nilable(::String)) }
  def srb_version(*arg, sorbet_bin: T.unsafe(nil), capture_err: T.unsafe(nil)); end

  # Set the `contents` of `sorbet/config` in this context directory
  # : (String contents, ?append: bool) -> void
  #
  # source://spoom//lib/spoom/context/sorbet.rb#123
  # Set the `contents` of `sorbet/config` in this context directory
  sig { params(contents: ::String, append: T::Boolean).void }
  def write_sorbet_config!(contents, append: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/snapshot.rb#5
module Spoom::Coverage
  class << self
    # : (Context context) -> FileTree
    #
    # source://spoom//lib/spoom/coverage.rb#101
    sig { params(context: ::Spoom::Context).returns(::Spoom::FileTree) }
    def file_tree(context); end

    # : (Context context, Array[Snapshot] snapshots, palette: D3::ColorPalette) -> Report
    #
    # source://spoom//lib/spoom/coverage.rb#81
    sig do
      params(
        context: ::Spoom::Context,
        snapshots: T::Array[::Spoom::Coverage::Snapshot],
        palette: ::Spoom::Coverage::D3::ColorPalette
      ).returns(::Spoom::Coverage::Report)
    end
    def report(context, snapshots, palette:); end

    # : (Context context, ?rbi: bool, ?sorbet_bin: String?) -> Snapshot
    #
    # source://spoom//lib/spoom/coverage.rb#14
    sig do
      params(
        context: ::Spoom::Context,
        rbi: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(::Spoom::Coverage::Snapshot)
    end
    def snapshot(context, rbi: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end
  end
end

# source://spoom//lib/spoom/coverage/report.rb#87
module Spoom::Coverage::Cards; end

# source://spoom//lib/spoom/coverage/report.rb#88
class Spoom::Coverage::Cards::Card < ::Spoom::Coverage::Template
  # : (?template: String, ?title: String?, ?body: String?) -> void
  #
  # @return [Card] a new instance of Card
  #
  # source://spoom//lib/spoom/coverage/report.rb#97
  sig { params(template: ::String, title: T.nilable(::String), body: T.nilable(::String)).void }
  def initialize(template: T.unsafe(nil), title: T.unsafe(nil), body: T.unsafe(nil)); end

  # : String?
  #
  # source://spoom//lib/spoom/coverage/report.rb#94
  # @return [String, nil]
  def body; end

  # : String?
  #
  # source://spoom//lib/spoom/coverage/report.rb#94
  sig { returns(T.nilable(::String)) }
  def title; end
end

# source://spoom//lib/spoom/coverage/report.rb#91
Spoom::Coverage::Cards::Card::TEMPLATE = T.let(T.unsafe(nil), String)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/report.rb#104
class Spoom::Coverage::Cards::Erb < ::Spoom::Coverage::Cards::Card
  abstract!

  # : -> void
  #
  # @return [Erb] a new instance of Erb
  #
  # source://spoom//lib/spoom/coverage/report.rb#110
  sig { void }
  def initialize; end

  # @abstract
  #
  # source://spoom//lib/spoom/coverage/report.rb#119
  sig { abstract.returns(::String) }
  def erb; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#114
  sig { override.returns(::String) }
  def html; end
end

# source://spoom//lib/spoom/coverage/report.rb#150
class Spoom::Coverage::Cards::Map < ::Spoom::Coverage::Cards::Card
  # : (file_tree: FileTree, nodes_strictnesses: Hash[FileTree::Node, String?], nodes_strictness_scores: Hash[FileTree::Node, Float], ?title: String) -> void
  #
  # @return [Map] a new instance of Map
  #
  # source://spoom//lib/spoom/coverage/report.rb#152
  sig do
    params(
      file_tree: ::Spoom::FileTree,
      nodes_strictnesses: T::Hash[::Spoom::FileTree::Node, T.nilable(::String)],
      nodes_strictness_scores: T::Hash[::Spoom::FileTree::Node, ::Float],
      title: ::String
    ).void
  end
  def initialize(file_tree:, nodes_strictnesses:, nodes_strictness_scores:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#122
class Spoom::Coverage::Cards::Snapshot < ::Spoom::Coverage::Cards::Card
  # : (snapshot: Coverage::Snapshot, ?title: String) -> void
  #
  # @return [Snapshot] a new instance of Snapshot
  #
  # source://spoom//lib/spoom/coverage/report.rb#129
  sig { params(snapshot: ::Spoom::Coverage::Snapshot, title: ::String).void }
  def initialize(snapshot:, title: T.unsafe(nil)); end

  # : -> D3::Pie::Calls
  #
  # source://spoom//lib/spoom/coverage/report.rb#140
  sig { returns(::Spoom::Coverage::D3::Pie::Calls) }
  def pie_calls; end

  # : -> D3::Pie::Sigils
  #
  # source://spoom//lib/spoom/coverage/report.rb#135
  sig { returns(::Spoom::Coverage::D3::Pie::Sigils) }
  def pie_sigils; end

  # : -> D3::Pie::Sigs
  #
  # source://spoom//lib/spoom/coverage/report.rb#145
  sig { returns(::Spoom::Coverage::D3::Pie::Sigs) }
  def pie_sigs; end

  # : Coverage::Snapshot
  #
  # source://spoom//lib/spoom/coverage/report.rb#126
  sig { returns(::Spoom::Coverage::Snapshot) }
  def snapshot; end
end

# source://spoom//lib/spoom/coverage/report.rb#123
Spoom::Coverage::Cards::Snapshot::TEMPLATE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/report.rb#214
class Spoom::Coverage::Cards::SorbetIntro < ::Spoom::Coverage::Cards::Erb
  # : (?sorbet_intro_commit: String?, ?sorbet_intro_date: Time?) -> void
  #
  # @return [SorbetIntro] a new instance of SorbetIntro
  #
  # source://spoom//lib/spoom/coverage/report.rb#216
  sig { params(sorbet_intro_commit: T.nilable(::String), sorbet_intro_date: T.nilable(::Time)).void }
  def initialize(sorbet_intro_commit: T.unsafe(nil), sorbet_intro_date: T.unsafe(nil)); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#223
  sig { override.returns(::String) }
  def erb; end
end

# source://spoom//lib/spoom/coverage/report.rb#165
class Spoom::Coverage::Cards::Timeline < ::Spoom::Coverage::Cards::Card
  # : (title: String, timeline: D3::Timeline) -> void
  #
  # @return [Timeline] a new instance of Timeline
  #
  # source://spoom//lib/spoom/coverage/report.rb#167
  sig { params(title: ::String, timeline: ::Spoom::Coverage::D3::Timeline).void }
  def initialize(title:, timeline:); end
end

# source://spoom//lib/spoom/coverage/report.rb#178
class Spoom::Coverage::Cards::Timeline::Calls < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [Calls] a new instance of Calls
  #
  # source://spoom//lib/spoom/coverage/report.rb#180
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#192
class Spoom::Coverage::Cards::Timeline::RBIs < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [RBIs] a new instance of RBIs
  #
  # source://spoom//lib/spoom/coverage/report.rb#194
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#206
class Spoom::Coverage::Cards::Timeline::Runtimes < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [Runtimes] a new instance of Runtimes
  #
  # source://spoom//lib/spoom/coverage/report.rb#208
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#171
class Spoom::Coverage::Cards::Timeline::Sigils < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [Sigils] a new instance of Sigils
  #
  # source://spoom//lib/spoom/coverage/report.rb#173
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#185
class Spoom::Coverage::Cards::Timeline::Sigs < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [Sigs] a new instance of Sigs
  #
  # source://spoom//lib/spoom/coverage/report.rb#187
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/report.rb#199
class Spoom::Coverage::Cards::Timeline::Versions < ::Spoom::Coverage::Cards::Timeline
  # : (snapshots: Array[Coverage::Snapshot], ?title: String) -> void
  #
  # @return [Versions] a new instance of Versions
  #
  # source://spoom//lib/spoom/coverage/report.rb#201
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom//lib/spoom/coverage/d3/base.rb#6
module Spoom::Coverage::D3
  class << self
    # : (ColorPalette palette) -> String
    #
    # source://spoom//lib/spoom/coverage/d3.rb#59
    sig { params(palette: ::Spoom::Coverage::D3::ColorPalette).returns(::String) }
    def header_script(palette); end

    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3.rb#19
    sig { returns(::String) }
    def header_style; end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/d3/base.rb#7
class Spoom::Coverage::D3::Base
  abstract!

  # : (String id, untyped data) -> void
  #
  # @return [Base] a new instance of Base
  #
  # source://spoom//lib/spoom/coverage/d3/base.rb#17
  sig { params(id: ::String, data: T.untyped).void }
  def initialize(id, data); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/base.rb#35
  sig { returns(::String) }
  def html; end

  # : String
  #
  # source://spoom//lib/spoom/coverage/d3/base.rb#14
  sig { returns(::String) }
  def id; end

  # @abstract
  #
  # source://spoom//lib/spoom/coverage/d3/base.rb#48
  sig { abstract.returns(::String) }
  def script; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/base.rb#43
  sig { returns(::String) }
  def tooltip; end

  class << self
    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/base.rb#29
    sig { returns(::String) }
    def header_script; end

    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/base.rb#24
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom//lib/spoom/coverage/d3.rb#12
Spoom::Coverage::D3::COLOR_FALSE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/d3.rb#11
Spoom::Coverage::D3::COLOR_IGNORE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/d3.rb#14
Spoom::Coverage::D3::COLOR_STRICT = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/d3.rb#15
Spoom::Coverage::D3::COLOR_STRONG = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/d3.rb#13
Spoom::Coverage::D3::COLOR_TRUE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/d3/circle_map.rb#9
class Spoom::Coverage::D3::CircleMap < ::Spoom::Coverage::D3::Base
  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/circle_map.rb#58
  sig { override.returns(::String) }
  def script; end

  class << self
    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/circle_map.rb#38
    sig { returns(::String) }
    def header_script; end

    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/circle_map.rb#12
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom//lib/spoom/coverage/d3/circle_map.rb#147
class Spoom::Coverage::D3::CircleMap::Sigils < ::Spoom::Coverage::D3::CircleMap
  # : (String id, FileTree file_tree, Hash[FileTree::Node, String?] nodes_strictnesses, Hash[FileTree::Node, Float] nodes_scores) -> void
  #
  # @return [Sigils] a new instance of Sigils
  #
  # source://spoom//lib/spoom/coverage/d3/circle_map.rb#149
  sig do
    params(
      id: ::String,
      file_tree: ::Spoom::FileTree,
      nodes_strictnesses: T::Hash[::Spoom::FileTree::Node, T.nilable(::String)],
      nodes_scores: T::Hash[::Spoom::FileTree::Node, ::Float]
    ).void
  end
  def initialize(id, file_tree, nodes_strictnesses, nodes_scores); end

  # : (FileTree::Node node) -> Hash[Symbol, untyped]
  #
  # source://spoom//lib/spoom/coverage/d3/circle_map.rb#156
  sig { params(node: ::Spoom::FileTree::Node).returns(T::Hash[::Symbol, T.untyped]) }
  def tree_node_to_json(node); end
end

# source://spoom//lib/spoom/coverage/d3.rb#101
class Spoom::Coverage::D3::ColorPalette < ::T::Struct
  prop :ignore, ::String
  prop :false, ::String
  prop :true, ::String
  prop :strict, ::String
  prop :strong, ::String

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/d3/pie.rb#9
class Spoom::Coverage::D3::Pie < ::Spoom::Coverage::D3::Base
  abstract!

  # : (String id, String title, untyped data) -> void
  #
  # @return [Pie] a new instance of Pie
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#15
  sig { params(id: ::String, title: ::String, data: T.untyped).void }
  def initialize(id, title, data); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#54
  sig { override.returns(::String) }
  def script; end

  class << self
    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/pie.rb#40
    sig { returns(::String) }
    def header_script; end

    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/pie.rb#22
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom//lib/spoom/coverage/d3/pie.rb#138
class Spoom::Coverage::D3::Pie::Calls < ::Spoom::Coverage::D3::Pie
  # : (String id, String title, Snapshot snapshot) -> void
  #
  # @return [Calls] a new instance of Calls
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#140
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#146
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/pie.rb#121
class Spoom::Coverage::D3::Pie::Sigils < ::Spoom::Coverage::D3::Pie
  # : (String id, String title, Snapshot snapshot) -> void
  #
  # @return [Sigils] a new instance of Sigils
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#123
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#129
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/pie.rb#155
class Spoom::Coverage::D3::Pie::Sigs < ::Spoom::Coverage::D3::Pie
  # : (String id, String title, Snapshot snapshot) -> void
  #
  # @return [Sigs] a new instance of Sigs
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#157
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/pie.rb#167
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/d3/timeline.rb#9
class Spoom::Coverage::D3::Timeline < ::Spoom::Coverage::D3::Base
  abstract!

  # : (String id, untyped data, Array[String] keys) -> void
  #
  # @return [Timeline] a new instance of Timeline
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#15
  sig { params(id: ::String, data: T.untyped, keys: T::Array[::String]).void }
  def initialize(id, data, keys); end

  # : (y: String, ?color: String, ?curve: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#185
  sig { params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def area(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # : (y: String, ?color: String, ?curve: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#201
  sig { params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # @abstract
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#124
  sig { abstract.returns(::String) }
  def plot; end

  # : (y: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#215
  sig { params(y: ::String).returns(::String) }
  def points(y:); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#99
  sig { override.returns(::String) }
  def script; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#127
  sig { returns(::String) }
  def x_scale; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#143
  sig { returns(::String) }
  def x_ticks; end

  # : (min: String, max: String, ticks: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#156
  sig { params(min: ::String, max: ::String, ticks: ::String).returns(::String) }
  def y_scale(min:, max:, ticks:); end

  # : (ticks: String, format: String, padding: Integer) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#172
  sig { params(ticks: ::String, format: ::String, padding: ::Integer).returns(::String) }
  def y_ticks(ticks:, format:, padding:); end

  class << self
    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/timeline.rb#76
    sig { returns(::String) }
    def header_script; end

    # : -> String
    #
    # source://spoom//lib/spoom/coverage/d3/timeline.rb#22
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#447
class Spoom::Coverage::D3::Timeline::Calls < ::Spoom::Coverage::D3::Timeline::Stacked
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [Calls] a new instance of Calls
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#449
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#464
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#502
class Spoom::Coverage::D3::Timeline::RBIs < ::Spoom::Coverage::D3::Timeline::Stacked
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [RBIs] a new instance of RBIs
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#504
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : (y: String, ?color: String, ?curve: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#575
  sig { override.params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#616
  sig { override.returns(::String) }
  def plot; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#534
  sig { override.returns(::String) }
  def script; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#519
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#280
class Spoom::Coverage::D3::Timeline::Runtimes < ::Spoom::Coverage::D3::Timeline
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [Runtimes] a new instance of Runtimes
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#282
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#309
  sig { override.returns(::String) }
  def plot; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#295
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#421
class Spoom::Coverage::D3::Timeline::Sigils < ::Spoom::Coverage::D3::Timeline::Stacked
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [Sigils] a new instance of Sigils
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#423
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#438
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#473
class Spoom::Coverage::D3::Timeline::Sigs < ::Spoom::Coverage::D3::Timeline::Stacked
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [Sigs] a new instance of Sigs
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#475
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#493
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/d3/timeline.rb#327
class Spoom::Coverage::D3::Timeline::Stacked < ::Spoom::Coverage::D3::Timeline
  abstract!

  # : (y: String, ?color: String, ?curve: String) -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#388
  sig { override.params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#376
  sig { override.returns(::String) }
  def plot; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#334
  sig { override.returns(::String) }
  def script; end
end

# source://spoom//lib/spoom/coverage/d3/timeline.rb#230
class Spoom::Coverage::D3::Timeline::Versions < ::Spoom::Coverage::D3::Timeline
  # : (String id, Array[Snapshot] snapshots) -> void
  #
  # @return [Versions] a new instance of Versions
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#232
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#261
  sig { override.returns(::String) }
  def plot; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/d3/timeline.rb#246
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/report.rb#37
class Spoom::Coverage::Page < ::Spoom::Coverage::Template
  abstract!

  # : (title: String, palette: D3::ColorPalette, ?template: String) -> void
  #
  # @return [Page] a new instance of Page
  #
  # source://spoom//lib/spoom/coverage/report.rb#52
  sig { params(title: ::String, palette: ::Spoom::Coverage::D3::ColorPalette, template: ::String).void }
  def initialize(title:, palette:, template: T.unsafe(nil)); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#74
  sig { returns(::String) }
  def body_html; end

  # @abstract
  #
  # source://spoom//lib/spoom/coverage/report.rb#79
  sig { abstract.returns(T::Array[::Spoom::Coverage::Cards::Card]) }
  def cards; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#82
  sig { returns(::String) }
  def footer_html; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#69
  sig { returns(::String) }
  def header_html; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#64
  sig { returns(::String) }
  def header_script; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#59
  sig { returns(::String) }
  def header_style; end

  # : D3::ColorPalette
  #
  # source://spoom//lib/spoom/coverage/report.rb#49
  sig { returns(::Spoom::Coverage::D3::ColorPalette) }
  def palette; end

  # : String
  #
  # source://spoom//lib/spoom/coverage/report.rb#46
  sig { returns(::String) }
  def title; end
end

# source://spoom//lib/spoom/coverage/report.rb#43
Spoom::Coverage::Page::TEMPLATE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/coverage/report.rb#234
class Spoom::Coverage::Report < ::Spoom::Coverage::Page
  # : (project_name: String, palette: D3::ColorPalette, snapshots: Array[Snapshot], file_tree: FileTree, nodes_strictnesses: Hash[FileTree::Node, String?], nodes_strictness_scores: Hash[FileTree::Node, Float], ?sorbet_intro_commit: String?, ?sorbet_intro_date: Time?) -> void
  #
  # @return [Report] a new instance of Report
  #
  # source://spoom//lib/spoom/coverage/report.rb#236
  sig do
    params(
      project_name: ::String,
      palette: ::Spoom::Coverage::D3::ColorPalette,
      snapshots: T::Array[::Spoom::Coverage::Snapshot],
      file_tree: ::Spoom::FileTree,
      nodes_strictnesses: T::Hash[::Spoom::FileTree::Node, T.nilable(::String)],
      nodes_strictness_scores: T::Hash[::Spoom::FileTree::Node, ::Float],
      sorbet_intro_commit: T.nilable(::String),
      sorbet_intro_date: T.nilable(::Time)
    ).void
  end
  def initialize(project_name:, palette:, snapshots:, file_tree:, nodes_strictnesses:, nodes_strictness_scores:, sorbet_intro_commit: T.unsafe(nil), sorbet_intro_date: T.unsafe(nil)); end

  # : -> Array[Cards::Card]
  #
  # source://spoom//lib/spoom/coverage/report.rb#270
  sig { override.returns(T::Array[::Spoom::Coverage::Cards::Card]) }
  def cards; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#258
  sig { override.returns(::String) }
  def header_html; end
end

# source://spoom//lib/spoom/coverage/snapshot.rb#6
class Spoom::Coverage::Snapshot < ::T::Struct
  prop :timestamp, ::Integer, default: T.unsafe(nil)
  prop :version_static, T.nilable(::String), default: T.unsafe(nil)
  prop :version_runtime, T.nilable(::String), default: T.unsafe(nil)
  prop :duration, ::Integer, default: T.unsafe(nil)
  prop :commit_sha, T.nilable(::String), default: T.unsafe(nil)
  prop :commit_timestamp, T.nilable(::Integer), default: T.unsafe(nil)
  prop :files, ::Integer, default: T.unsafe(nil)
  prop :rbi_files, ::Integer, default: T.unsafe(nil)
  prop :modules, ::Integer, default: T.unsafe(nil)
  prop :classes, ::Integer, default: T.unsafe(nil)
  prop :singleton_classes, ::Integer, default: T.unsafe(nil)
  prop :methods_without_sig, ::Integer, default: T.unsafe(nil)
  prop :methods_with_sig, ::Integer, default: T.unsafe(nil)
  prop :calls_untyped, ::Integer, default: T.unsafe(nil)
  prop :calls_typed, ::Integer, default: T.unsafe(nil)
  prop :sigils, T::Hash[::String, ::Integer], default: T.unsafe(nil)
  prop :methods_with_sig_excluding_rbis, ::Integer, default: T.unsafe(nil)
  prop :methods_without_sig_excluding_rbis, ::Integer, default: T.unsafe(nil)
  prop :sigils_excluding_rbis, T::Hash[::String, ::Integer], default: T.unsafe(nil)

  # : (?out: (IO | StringIO), ?colors: bool, ?indent_level: Integer) -> void
  #
  # source://spoom//lib/spoom/coverage/snapshot.rb#31
  sig { params(out: T.any(::IO, ::StringIO), colors: T::Boolean, indent_level: ::Integer).void }
  def print(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # : (*untyped arg) -> String
  #
  # source://spoom//lib/spoom/coverage/snapshot.rb#37
  sig { params(arg: T.untyped).returns(::String) }
  def to_json(*arg); end

  class << self
    # : (String json) -> Snapshot
    #
    # source://spoom//lib/spoom/coverage/snapshot.rb#43
    sig { params(json: ::String).returns(::Spoom::Coverage::Snapshot) }
    def from_json(json); end

    # : (Hash[String, untyped] obj) -> Snapshot
    #
    # source://spoom//lib/spoom/coverage/snapshot.rb#48
    sig { params(obj: T::Hash[::String, T.untyped]).returns(::Spoom::Coverage::Snapshot) }
    def from_obj(obj); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# The strictness name as found in the Sorbet metrics file
#
# source://spoom//lib/spoom/coverage/snapshot.rb#28
Spoom::Coverage::Snapshot::STRICTNESSES = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/coverage/snapshot.rb#91
class Spoom::Coverage::SnapshotPrinter < ::Spoom::Printer
  # : (Snapshot snapshot) -> void
  #
  # source://spoom//lib/spoom/coverage/snapshot.rb#93
  sig { params(snapshot: ::Spoom::Coverage::Snapshot).void }
  def print_snapshot(snapshot); end

  private

  # : (Integer? value, Integer? total) -> String
  #
  # source://spoom//lib/spoom/coverage/snapshot.rb#152
  sig { params(value: T.nilable(::Integer), total: T.nilable(::Integer)).returns(::String) }
  def percent(value, total); end

  # : (Hash[String, Integer] hash, Integer total) -> void
  #
  # source://spoom//lib/spoom/coverage/snapshot.rb#141
  sig { params(hash: T::Hash[::String, ::Integer], total: ::Integer).void }
  def print_map(hash, total); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/coverage/report.rb#10
class Spoom::Coverage::Template
  abstract!

  # Create a new template from an Erb file path
  # : (template: String) -> void
  #
  # @return [Template] a new instance of Template
  #
  # source://spoom//lib/spoom/coverage/report.rb#17
  # Create a new template from an Erb file path
  sig { params(template: ::String).void }
  def initialize(template:); end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#22
  sig { returns(::String) }
  def erb; end

  # : -> Binding
  #
  # source://spoom//lib/spoom/coverage/report.rb#32
  sig { returns(::Binding) }
  def get_binding; end

  # : -> String
  #
  # source://spoom//lib/spoom/coverage/report.rb#27
  sig { returns(::String) }
  def html; end
end

# source://spoom//lib/spoom/deadcode/erb.rb#27
module Spoom::Deadcode
  class << self
    # : (Context context) -> Array[singleton(Plugins::Base)]
    #
    # source://spoom//lib/spoom/deadcode/plugins.rb#73
    sig { params(context: ::Spoom::Context).returns(T::Array[T.class_of(Spoom::Deadcode::Plugins::Base)]) }
    def load_custom_plugins(context); end

    # : (Context context) -> Set[singleton(Plugins::Base)]
    #
    # source://spoom//lib/spoom/deadcode/plugins.rb#59
    sig { params(context: ::Spoom::Context).returns(T::Set[T.class_of(Spoom::Deadcode::Plugins::Base)]) }
    def plugins_from_gemfile_lock(context); end
  end
end

# source://spoom//lib/spoom/deadcode/plugins.rb#26
Spoom::Deadcode::DEFAULT_CUSTOM_PLUGINS_PATH = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/deadcode/plugins.rb#28
Spoom::Deadcode::DEFAULT_PLUGINS = T.let(T.unsafe(nil), Set)

# A definition is a class, module, method, constant, etc. being defined in the code
#
# source://spoom//lib/spoom/deadcode/definition.rb#7
class Spoom::Deadcode::Definition < ::T::Struct
  const :kind, ::Spoom::Deadcode::Definition::Kind
  const :name, ::String
  const :full_name, ::String
  const :location, ::Spoom::Location
  const :status, ::Spoom::Deadcode::Definition::Status, default: T.unsafe(nil)

  # : -> void
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#76
  sig { void }
  def alive!; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#71
  # Status
  sig { returns(T::Boolean) }
  def alive?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#39
  # Kind
  sig { returns(T::Boolean) }
  def attr_reader?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#44
  sig { returns(T::Boolean) }
  def attr_writer?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#49
  sig { returns(T::Boolean) }
  def class?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#54
  sig { returns(T::Boolean) }
  def constant?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#81
  sig { returns(T::Boolean) }
  def dead?; end

  # : -> void
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#91
  sig { void }
  def ignored!; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#86
  sig { returns(T::Boolean) }
  def ignored?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#59
  sig { returns(T::Boolean) }
  def method?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#64
  sig { returns(T::Boolean) }
  def module?; end

  # : (*untyped args) -> String
  #
  # source://spoom//lib/spoom/deadcode/definition.rb#98
  # Utils
  sig { params(args: T.untyped).returns(::String) }
  def to_json(*args); end

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/deadcode/definition.rb#8
class Spoom::Deadcode::Definition::Kind < ::T::Enum
  enums do
    AttrReader = new
    AttrWriter = new
    Class = new
    Constant = new
    Method = new
    Module = new
  end
end

# source://spoom//lib/spoom/deadcode/definition.rb#19
class Spoom::Deadcode::Definition::Status < ::T::Enum
  enums do
    ALIVE = new
    DEAD = new
    IGNORED = new
  end
end

# Custom engine to handle ERB templates as used by Rails
#
# source://spoom//lib/spoom/deadcode/erb.rb#29
class Spoom::Deadcode::ERB < ::Erubi::Engine
  # : (untyped input, ?untyped properties) -> void
  #
  # @return [ERB] a new instance of ERB
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#31
  sig { params(input: T.untyped, properties: T.untyped).void }
  def initialize(input, properties = T.unsafe(nil)); end

  private

  # : (untyped code) -> void
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#84
  sig { override.params(code: T.untyped).void }
  def add_code(code); end

  # : (untyped indicator, untyped code) -> void
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#66
  sig { override.params(indicator: T.untyped, code: T.untyped).void }
  def add_expression(indicator, code); end

  # : (untyped _) -> void
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#91
  sig { override.params(_: T.untyped).void }
  def add_postamble(_); end

  # : (untyped text) -> void
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#47
  sig { override.params(text: T.untyped).void }
  def add_text(text); end

  # : (untyped src) -> void
  #
  # source://spoom//lib/spoom/deadcode/erb.rb#97
  sig { params(src: T.untyped).void }
  def flush_newline_if_pending(src); end
end

# source://spoom//lib/spoom/deadcode/erb.rb#62
Spoom::Deadcode::ERB::BLOCK_EXPR = T.let(T.unsafe(nil), Regexp)

# source://spoom//lib/spoom/deadcode/index.rb#6
class Spoom::Deadcode::Index
  # : (Model model) -> void
  #
  # @return [Index] a new instance of Index
  #
  # source://spoom//lib/spoom/deadcode/index.rb#25
  sig { params(model: ::Spoom::Model).void }
  def initialize(model); end

  # : -> Array[Definition]
  #
  # source://spoom//lib/spoom/deadcode/index.rb#215
  sig { returns(T::Array[::Spoom::Deadcode::Definition]) }
  def all_definitions; end

  # : -> Array[Model::Reference]
  #
  # source://spoom//lib/spoom/deadcode/index.rb#220
  sig { returns(T::Array[::Spoom::Model::Reference]) }
  def all_references; end

  # : (Array[Plugins::Base] plugins) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#95
  sig { params(plugins: T::Array[::Spoom::Deadcode::Plugins::Base]).void }
  def apply_plugins!(plugins); end

  # : (Definition definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#75
  sig { params(definition: ::Spoom::Deadcode::Definition).void }
  def define(definition); end

  # : Hash[String, Array[Definition]]
  #
  # source://spoom//lib/spoom/deadcode/index.rb#19
  sig { returns(T::Hash[::String, T::Array[::Spoom::Deadcode::Definition]]) }
  def definitions; end

  # : (String name) -> Array[Definition]
  #
  # source://spoom//lib/spoom/deadcode/index.rb#210
  # Utils
  sig { params(name: ::String).returns(T::Array[::Spoom::Deadcode::Definition]) }
  def definitions_for_name(name); end

  # Mark all definitions having a reference of the same name as `alive`
  #
  # To be called once all the files have been indexed and all the definitions and references discovered.
  # : -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#118
  # Mark all definitions having a reference of the same name as `alive`
  # To be called once all the files have been indexed and all the definitions and references discovered.
  sig { void }
  def finalize!; end

  # : (Model::SymbolDef symbol_def) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#90
  sig { params(symbol_def: ::Spoom::Model::SymbolDef).void }
  def ignore(symbol_def); end

  # : (String erb, file: String, ?plugins: Array[Plugins::Base]) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#46
  sig { params(erb: ::String, file: ::String, plugins: T::Array[::Spoom::Deadcode::Plugins::Base]).void }
  def index_erb(erb, file:, plugins: T.unsafe(nil)); end

  # : (String file, ?plugins: Array[Plugins::Base]) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#35
  # Indexing
  sig { params(file: ::String, plugins: T::Array[::Spoom::Deadcode::Plugins::Base]).void }
  def index_file(file, plugins: T.unsafe(nil)); end

  # : (String rb, file: String, ?plugins: Array[Plugins::Base]) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#51
  sig { params(rb: ::String, file: ::String, plugins: T::Array[::Spoom::Deadcode::Plugins::Base]).void }
  def index_ruby(rb, file:, plugins: T.unsafe(nil)); end

  # : Model
  #
  # source://spoom//lib/spoom/deadcode/index.rb#16
  sig { returns(::Spoom::Model) }
  def model; end

  # : (String name, Location location) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#80
  sig { params(name: ::String, location: ::Spoom::Location).void }
  def reference_constant(name, location); end

  # : (String name, Location location) -> void
  #
  # source://spoom//lib/spoom/deadcode/index.rb#85
  sig { params(name: ::String, location: ::Spoom::Location).void }
  def reference_method(name, location); end

  # : Hash[String, Array[Model::Reference]]
  #
  # source://spoom//lib/spoom/deadcode/index.rb#22
  sig { returns(T::Hash[::String, T::Array[::Spoom::Model::Reference]]) }
  def references; end
end

# source://spoom//lib/spoom/deadcode/index.rb#7
class Spoom::Deadcode::Index::Error < ::Spoom::Error
  # : (String message, parent: Exception) -> void
  #
  # @return [Error] a new instance of Error
  #
  # source://spoom//lib/spoom/deadcode/index.rb#9
  sig { params(message: ::String, parent: ::Exception).void }
  def initialize(message, parent:); end
end

# source://spoom//lib/spoom/deadcode/indexer.rb#6
class Spoom::Deadcode::Indexer < ::Spoom::Visitor
  # : (String path, Index index, ?plugins: Array[Plugins::Base]) -> void
  #
  # @return [Indexer] a new instance of Indexer
  #
  # source://spoom//lib/spoom/deadcode/indexer.rb#14
  sig do
    params(
      path: ::String,
      index: ::Spoom::Deadcode::Index,
      plugins: T::Array[::Spoom::Deadcode::Plugins::Base]
    ).void
  end
  def initialize(path, index, plugins: T.unsafe(nil)); end

  # : Index
  #
  # source://spoom//lib/spoom/deadcode/indexer.rb#11
  sig { returns(::Spoom::Deadcode::Index) }
  def index; end

  # : String
  #
  # source://spoom//lib/spoom/deadcode/indexer.rb#8
  sig { returns(::String) }
  def path; end

  # : (Prism::CallNode node) -> void
  #
  # source://spoom//lib/spoom/deadcode/indexer.rb#26
  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end
end

# source://spoom//lib/spoom/deadcode/plugins.rb#36
Spoom::Deadcode::PLUGINS_FOR_GEM = T.let(T.unsafe(nil), Hash)

# source://spoom//lib/spoom/deadcode/plugins/base.rb#8
module Spoom::Deadcode::Plugins; end

# source://spoom//lib/spoom/deadcode/plugins/action_mailer.rb#7
class Spoom::Deadcode::Plugins::ActionMailer < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/action_mailer.rb#10
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/action_mailer_preview.rb#7
class Spoom::Deadcode::Plugins::ActionMailerPreview < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/action_mailer_preview.rb#12
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end
end

# source://spoom//lib/spoom/deadcode/plugins/actionpack.rb#7
class Spoom::Deadcode::Plugins::ActionPack < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/actionpack.rb#30
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end

  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/actionpack.rb#39
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/actionpack.rb#10
Spoom::Deadcode::Plugins::ActionPack::CALLBACKS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/deadcode/plugins/active_job.rb#7
class Spoom::Deadcode::Plugins::ActiveJob < ::Spoom::Deadcode::Plugins::Base; end

# source://spoom//lib/spoom/deadcode/plugins/active_model.rb#7
class Spoom::Deadcode::Plugins::ActiveModel < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/active_model.rb#13
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/active_record.rb#7
class Spoom::Deadcode::Plugins::ActiveRecord < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/active_record.rb#73
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/active_record.rb#62
Spoom::Deadcode::Plugins::ActiveRecord::ARRAY_METHODS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/deadcode/plugins/active_record.rb#18
Spoom::Deadcode::Plugins::ActiveRecord::CALLBACKS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/deadcode/plugins/active_record.rb#47
Spoom::Deadcode::Plugins::ActiveRecord::CRUD_METHODS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/deadcode/plugins/active_support.rb#7
class Spoom::Deadcode::Plugins::ActiveSupport < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/active_support.rb#23
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/active_support.rb#19
Spoom::Deadcode::Plugins::ActiveSupport::SETUP_AND_TEARDOWN_METHODS = T.let(T.unsafe(nil), Array)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/deadcode/plugins/base.rb#9
class Spoom::Deadcode::Plugins::Base
  abstract!

  # : (Index index) -> void
  #
  # @return [Base] a new instance of Base
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#129
  sig { params(index: ::Spoom::Deadcode::Index).void }
  def initialize(index); end

  # : Index
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#126
  sig { returns(::Spoom::Deadcode::Index) }
  def index; end

  # Do not override this method, use `on_define_accessor` instead.
  # : (Model::Attr definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#155
  # Do not override this method, use `on_define_accessor` instead.
  sig { params(definition: ::Spoom::Model::Attr).void }
  def internal_on_define_accessor(definition); end

  # Do not override this method, use `on_define_class` instead.
  # : (Model::Class definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#179
  # Do not override this method, use `on_define_class` instead.
  sig { params(definition: ::Spoom::Model::Class).void }
  def internal_on_define_class(definition); end

  # Do not override this method, use `on_define_constant` instead.
  # : (Model::Constant definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#209
  # Do not override this method, use `on_define_constant` instead.
  sig { params(definition: ::Spoom::Model::Constant).void }
  def internal_on_define_constant(definition); end

  # Do not override this method, use `on_define_method` instead.
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#235
  # Do not override this method, use `on_define_method` instead.
  sig { params(definition: ::Spoom::Model::Method).void }
  def internal_on_define_method(definition); end

  # Do not override this method, use `on_define_module` instead.
  # : (Model::Module definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#261
  # Do not override this method, use `on_define_module` instead.
  sig { params(definition: ::Spoom::Model::Module).void }
  def internal_on_define_module(definition); end

  # Called when an accessor is defined.
  #
  # Will be called when the indexer processes a `attr_reader`, `attr_writer` or `attr_accessor` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_accessor(definition)
  #     @index.ignore(definition) if symbol_def.name == "foo"
  #   end
  # end
  # ~~~
  # : (Model::Attr definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#149
  # Called when an accessor is defined.
  # Will be called when the indexer processes a `attr_reader`, `attr_writer` or `attr_accessor` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_accessor(definition)
  #     @index.ignore(definition) if symbol_def.name == "foo"
  #   end
  # end
  # ~~~
  sig { params(definition: ::Spoom::Model::Attr).void }
  def on_define_accessor(definition); end

  # Called when a class is defined.
  #
  # Will be called when the indexer processes a `class` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_class(definition)
  #     @index.ignore(definition) if definition.name == "Foo"
  #   end
  # end
  # ~~~
  # : (Model::Class definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#173
  # Called when a class is defined.
  # Will be called when the indexer processes a `class` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_class(definition)
  #     @index.ignore(definition) if definition.name == "Foo"
  #   end
  # end
  # ~~~
  sig { params(definition: ::Spoom::Model::Class).void }
  def on_define_class(definition); end

  # Called when a constant is defined.
  #
  # Will be called when the indexer processes a `CONST =` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_constant(definition)
  #     @index.ignore(definition) if definition.name == "FOO"
  #   end
  # end
  # ~~~
  # : (Model::Constant definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#203
  # Called when a constant is defined.
  # Will be called when the indexer processes a `CONST =` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_constant(definition)
  #     @index.ignore(definition) if definition.name == "FOO"
  #   end
  # end
  # ~~~
  sig { params(definition: ::Spoom::Model::Constant).void }
  def on_define_constant(definition); end

  # Called when a method is defined.
  #
  # Will be called when the indexer processes a `def` or `defs` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_method(definition)
  #     @index.ignore(definition) if definition.name == "foo"
  #   end
  # end
  # ~~~
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#229
  # Called when a method is defined.
  # Will be called when the indexer processes a `def` or `defs` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_method(definition)
  #     @index.ignore(definition) if definition.name == "foo"
  #   end
  # end
  # ~~~
  sig { params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end

  # Called when a module is defined.
  #
  # Will be called when the indexer processes a `module` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_module(definition)
  #     @index.ignore(definition) if definition.name == "Foo"
  #   end
  # end
  # ~~~
  # : (Model::Module definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#255
  # Called when a module is defined.
  # Will be called when the indexer processes a `module` node.
  # Note that when this method is called, the definition for the node has already been added to the index.
  # It is still possible to ignore it from the plugin:
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_define_module(definition)
  #     @index.ignore(definition) if definition.name == "Foo"
  #   end
  # end
  # ~~~
  sig { params(definition: ::Spoom::Model::Module).void }
  def on_define_module(definition); end

  # Called when a send is being processed
  #
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_send(send)
  #     return unless send.name == "dsl_method"
  #     return if send.args.empty?
  #
  #     method_name = send.args.first.slice.delete_prefix(":")
  #     @index.reference_method(method_name, send.node, send.loc)
  #   end
  # end
  # ~~~
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#281
  # Called when a send is being processed
  # ~~~rb
  # class MyPlugin < Spoom::Deadcode::Plugins::Base
  #   def on_send(send)
  #     return unless send.name == "dsl_method"
  #     return if send.args.empty?
  #     method_name = send.args.first.slice.delete_prefix(":")
  #     @index.reference_method(method_name, send.node, send.loc)
  #   end
  # end
  # ~~~
  sig { params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end

  private

  # : (String name) -> String
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#349
  # Plugin utils
  sig { params(name: ::String).returns(::String) }
  def camelize(name); end

  # : (String? name) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#298
  sig { params(name: T.nilable(::String)).returns(T::Boolean) }
  def ignored_class_name?(name); end

  # : (String name) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#317
  sig { params(name: ::String).returns(T::Boolean) }
  def ignored_constant_name?(name); end

  # : (String name) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#322
  sig { params(name: ::String).returns(T::Boolean) }
  def ignored_method_name?(name); end

  # : (String name) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#327
  sig { params(name: ::String).returns(T::Boolean) }
  def ignored_module_name?(name); end

  # : (String name, Symbol names_variable, Symbol patterns_variable) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#332
  sig { params(name: ::String, names_variable: ::Symbol, patterns_variable: ::Symbol).returns(T::Boolean) }
  def ignored_name?(name, names_variable, patterns_variable); end

  # : (Model::Class definition) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#305
  sig { params(definition: ::Spoom::Model::Class).returns(T::Boolean) }
  def ignored_subclass?(definition); end

  # : (Symbol const) -> Set[String]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#337
  sig { params(const: ::Symbol).returns(T::Set[::String]) }
  def names(const); end

  # : (Symbol const) -> Array[Regexp]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#342
  sig { params(const: ::Symbol).returns(T::Array[::Regexp]) }
  def patterns(const); end

  # : (Model::Namespace definition, String superclass_name) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/base.rb#290
  # DSL support
  sig { params(definition: ::Spoom::Model::Namespace, superclass_name: ::String).returns(T::Boolean) }
  def subclass_of?(definition, superclass_name); end

  class << self
    # Mark classes directly subclassing a class matching `names` as ignored.
    #
    # Names can be either strings or regexps:
    #
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_classes_inheriting_from(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    # : (*(String | Regexp) names) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#49
    # Mark classes directly subclassing a class matching `names` as ignored.
    # Names can be either strings or regexps:
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_classes_inheriting_from(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    sig { params(names: T.any(::Regexp, ::String)).void }
    def ignore_classes_inheriting_from(*names); end

    # Mark classes matching `names` as ignored.
    #
    # Names can be either strings or regexps:
    #
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    # : (*(String | Regexp) names) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#31
    # Mark classes matching `names` as ignored.
    # Names can be either strings or regexps:
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    sig { params(names: T.any(::Regexp, ::String)).void }
    def ignore_classes_named(*names); end

    # Mark constants matching `names` as ignored.
    #
    # Names can be either strings or regexps:
    #
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "FOO",
    #     "BAR",
    #     /BAZ.*/,
    #   )
    # end
    # ~~~
    # : (*(String | Regexp) names) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#67
    # Mark constants matching `names` as ignored.
    # Names can be either strings or regexps:
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "FOO",
    #     "BAR",
    #     /BAZ.*/,
    #   )
    # end
    # ~~~
    sig { params(names: T.any(::Regexp, ::String)).void }
    def ignore_constants_named(*names); end

    # Mark methods matching `names` as ignored.
    #
    # Names can be either strings or regexps:
    #
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_method_names(
    #     "foo",
    #     "bar",
    #     /baz.*/,
    #   )
    # end
    # ~~~
    # : (*(String | Regexp) names) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#85
    # Mark methods matching `names` as ignored.
    # Names can be either strings or regexps:
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_method_names(
    #     "foo",
    #     "bar",
    #     /baz.*/,
    #   )
    # end
    # ~~~
    sig { params(names: T.any(::Regexp, ::String)).void }
    def ignore_methods_named(*names); end

    # Mark modules matching `names` as ignored.
    #
    # Names can be either strings or regexps:
    #
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    # : (*(String | Regexp) names) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#103
    # Mark modules matching `names` as ignored.
    # Names can be either strings or regexps:
    # ~~~rb
    # class MyPlugin < Spoom::Deadcode::Plugins::Base
    #   ignore_class_names(
    #     "Foo",
    #     "Bar",
    #     /Baz.*/,
    #   )
    # end
    # ~~~
    sig { params(names: T.any(::Regexp, ::String)).void }
    def ignore_modules_named(*names); end

    private

    # : (Array[(String | Regexp)] names, Symbol names_variable, Symbol patterns_variable) -> void
    #
    # source://spoom//lib/spoom/deadcode/plugins/base.rb#110
    sig do
      params(
        names: T::Array[T.any(::Regexp, ::String)],
        names_variable: ::Symbol,
        patterns_variable: ::Symbol
      ).void
    end
    def save_names_and_patterns(names, names_variable, patterns_variable); end
  end
end

# source://spoom//lib/spoom/deadcode/plugins/graphql.rb#7
class Spoom::Deadcode::Plugins::GraphQL < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/graphql.rb#27
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/minitest.rb#7
class Spoom::Deadcode::Plugins::Minitest < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/minitest.rb#21
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end

  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/minitest.rb#28
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end
end

# source://spoom//lib/spoom/deadcode/plugins/namespaces.rb#7
class Spoom::Deadcode::Plugins::Namespaces < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Class definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/namespaces.rb#10
  sig { override.params(definition: ::Spoom::Model::Class).void }
  def on_define_class(definition); end

  # : (Model::Module definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/namespaces.rb#16
  sig { override.params(definition: ::Spoom::Model::Module).void }
  def on_define_module(definition); end

  private

  # : (Model::Namespace symbol_def) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/namespaces.rb#23
  sig { params(symbol_def: ::Spoom::Model::Namespace).returns(T::Boolean) }
  def used_as_namespace?(symbol_def); end
end

# source://spoom//lib/spoom/deadcode/plugins/rspec.rb#7
class Spoom::Deadcode::Plugins::RSpec < ::Spoom::Deadcode::Plugins::Base; end

# source://spoom//lib/spoom/deadcode/plugins/rails.rb#7
class Spoom::Deadcode::Plugins::Rails < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Class definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/rails.rb#12
  sig { override.params(definition: ::Spoom::Model::Class).void }
  def on_define_class(definition); end

  # : (Model::Module definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/rails.rb#18
  sig { override.params(definition: ::Spoom::Model::Module).void }
  def on_define_module(definition); end

  private

  # : (Model::Namespace symbol_def) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/rails.rb#25
  sig { params(symbol_def: ::Spoom::Model::Namespace).returns(T::Boolean) }
  def file_is_helper?(symbol_def); end
end

# source://spoom//lib/spoom/deadcode/plugins/rake.rb#7
class Spoom::Deadcode::Plugins::Rake < ::Spoom::Deadcode::Plugins::Base; end

# source://spoom//lib/spoom/deadcode/plugins/rubocop.rb#7
class Spoom::Deadcode::Plugins::Rubocop < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Constant definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/rubocop.rb#17
  sig { override.params(definition: ::Spoom::Model::Constant).void }
  def on_define_constant(definition); end

  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/rubocop.rb#26
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end
end

# source://spoom//lib/spoom/deadcode/plugins/rubocop.rb#8
Spoom::Deadcode::Plugins::Rubocop::RUBOCOP_CONSTANTS = T.let(T.unsafe(nil), Set)

# source://spoom//lib/spoom/deadcode/plugins/ruby.rb#7
class Spoom::Deadcode::Plugins::Ruby < ::Spoom::Deadcode::Plugins::Base
  # : (Send send) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/ruby.rb#23
  sig { override.params(send: ::Spoom::Deadcode::Send).void }
  def on_send(send); end

  private

  # : (Send send, Prism::Node node) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/ruby.rb#45
  sig { params(send: ::Spoom::Deadcode::Send, node: ::Prism::Node).void }
  def reference_symbol_as_constant(send, node); end
end

# source://spoom//lib/spoom/deadcode/plugins/sorbet.rb#7
class Spoom::Deadcode::Plugins::Sorbet < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Constant definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/sorbet.rb#10
  sig { override.params(definition: ::Spoom::Model::Constant).void }
  def on_define_constant(definition); end

  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/sorbet.rb#16
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end

  private

  # : (Model::Constant definition) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/sorbet.rb#34
  sig { params(definition: ::Spoom::Model::Constant).returns(T::Boolean) }
  def sorbet_enum_constant?(definition); end

  # : (Model::Constant definition) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/plugins/sorbet.rb#29
  sig { params(definition: ::Spoom::Model::Constant).returns(T::Boolean) }
  def sorbet_type_member?(definition); end
end

# source://spoom//lib/spoom/deadcode/plugins/thor.rb#7
class Spoom::Deadcode::Plugins::Thor < ::Spoom::Deadcode::Plugins::Base
  # : (Model::Method definition) -> void
  #
  # source://spoom//lib/spoom/deadcode/plugins/thor.rb#12
  sig { override.params(definition: ::Spoom::Model::Method).void }
  def on_define_method(definition); end
end

# source://spoom//lib/spoom/deadcode/remover.rb#6
class Spoom::Deadcode::Remover
  # : (Context context) -> void
  #
  # @return [Remover] a new instance of Remover
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#10
  sig { params(context: ::Spoom::Context).void }
  def initialize(context); end

  # : (Definition::Kind? kind, Location location) -> String
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#15
  sig { params(kind: T.nilable(::Spoom::Deadcode::Definition::Kind), location: ::Spoom::Location).returns(::String) }
  def remove_location(kind, location); end
end

# source://spoom//lib/spoom/deadcode/remover.rb#7
class Spoom::Deadcode::Remover::Error < ::Spoom::Error; end

# source://spoom//lib/spoom/deadcode/remover.rb#362
class Spoom::Deadcode::Remover::NodeContext
  # : (String source, Hash[Integer, Prism::Comment] comments, Prism::Node node, Array[Prism::Node] nesting) -> void
  #
  # @return [NodeContext] a new instance of NodeContext
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#373
  sig do
    params(
      source: ::String,
      comments: T::Hash[::Integer, ::Prism::Comment],
      node: ::Prism::Node,
      nesting: T::Array[::Prism::Node]
    ).void
  end
  def initialize(source, comments, node, nesting); end

  # : (Prism::Node node) -> Array[Prism::Comment]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#487
  sig { params(node: ::Prism::Node).returns(T::Array[::Prism::Comment]) }
  def attached_comments(node); end

  # : -> Prism::CallNode?
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#515
  sig { returns(T.nilable(::Prism::CallNode)) }
  def attached_sig; end

  # : -> Array[Prism::Node]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#502
  sig { returns(T::Array[::Prism::Node]) }
  def attached_sigs; end

  # : Hash[Integer, Prism::Comment]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#364
  sig { returns(T::Hash[::Integer, ::Prism::Comment]) }
  def comments; end

  # : (Integer start_line, Integer end_line) -> Array[Prism::Comment]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#475
  sig { params(start_line: ::Integer, end_line: ::Integer).returns(T::Array[::Prism::Comment]) }
  def comments_between_lines(start_line, end_line); end

  # : Array[Prism::Node]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#370
  sig { returns(T::Array[::Prism::Node]) }
  def nesting; end

  # : Array[Prism::Node]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#370
  # @return [Array<Prism::Node>]
  def nesting=(_arg0); end

  # : -> Prism::Node?
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#425
  sig { returns(T.nilable(::Prism::Node)) }
  def next_node; end

  # : -> Array[Prism::Node]
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#414
  sig { returns(T::Array[::Prism::Node]) }
  def next_nodes; end

  # : Prism::Node
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#367
  sig { returns(::Prism::Node) }
  def node; end

  # : -> NodeContext
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#389
  sig { returns(::Spoom::Deadcode::Remover::NodeContext) }
  def parent_context; end

  # : -> Prism::Node
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#381
  sig { returns(::Prism::Node) }
  def parent_node; end

  # : -> Prism::Node?
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#409
  sig { returns(T.nilable(::Prism::Node)) }
  def previous_node; end

  # : -> Array[Prism::Node]
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#398
  sig { returns(T::Array[::Prism::Node]) }
  def previous_nodes; end

  # : -> NodeContext?
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#430
  sig { returns(T.nilable(::Spoom::Deadcode::Remover::NodeContext)) }
  def sclass_context; end

  # : (Prism::Node? node) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#463
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
  def sorbet_extend_sig?(node); end

  # : (Prism::Node? node) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#458
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
  def sorbet_signature?(node); end
end

# source://spoom//lib/spoom/deadcode/remover.rb#530
class Spoom::Deadcode::Remover::NodeFinder < ::Spoom::Visitor
  # : (Location location, Definition::Kind? kind) -> void
  #
  # @return [NodeFinder] a new instance of NodeFinder
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#598
  sig { params(location: ::Spoom::Location, kind: T.nilable(::Spoom::Deadcode::Definition::Kind)).void }
  def initialize(location, kind); end

  # : Prism::Node?
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#592
  sig { returns(T.nilable(::Prism::Node)) }
  def node; end

  # : Array[Prism::Node]
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#595
  sig { returns(T::Array[::Prism::Node]) }
  def nodes_nesting; end

  # : (Prism::Node? node) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#608
  sig { override.params(node: T.nilable(::Prism::Node)).void }
  def visit(node); end

  class << self
    # : (String source, Location location, Definition::Kind? kind) -> NodeContext
    #
    # source://spoom//lib/spoom/deadcode/remover.rb#533
    sig do
      params(
        source: ::String,
        location: ::Spoom::Location,
        kind: T.nilable(::Spoom::Deadcode::Definition::Kind)
      ).returns(::Spoom::Deadcode::Remover::NodeContext)
    end
    def find(source, location, kind); end

    # : (Prism::Node node, Definition::Kind kind) -> bool
    #
    # @return [Boolean]
    #
    # source://spoom//lib/spoom/deadcode/remover.rb#567
    sig { params(node: ::Prism::Node, kind: ::Spoom::Deadcode::Definition::Kind).returns(T::Boolean) }
    def node_match_kind?(node, kind); end
  end
end

# source://spoom//lib/spoom/deadcode/remover.rb#27
class Spoom::Deadcode::Remover::NodeRemover
  # : (String source, Definition::Kind? kind, Location location) -> void
  #
  # @return [NodeRemover] a new instance of NodeRemover
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#32
  sig do
    params(
      source: ::String,
      kind: T.nilable(::Spoom::Deadcode::Definition::Kind),
      location: ::Spoom::Location
    ).void
  end
  def initialize(source, kind, location); end

  # : -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#42
  sig { void }
  def apply_edit; end

  # : String
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#29
  sig { returns(::String) }
  def new_source; end

  private

  # : (NodeContext context) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#149
  sig { params(context: ::Spoom::Deadcode::Remover::NodeContext).void }
  def delete_attr_accessor(context); end

  # : (Integer start_char, Integer end_char) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#321
  sig { params(start_char: ::Integer, end_char: ::Integer).void }
  def delete_chars(start_char, end_char); end

  # : (NodeContext context) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#69
  sig { params(context: ::Spoom::Deadcode::Remover::NodeContext).void }
  def delete_constant_assignment(context); end

  # : (Integer start_line, Integer end_line) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#314
  sig { params(start_line: ::Integer, end_line: ::Integer).void }
  def delete_lines(start_line, end_line); end

  # : (NodeContext context) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#251
  sig { params(context: ::Spoom::Deadcode::Remover::NodeContext).void }
  def delete_node_and_comments_and_sigs(context); end

  # : (Prism::Node node, NodeContext send_context, was_removed: bool) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#208
  sig do
    params(
      node: ::Prism::Node,
      send_context: ::Spoom::Deadcode::Remover::NodeContext,
      was_removed: T::Boolean
    ).void
  end
  def insert_accessor(node, send_context, was_removed:); end

  # : (Integer start_char, Integer end_char, String replacement) -> void
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#326
  sig { params(start_char: ::Integer, end_char: ::Integer, replacement: ::String).void }
  def replace_chars(start_char, end_char, replacement); end

  # : (Prism::CallNode node, name: String, kind: Definition::Kind?) -> String
  #
  # source://spoom//lib/spoom/deadcode/remover.rb#331
  sig do
    params(
      node: ::Prism::CallNode,
      name: ::String,
      kind: T.nilable(::Spoom::Deadcode::Definition::Kind)
    ).returns(::String)
  end
  def transform_sig(node, name:, kind:); end
end

# An abstraction to simplify handling of Prism::CallNode nodes.
#
# source://spoom//lib/spoom/deadcode/send.rb#7
class Spoom::Deadcode::Send < ::T::Struct
  const :node, ::Prism::CallNode
  const :name, ::String
  const :recv, T.nilable(::Prism::Node), default: T.unsafe(nil)
  const :args, T::Array[::Prism::Node], default: T.unsafe(nil)
  const :block, T.nilable(::Prism::Node), default: T.unsafe(nil)
  const :location, ::Spoom::Location

  # : [T] (Class[T] arg_type) { (T arg) -> void } -> void
  #
  # source://spoom//lib/spoom/deadcode/send.rb#16
  sig do
    type_parameters(:T)
      .params(
        arg_type: T::Class[T.type_parameter(:T)],
        block: T.proc.params(arg: T.type_parameter(:T)).void
      ).void
  end
  def each_arg(arg_type, &block); end

  # : { (Prism::Node key, Prism::Node? value) -> void } -> void
  #
  # source://spoom//lib/spoom/deadcode/send.rb#23
  sig { params(block: T.proc.params(key: ::Prism::Node, value: T.nilable(::Prism::Node)).void).void }
  def each_arg_assoc(&block); end

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom.rb#10
class Spoom::Error < ::StandardError; end

# source://spoom//lib/spoom/context/exec.rb#5
class Spoom::ExecResult < ::T::Struct
  const :out, ::String
  const :err, T.nilable(::String)
  const :status, T::Boolean
  const :exit_code, ::Integer

  # : -> String
  #
  # source://spoom//lib/spoom/context/exec.rb#12
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/file_collector.rb#5
class Spoom::FileCollector
  # Initialize a new file collector
  #
  # If `allow_extensions` is empty, all files are collected.
  # If `allow_extensions` is an array of extensions, only files with one of these extensions are collected.
  #
  # If `allow_mime_types` is empty, all files are collected.
  # If `allow_mime_types` is an array of mimetypes, files without an extension are collected if their mimetype is in
  # the list.
  # : (?allow_extensions: Array[String], ?allow_mime_types: Array[String], ?exclude_patterns: Array[String]) -> void
  #
  # @return [FileCollector] a new instance of FileCollector
  #
  # source://spoom//lib/spoom/file_collector.rb#18
  # Initialize a new file collector
  # If `allow_extensions` is empty, all files are collected.
  # If `allow_extensions` is an array of extensions, only files with one of these extensions are collected.
  # If `allow_mime_types` is empty, all files are collected.
  # If `allow_mime_types` is an array of mimetypes, files without an extension are collected if their mimetype is in
  # the list.
  sig do
    params(
      allow_extensions: T::Array[::String],
      allow_mime_types: T::Array[::String],
      exclude_patterns: T::Array[::String]
    ).void
  end
  def initialize(allow_extensions: T.unsafe(nil), allow_mime_types: T.unsafe(nil), exclude_patterns: T.unsafe(nil)); end

  # : Array[String]
  #
  # source://spoom//lib/spoom/file_collector.rb#7
  sig { returns(T::Array[::String]) }
  def files; end

  # : (String path) -> void
  #
  # source://spoom//lib/spoom/file_collector.rb#31
  sig { params(path: ::String).void }
  def visit_path(path); end

  # : (Array[String] paths) -> void
  #
  # source://spoom//lib/spoom/file_collector.rb#26
  sig { params(paths: T::Array[::String]).void }
  def visit_paths(paths); end

  private

  # : (String path) -> String
  #
  # source://spoom//lib/spoom/file_collector.rb#48
  sig { params(path: ::String).returns(::String) }
  def clean_path(path); end

  # : (String path) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/file_collector.rb#65
  sig { params(path: ::String).returns(T::Boolean) }
  def excluded_file?(path); end

  # : (String path) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/file_collector.rb#80
  sig { params(path: ::String).returns(T::Boolean) }
  def excluded_path?(path); end

  # : (String path) -> String?
  #
  # source://spoom//lib/spoom/file_collector.rb#89
  sig { params(path: ::String).returns(T.nilable(::String)) }
  def mime_type_for(path); end

  # : (String path) -> void
  #
  # source://spoom//lib/spoom/file_collector.rb#60
  sig { params(path: ::String).void }
  def visit_directory(path); end

  # : (String path) -> void
  #
  # source://spoom//lib/spoom/file_collector.rb#53
  sig { params(path: ::String).void }
  def visit_file(path); end
end

# Build a file hierarchy from a set of file paths.
#
# source://spoom//lib/spoom/file_tree.rb#6
class Spoom::FileTree
  # : (?T::Enumerable[String] paths) -> void
  #
  # @return [FileTree] a new instance of FileTree
  #
  # source://spoom//lib/spoom/file_tree.rb#8
  sig { params(paths: T::Enumerable[::String]).void }
  def initialize(paths = T.unsafe(nil)); end

  # Add a `path` to the tree
  #
  # This will create all nodes until the root of `path`.
  # : (String path) -> Node
  #
  # source://spoom//lib/spoom/file_tree.rb#23
  # Add a `path` to the tree
  # This will create all nodes until the root of `path`.
  sig { params(path: ::String).returns(::Spoom::FileTree::Node) }
  def add_path(path); end

  # Add all `paths` to the tree
  # : (T::Enumerable[String] paths) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#15
  # Add all `paths` to the tree
  sig { params(paths: T::Enumerable[::String]).void }
  def add_paths(paths); end

  # All the nodes in this tree
  # : -> Array[Node]
  #
  # source://spoom//lib/spoom/file_tree.rb#43
  # All the nodes in this tree
  sig { returns(T::Array[::Spoom::FileTree::Node]) }
  def nodes; end

  # Return a map of typing scores for each node in the tree
  # : (Context context) -> Hash[Node, Float]
  #
  # source://spoom//lib/spoom/file_tree.rb#57
  # Return a map of typing scores for each node in the tree
  sig { params(context: ::Spoom::Context).returns(T::Hash[::Spoom::FileTree::Node, ::Float]) }
  def nodes_strictness_scores(context); end

  # All the paths in this tree
  # : -> Array[String]
  #
  # source://spoom//lib/spoom/file_tree.rb#51
  # All the paths in this tree
  sig { returns(T::Array[::String]) }
  def paths; end

  # Return a map of typing scores for each path in the tree
  # : (Context context) -> Hash[String, Float]
  #
  # source://spoom//lib/spoom/file_tree.rb#65
  # Return a map of typing scores for each path in the tree
  sig { params(context: ::Spoom::Context).returns(T::Hash[::String, ::Float]) }
  def paths_strictness_scores(context); end

  # : (?out: (IO | StringIO), ?colors: bool) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#70
  sig { params(out: T.any(::IO, ::StringIO), colors: T::Boolean).void }
  def print(out: T.unsafe(nil), colors: T.unsafe(nil)); end

  # All root nodes
  # : -> Array[Node]
  #
  # source://spoom//lib/spoom/file_tree.rb#37
  # All root nodes
  sig { returns(T::Array[::Spoom::FileTree::Node]) }
  def roots; end
end

# A visitor that collects all the nodes in a tree
#
# source://spoom//lib/spoom/file_tree.rb#119
class Spoom::FileTree::CollectNodes < ::Spoom::FileTree::Visitor
  # : -> void
  #
  # @return [CollectNodes] a new instance of CollectNodes
  #
  # source://spoom//lib/spoom/file_tree.rb#124
  sig { void }
  def initialize; end

  # : Array[FileTree::Node]
  #
  # source://spoom//lib/spoom/file_tree.rb#121
  sig { returns(T::Array[::Spoom::FileTree::Node]) }
  def nodes; end

  # : (FileTree::Node node) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#131
  sig { override.params(node: ::Spoom::FileTree::Node).void }
  def visit_node(node); end
end

# A visitor that collects the typing score of each node in a tree
#
# source://spoom//lib/spoom/file_tree.rb#160
class Spoom::FileTree::CollectScores < ::Spoom::FileTree::CollectStrictnesses
  # : (Context context) -> void
  #
  # @return [CollectScores] a new instance of CollectScores
  #
  # source://spoom//lib/spoom/file_tree.rb#165
  sig { params(context: ::Spoom::Context).void }
  def initialize(context); end

  # : Hash[Node, Float]
  #
  # source://spoom//lib/spoom/file_tree.rb#162
  sig { returns(T::Hash[::Spoom::FileTree::Node, ::Float]) }
  def scores; end

  # : (FileTree::Node node) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#173
  sig { override.params(node: ::Spoom::FileTree::Node).void }
  def visit_node(node); end

  private

  # : (Node node) -> Float
  #
  # source://spoom//lib/spoom/file_tree.rb#182
  sig { params(node: ::Spoom::FileTree::Node).returns(::Float) }
  def node_score(node); end

  # : (String? strictness) -> Float
  #
  # source://spoom//lib/spoom/file_tree.rb#191
  sig { params(strictness: T.nilable(::String)).returns(::Float) }
  def strictness_score(strictness); end
end

# A visitor that collects the strictness of each node in a tree
#
# source://spoom//lib/spoom/file_tree.rb#138
class Spoom::FileTree::CollectStrictnesses < ::Spoom::FileTree::Visitor
  # : (Context context) -> void
  #
  # @return [CollectStrictnesses] a new instance of CollectStrictnesses
  #
  # source://spoom//lib/spoom/file_tree.rb#143
  sig { params(context: ::Spoom::Context).void }
  def initialize(context); end

  # : Hash[Node, String?]
  #
  # source://spoom//lib/spoom/file_tree.rb#140
  sig { returns(T::Hash[::Spoom::FileTree::Node, T.nilable(::String)]) }
  def strictnesses; end

  # : (FileTree::Node node) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#151
  sig { override.params(node: ::Spoom::FileTree::Node).void }
  def visit_node(node); end
end

# A node representing either a file or a directory inside a FileTree
#
# source://spoom//lib/spoom/file_tree.rb#76
class Spoom::FileTree::Node < ::T::Struct
  const :parent, T.nilable(::Spoom::FileTree::Node)
  const :name, ::String
  const :children, T::Hash[::String, ::Spoom::FileTree::Node], default: T.unsafe(nil)

  # Full path to this node from root
  # : -> String
  #
  # source://spoom//lib/spoom/file_tree.rb#88
  # Full path to this node from root
  sig { returns(::String) }
  def path; end

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# An internal class used to print a FileTree
#
# See `FileTree#print`
#
# source://spoom//lib/spoom/file_tree.rb#204
# An internal class used to print a FileTree
class Spoom::FileTree::Printer < ::Spoom::FileTree::Visitor
  # : (Hash[FileTree::Node, String?] strictnesses, ?out: (IO | StringIO), ?colors: bool) -> void
  #
  # @return [Printer] a new instance of Printer
  #
  # source://spoom//lib/spoom/file_tree.rb#206
  sig do
    params(
      strictnesses: T::Hash[::Spoom::FileTree::Node, T.nilable(::String)],
      out: T.any(::IO, ::StringIO),
      colors: T::Boolean
    ).void
  end
  def initialize(strictnesses, out: T.unsafe(nil), colors: T.unsafe(nil)); end

  # : (FileTree::Node node) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#215
  sig { override.params(node: ::Spoom::FileTree::Node).void }
  def visit_node(node); end

  private

  # : (String? strictness) -> Color
  #
  # source://spoom//lib/spoom/file_tree.rb#240
  sig { params(strictness: T.nilable(::String)).returns(::Spoom::Color) }
  def strictness_color(strictness); end
end

# An abstract visitor for FileTree
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/file_tree.rb#97
class Spoom::FileTree::Visitor
  abstract!

  # : (FileTree::Node node) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#108
  sig { params(node: ::Spoom::FileTree::Node).void }
  def visit_node(node); end

  # : (Array[FileTree::Node] nodes) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#113
  sig { params(nodes: T::Array[::Spoom::FileTree::Node]).void }
  def visit_nodes(nodes); end

  # : (FileTree tree) -> void
  #
  # source://spoom//lib/spoom/file_tree.rb#103
  sig { params(tree: ::Spoom::FileTree).void }
  def visit_tree(tree); end
end

# source://spoom//lib/spoom/context/git.rb#5
module Spoom::Git; end

# source://spoom//lib/spoom/context/git.rb#6
class Spoom::Git::Commit < ::T::Struct
  const :sha, ::String
  const :time, ::Time

  # : -> Integer
  #
  # source://spoom//lib/spoom/context/git.rb#23
  sig { returns(::Integer) }
  def timestamp; end

  class << self
    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end

    # Parse a line formatted as `%h %at` into a `Commit`
    # : (String string) -> Commit?
    #
    # source://spoom//lib/spoom/context/git.rb#10
    # Parse a line formatted as `%h %at` into a `Commit`
    sig { params(string: ::String).returns(T.nilable(::Spoom::Git::Commit)) }
    def parse_line(string); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/base.rb#5
module Spoom::LSP; end

# source://spoom//lib/spoom/sorbet/lsp.rb#13
class Spoom::LSP::Client
  # : (String sorbet_bin, *String sorbet_args, ?path: String) -> void
  #
  # @return [Client] a new instance of Client
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#15
  sig { params(sorbet_bin: ::String, sorbet_args: ::String, path: ::String).void }
  def initialize(sorbet_bin, *sorbet_args, path: T.unsafe(nil)); end

  # : -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#227
  sig { void }
  def close; end

  # : (String uri, Integer line, Integer column) -> Array[Location]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#129
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::Location]) }
  def definitions(uri, line, column); end

  # : (String uri) -> Array[DocumentSymbol]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#210
  sig { params(uri: ::String).returns(T::Array[::Spoom::LSP::DocumentSymbol]) }
  def document_symbols(uri); end

  # : (String uri, Integer line, Integer column) -> Hover?
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#87
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T.nilable(::Spoom::LSP::Hover)) }
  def hover(uri, line, column); end

  # : -> Integer
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#25
  sig { returns(::Integer) }
  def next_id; end

  # : (String workspace_path) -> void
  #
  # @raise [Error::AlreadyOpen]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#70
  # LSP requests
  sig { params(workspace_path: ::String).void }
  def open(workspace_path); end

  # : -> Hash[untyped, untyped]?
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#52
  sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def read; end

  # : -> String?
  #
  # @raise [Error::BadHeaders]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#41
  sig { returns(T.nilable(::String)) }
  def read_raw; end

  # : (String uri, Integer line, Integer column, ?bool include_decl) -> Array[Location]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#171
  sig do
    params(
      uri: ::String,
      line: ::Integer,
      column: ::Integer,
      include_decl: T::Boolean
    ).returns(T::Array[::Spoom::LSP::Location])
  end
  def references(uri, line, column, include_decl = T.unsafe(nil)); end

  # : (Message message) -> Hash[untyped, untyped]?
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#35
  sig { params(message: ::Spoom::LSP::Message).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def send(message); end

  # : (String json_string) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#30
  sig { params(json_string: ::String).void }
  def send_raw(json_string); end

  # : (String uri, Integer line, Integer column) -> Array[SignatureHelp]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#108
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::SignatureHelp]) }
  def signatures(uri, line, column); end

  # : (String query) -> Array[DocumentSymbol]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#195
  sig { params(query: ::String).returns(T::Array[::Spoom::LSP::DocumentSymbol]) }
  def symbols(query); end

  # : (String uri, Integer line, Integer column) -> Array[Location]
  #
  # source://spoom//lib/spoom/sorbet/lsp.rb#150
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::Location]) }
  def type_definitions(uri, line, column); end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#168
class Spoom::LSP::Diagnostic < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :range, ::Spoom::LSP::Range
  const :code, ::Integer
  const :message, ::String
  const :information, ::Object

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#190
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#195
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> Diagnostic
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#178
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Diagnostic) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#200
class Spoom::LSP::DocumentSymbol < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :name, ::String
  const :detail, T.nilable(::String)
  const :kind, ::Integer
  const :location, T.nilable(::Spoom::LSP::Location)
  const :range, T.nilable(::Spoom::LSP::Range)
  const :children, T::Array[::Spoom::LSP::DocumentSymbol]

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#226
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#258
  sig { returns(::String) }
  def kind_string; end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#253
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> DocumentSymbol
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#212
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::DocumentSymbol) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#262
Spoom::LSP::DocumentSymbol::SYMBOL_KINDS = T.let(T.unsafe(nil), Hash)

# source://spoom//lib/spoom/sorbet/lsp/errors.rb#6
class Spoom::LSP::Error < ::Spoom::Error; end

# source://spoom//lib/spoom/sorbet/lsp/errors.rb#7
class Spoom::LSP::Error::AlreadyOpen < ::Spoom::LSP::Error; end

# source://spoom//lib/spoom/sorbet/lsp/errors.rb#8
class Spoom::LSP::Error::BadHeaders < ::Spoom::LSP::Error; end

# source://spoom//lib/spoom/sorbet/lsp/errors.rb#10
class Spoom::LSP::Error::Diagnostics < ::Spoom::LSP::Error
  # : (String uri, Array[Diagnostic] diagnostics) -> void
  #
  # @return [Diagnostics] a new instance of Diagnostics
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#28
  sig { params(uri: ::String, diagnostics: T::Array[::Spoom::LSP::Diagnostic]).void }
  def initialize(uri, diagnostics); end

  # : Array[Diagnostic]
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#15
  sig { returns(T::Array[::Spoom::LSP::Diagnostic]) }
  def diagnostics; end

  # : String
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#12
  sig { returns(::String) }
  def uri; end

  class << self
    # : (Hash[untyped, untyped] json) -> Diagnostics
    #
    # source://spoom//lib/spoom/sorbet/lsp/errors.rb#19
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Error::Diagnostics) }
    def from_json(json); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#19
class Spoom::LSP::Hover < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :contents, ::String
  const :range, T.nilable(T::Range[T.untyped])

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#37
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#43
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> Hover
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#27
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Hover) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#106
class Spoom::LSP::Location < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :uri, ::String
  const :range, ::Spoom::LSP::Range

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#124
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#130
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> Location
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#114
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Location) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# A general message as defined by JSON-RPC.
#
# The language server protocol always uses `"2.0"` as the `jsonrpc` version.
#
# source://spoom//lib/spoom/sorbet/lsp/base.rb#12
# A general message as defined by JSON-RPC.
class Spoom::LSP::Message
  # : -> void
  #
  # @return [Message] a new instance of Message
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#14
  sig { void }
  def initialize; end

  # : -> Hash[untyped, untyped]
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#19
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def as_json; end

  # : (*untyped args) -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#27
  sig { params(args: T.untyped).returns(::String) }
  def to_json(*args); end
end

# A notification message.
#
# A processed notification message must not send a response back. They work like events.
#
# source://spoom//lib/spoom/sorbet/lsp/base.rb#54
# A notification message.
class Spoom::LSP::Notification < ::Spoom::LSP::Message
  # : (String method, Hash[untyped, untyped] params) -> void
  #
  # @return [Notification] a new instance of Notification
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#62
  sig { params(method: ::String, params: T::Hash[T.untyped, T.untyped]).void }
  def initialize(method, params); end

  # : String
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#56
  sig { returns(::String) }
  def method; end

  # : Hash[untyped, untyped]
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#59
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def params; end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#48
class Spoom::LSP::Position < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :line, ::Integer
  const :char, ::Integer

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#66
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#71
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> Position
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#56
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Position) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/sorbet/lsp/structures.rb#9
module Spoom::LSP::PrintableSymbol
  interface!

  # @abstract
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#16
  sig { abstract.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#76
class Spoom::LSP::Range < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :start, ::Spoom::LSP::Position
  const :end, ::Spoom::LSP::Position

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#94
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#101
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> Range
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#84
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Range) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# A request message to describe a request between the client and the server.
#
# Every processed request must send a response back to the sender of the request.
#
# source://spoom//lib/spoom/sorbet/lsp/base.rb#35
# A request message to describe a request between the client and the server.
class Spoom::LSP::Request < ::Spoom::LSP::Message
  # : (Integer id, String method, Hash[untyped, untyped] params) -> void
  #
  # @return [Request] a new instance of Request
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#43
  sig { params(id: ::Integer, method: ::String, params: T::Hash[T.untyped, T.untyped]).void }
  def initialize(id, method, params); end

  # : Integer
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#37
  sig { returns(::Integer) }
  def id; end

  # : Hash[untyped, untyped]
  #
  # source://spoom//lib/spoom/sorbet/lsp/base.rb#40
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def params; end
end

# source://spoom//lib/spoom/sorbet/lsp/errors.rb#36
class Spoom::LSP::ResponseError < ::Spoom::LSP::Error
  # : (Integer code, String message, Hash[untyped, untyped] data) -> void
  #
  # @return [ResponseError] a new instance of ResponseError
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#55
  sig { params(code: ::Integer, message: ::String, data: T::Hash[T.untyped, T.untyped]).void }
  def initialize(code, message, data); end

  # : Integer
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#38
  sig { returns(::Integer) }
  def code; end

  # : Hash[untyped, untyped]
  #
  # source://spoom//lib/spoom/sorbet/lsp/errors.rb#41
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def data; end

  class << self
    # : (Hash[untyped, untyped] json) -> ResponseError
    #
    # source://spoom//lib/spoom/sorbet/lsp/errors.rb#45
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::ResponseError) }
    def from_json(json); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#135
class Spoom::LSP::SignatureHelp < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :label, T.nilable(::String)
  const :doc, ::Object
  const :params, T::Array[T.untyped]

  # : (SymbolPrinter printer) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#155
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#163
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (Hash[untyped, untyped] json) -> SignatureHelp
    #
    # source://spoom//lib/spoom/sorbet/lsp/structures.rb#144
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::SignatureHelp) }
    def from_json(json); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://spoom//lib/spoom/sorbet/lsp/structures.rb#295
class Spoom::LSP::SymbolPrinter < ::Spoom::Printer
  # : (?out: (IO | StringIO), ?colors: bool, ?indent_level: Integer, ?prefix: String?) -> void
  #
  # @return [SymbolPrinter] a new instance of SymbolPrinter
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#303
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      colors: T::Boolean,
      indent_level: ::Integer,
      prefix: T.nilable(::String)
    ).void
  end
  def initialize(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil), prefix: T.unsafe(nil)); end

  # : (String uri) -> String
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#325
  sig { params(uri: ::String).returns(::String) }
  def clean_uri(uri); end

  # : String?
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#300
  sig { returns(T.nilable(::String)) }
  def prefix; end

  # : String?
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#300
  # @return [String, nil]
  def prefix=(_arg0); end

  # : (Array[PrintableSymbol] objects) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#333
  sig { params(objects: T::Array[::Spoom::LSP::PrintableSymbol]).void }
  def print_list(objects); end

  # : (PrintableSymbol? object) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#313
  sig { params(object: T.nilable(::Spoom::LSP::PrintableSymbol)).void }
  def print_object(object); end

  # : (Array[PrintableSymbol] objects) -> void
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#320
  sig { params(objects: T::Array[::Spoom::LSP::PrintableSymbol]).void }
  def print_objects(objects); end

  # : Set[Integer]
  #
  # source://spoom//lib/spoom/sorbet/lsp/structures.rb#297
  sig { returns(T::Set[::Integer]) }
  def seen; end
end

# source://spoom//lib/spoom/location.rb#5
class Spoom::Location
  include ::Comparable

  # : (String file, ?start_line: Integer?, ?start_column: Integer?, ?end_line: Integer?, ?end_column: Integer?) -> void
  #
  # @raise [LocationError]
  # @return [Location] a new instance of Location
  #
  # source://spoom//lib/spoom/location.rb#61
  sig do
    params(
      file: ::String,
      start_line: T.nilable(::Integer),
      start_column: T.nilable(::Integer),
      end_line: T.nilable(::Integer),
      end_column: T.nilable(::Integer)
    ).void
  end
  def initialize(file, start_line: T.unsafe(nil), start_column: T.unsafe(nil), end_line: T.unsafe(nil), end_column: T.unsafe(nil)); end

  # : (BasicObject other) -> Integer?
  #
  # source://spoom//lib/spoom/location.rb#95
  sig { override.params(other: ::BasicObject).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # : Integer?
  #
  # source://spoom//lib/spoom/location.rb#58
  # @return [Integer, nil]
  def end_column; end

  # : Integer?
  #
  # source://spoom//lib/spoom/location.rb#58
  # @return [Integer, nil]
  def end_line; end

  # : String
  #
  # source://spoom//lib/spoom/location.rb#55
  sig { returns(::String) }
  def file; end

  # : (Location other) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/location.rb#81
  sig { params(other: ::Spoom::Location).returns(T::Boolean) }
  def include?(other); end

  # : Integer?
  #
  # source://spoom//lib/spoom/location.rb#58
  # @return [Integer, nil]
  def start_column; end

  # : Integer?
  #
  # source://spoom//lib/spoom/location.rb#58
  sig { returns(T.nilable(::Integer)) }
  def start_line; end

  # : -> String
  #
  # source://spoom//lib/spoom/location.rb#118
  sig { returns(::String) }
  def to_s; end

  class << self
    # : (String file, Prism::Location location) -> Location
    #
    # source://spoom//lib/spoom/location.rb#43
    sig { params(file: ::String, location: ::Prism::Location).returns(::Spoom::Location) }
    def from_prism(file, location); end

    # : (String location_string) -> Location
    #
    # @raise [LocationError]
    #
    # source://spoom//lib/spoom/location.rb#12
    sig { params(location_string: ::String).returns(::Spoom::Location) }
    def from_string(location_string); end
  end
end

# source://spoom//lib/spoom/location.rb#8
class Spoom::Location::LocationError < ::Spoom::Error; end

# source://spoom//lib/spoom/model/model.rb#5
class Spoom::Model
  # : -> void
  #
  # @return [Model] a new instance of Model
  #
  # source://spoom//lib/spoom/model/model.rb#235
  sig { void }
  def initialize; end

  # Get a symbol by it's full name
  #
  # Raises an error if the symbol is not found
  # : (String full_name) -> Symbol
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/model/model.rb#244
  # Get a symbol by it's full name
  # Raises an error if the symbol is not found
  sig { params(full_name: ::String).returns(::Spoom::Model::Symbol) }
  def [](full_name); end

  # : -> void
  #
  # source://spoom//lib/spoom/model/model.rb#293
  sig { void }
  def finalize!; end

  # Register a new symbol by it's full name
  #
  # If the symbol already exists, it will be returned.
  # : (String full_name) -> Symbol
  #
  # source://spoom//lib/spoom/model/model.rb#255
  # Register a new symbol by it's full name
  # If the symbol already exists, it will be returned.
  sig { params(full_name: ::String).returns(::Spoom::Model::Symbol) }
  def register_symbol(full_name); end

  # : (String full_name, context: Symbol) -> Symbol
  #
  # source://spoom//lib/spoom/model/model.rb#260
  sig { params(full_name: ::String, context: ::Spoom::Model::Symbol).returns(::Spoom::Model::Symbol) }
  def resolve_symbol(full_name, context:); end

  # : (Symbol symbol) -> Array[Symbol]
  #
  # source://spoom//lib/spoom/model/model.rb#287
  sig { params(symbol: ::Spoom::Model::Symbol).returns(T::Array[::Spoom::Model::Symbol]) }
  def subtypes(symbol); end

  # : (Symbol symbol) -> Array[Symbol]
  #
  # source://spoom//lib/spoom/model/model.rb#281
  sig { params(symbol: ::Spoom::Model::Symbol).returns(T::Array[::Spoom::Model::Symbol]) }
  def supertypes(symbol); end

  # All the symbols registered in this model
  # : Hash[String, Symbol]
  #
  # source://spoom//lib/spoom/model/model.rb#229
  # All the symbols registered in this model
  sig { returns(T::Hash[::String, ::Spoom::Model::Symbol]) }
  def symbols; end

  # : Poset[Symbol]
  #
  # source://spoom//lib/spoom/model/model.rb#232
  sig { returns(Spoom::Poset[::Spoom::Model::Symbol]) }
  def symbols_hierarchy; end

  private

  # : -> void
  #
  # source://spoom//lib/spoom/model/model.rb#300
  sig { void }
  def compute_symbols_hierarchy!; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/model.rb#179
class Spoom::Model::Attr < ::Spoom::Model::Property
  abstract!
end

# source://spoom//lib/spoom/model/model.rb#185
class Spoom::Model::AttrAccessor < ::Spoom::Model::Attr; end

# source://spoom//lib/spoom/model/model.rb#183
class Spoom::Model::AttrReader < ::Spoom::Model::Attr; end

# source://spoom//lib/spoom/model/model.rb#184
class Spoom::Model::AttrWriter < ::Spoom::Model::Attr; end

# Populate a Model by visiting the nodes from a Ruby file
#
# source://spoom//lib/spoom/model/builder.rb#7
class Spoom::Model::Builder < ::Spoom::Model::NamespaceVisitor
  # : (Model model, String file, ?comments: Array[Prism::Comment]) -> void
  #
  # @return [Builder] a new instance of Builder
  #
  # source://spoom//lib/spoom/model/builder.rb#9
  sig { params(model: ::Spoom::Model, file: ::String, comments: T::Array[::Prism::Comment]).void }
  def initialize(model, file, comments:); end

  # : (Prism::CallNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#165
  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end

  # : (Prism::ClassNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#29
  sig { override.params(node: ::Prism::ClassNode).void }
  def visit_class_node(node); end

  # : (Prism::ConstantPathWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#82
  sig { override.params(node: ::Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # : (Prism::ConstantWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#105
  sig { override.params(node: ::Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # : (Prism::DefNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#144
  sig { override.params(node: ::Prism::DefNode).void }
  def visit_def_node(node); end

  # : (Prism::ModuleNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#64
  sig { override.params(node: ::Prism::ModuleNode).void }
  def visit_module_node(node); end

  # : (Prism::MultiWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#121
  sig { override.params(node: ::Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # : (Prism::SingletonClassNode node) -> void
  #
  # source://spoom//lib/spoom/model/builder.rb#46
  sig { override.params(node: ::Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  private

  # : -> Array[Sig]
  #
  # source://spoom//lib/spoom/model/builder.rb#256
  sig { returns(T::Array[::Spoom::Model::Sig]) }
  def collect_sigs; end

  # : -> Visibility
  #
  # source://spoom//lib/spoom/model/builder.rb#251
  sig { returns(::Spoom::Model::Visibility) }
  def current_visibility; end

  # : (Prism::Node node) -> Array[Comment]
  #
  # source://spoom//lib/spoom/model/builder.rb#268
  sig { params(node: ::Prism::Node).returns(T::Array[::Spoom::Model::Comment]) }
  def node_comments(node); end

  # : (Prism::Node node) -> Location
  #
  # source://spoom//lib/spoom/model/builder.rb#263
  sig { params(node: ::Prism::Node).returns(::Spoom::Location) }
  def node_location(node); end
end

# source://spoom//lib/spoom/model/model.rb#132
class Spoom::Model::Class < ::Spoom::Model::Namespace
  # : (Symbol symbol, owner: Namespace?, location: Location, ?superclass_name: String?, ?comments: Array[Comment]) -> void
  #
  # @return [Class] a new instance of Class
  #
  # source://spoom//lib/spoom/model/model.rb#137
  sig do
    params(
      symbol: ::Spoom::Model::Symbol,
      owner: T.nilable(::Spoom::Model::Namespace),
      location: ::Spoom::Location,
      superclass_name: T.nilable(::String),
      comments: T::Array[::Spoom::Model::Comment]
    ).void
  end
  def initialize(symbol, owner:, location:, superclass_name: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : String?
  #
  # source://spoom//lib/spoom/model/model.rb#134
  sig { returns(T.nilable(::String)) }
  def superclass_name; end

  # : String?
  #
  # source://spoom//lib/spoom/model/model.rb#134
  # @return [String, nil]
  def superclass_name=(_arg0); end
end

# source://spoom//lib/spoom/model/model.rb#8
class Spoom::Model::Comment
  # : (String string, Location location) -> void
  #
  # @return [Comment] a new instance of Comment
  #
  # source://spoom//lib/spoom/model/model.rb#16
  sig { params(string: ::String, location: ::Spoom::Location).void }
  def initialize(string, location); end

  # : Location
  #
  # source://spoom//lib/spoom/model/model.rb#13
  sig { returns(::Spoom::Location) }
  def location; end

  # : String
  #
  # source://spoom//lib/spoom/model/model.rb#10
  sig { returns(::String) }
  def string; end
end

# source://spoom//lib/spoom/model/model.rb#146
class Spoom::Model::Constant < ::Spoom::Model::SymbolDef
  # : (Symbol symbol, owner: Namespace?, location: Location, value: String, ?comments: Array[Comment]) -> void
  #
  # @return [Constant] a new instance of Constant
  #
  # source://spoom//lib/spoom/model/model.rb#151
  sig do
    params(
      symbol: ::Spoom::Model::Symbol,
      owner: T.nilable(::Spoom::Model::Namespace),
      location: ::Spoom::Location,
      value: ::String,
      comments: T::Array[::Spoom::Model::Comment]
    ).void
  end
  def initialize(symbol, owner:, location:, value:, comments: T.unsafe(nil)); end

  # : String
  #
  # source://spoom//lib/spoom/model/model.rb#148
  sig { returns(::String) }
  def value; end
end

# source://spoom//lib/spoom/model/model.rb#6
class Spoom::Model::Error < ::Spoom::Error; end

# source://spoom//lib/spoom/model/model.rb#212
class Spoom::Model::Extend < ::Spoom::Model::Mixin; end

# source://spoom//lib/spoom/model/model.rb#210
class Spoom::Model::Include < ::Spoom::Model::Mixin; end

# source://spoom//lib/spoom/model/model.rb#177
class Spoom::Model::Method < ::Spoom::Model::Property; end

# A mixin (include, prepend, extend) to a namespace
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/model.rb#196
class Spoom::Model::Mixin
  abstract!

  # : (String name) -> void
  #
  # @return [Mixin] a new instance of Mixin
  #
  # source://spoom//lib/spoom/model/model.rb#205
  sig { params(name: ::String).void }
  def initialize(name); end

  # : String
  #
  # source://spoom//lib/spoom/model/model.rb#202
  sig { returns(::String) }
  def name; end
end

# source://spoom//lib/spoom/model/model.rb#144
class Spoom::Model::Module < ::Spoom::Model::Namespace; end

# A class or module
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/model.rb#112
class Spoom::Model::Namespace < ::Spoom::Model::SymbolDef
  abstract!

  # : (Symbol symbol, owner: Namespace?, location: Location, ?comments: Array[Comment]) -> void
  #
  # @return [Namespace] a new instance of Namespace
  #
  # source://spoom//lib/spoom/model/model.rb#122
  sig do
    params(
      symbol: ::Spoom::Model::Symbol,
      owner: T.nilable(::Spoom::Model::Namespace),
      location: ::Spoom::Location,
      comments: T::Array[::Spoom::Model::Comment]
    ).void
  end
  def initialize(symbol, owner:, location:, comments: T.unsafe(nil)); end

  # : Array[SymbolDef]
  #
  # source://spoom//lib/spoom/model/model.rb#116
  sig { returns(T::Array[::Spoom::Model::SymbolDef]) }
  def children; end

  # : Array[Mixin]
  #
  # source://spoom//lib/spoom/model/model.rb#119
  sig { returns(T::Array[::Spoom::Model::Mixin]) }
  def mixins; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/namespace_visitor.rb#6
class Spoom::Model::NamespaceVisitor < ::Spoom::Visitor
  abstract!

  # : -> void
  #
  # @return [NamespaceVisitor] a new instance of NamespaceVisitor
  #
  # source://spoom//lib/spoom/model/namespace_visitor.rb#12
  sig { void }
  def initialize; end

  # : (Prism::Node? node) -> void
  #
  # source://spoom//lib/spoom/model/namespace_visitor.rb#20
  sig { override.params(node: T.nilable(::Prism::Node)).void }
  def visit(node); end
end

# source://spoom//lib/spoom/model/model.rb#211
class Spoom::Model::Prepend < ::Spoom::Model::Mixin; end

# A method or an attribute accessor
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/model.rb#159
class Spoom::Model::Property < ::Spoom::Model::SymbolDef
  abstract!

  # : (Symbol symbol, owner: Namespace?, location: Location, visibility: Visibility, ?sigs: Array[Sig], ?comments: Array[Comment]) -> void
  #
  # @return [Property] a new instance of Property
  #
  # source://spoom//lib/spoom/model/model.rb#169
  sig do
    params(
      symbol: ::Spoom::Model::Symbol,
      owner: T.nilable(::Spoom::Model::Namespace),
      location: ::Spoom::Location,
      visibility: ::Spoom::Model::Visibility,
      sigs: T::Array[::Spoom::Model::Sig],
      comments: T::Array[::Spoom::Model::Comment]
    ).void
  end
  def initialize(symbol, owner:, location:, visibility:, sigs: T.unsafe(nil), comments: T.unsafe(nil)); end

  # : Array[Sig]
  #
  # source://spoom//lib/spoom/model/model.rb#166
  sig { returns(T::Array[::Spoom::Model::Sig]) }
  def sigs; end

  # : Visibility
  #
  # source://spoom//lib/spoom/model/model.rb#163
  sig { returns(::Spoom::Model::Visibility) }
  def visibility; end
end

# A reference to something that looks like a constant or a method
#
# Constants could be classes, modules, or actual constants.
# Methods could be accessors, instance or class methods, aliases, etc.
#
# source://spoom//lib/spoom/model/reference.rb#10
# A reference to something that looks like a constant or a method
# Constants could be classes, modules, or actual constants.
class Spoom::Model::Reference < ::T::Struct
  const :kind, ::Spoom::Model::Reference::Kind
  const :name, ::String
  const :location, ::Spoom::Location

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/model/reference.rb#35
  sig { returns(T::Boolean) }
  def constant?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/model/reference.rb#40
  sig { returns(T::Boolean) }
  def method?; end

  class << self
    # : (String name, Spoom::Location location) -> Reference
    #
    # source://spoom//lib/spoom/model/reference.rb#20
    sig { params(name: ::String, location: ::Spoom::Location).returns(::Spoom::Model::Reference) }
    def constant(name, location); end

    # source://sorbet-runtime/0.5.11965/lib/types/struct.rb#13
    def inherited(s); end

    # : (String name, Spoom::Location location) -> Reference
    #
    # source://spoom//lib/spoom/model/reference.rb#25
    sig { params(name: ::String, location: ::Spoom::Location).returns(::Spoom::Model::Reference) }
    def method(name, location); end
  end
end

# source://spoom//lib/spoom/model/reference.rb#11
class Spoom::Model::Reference::Kind < ::T::Enum
  enums do
    Constant = new
    Method = new
  end
end

# Visit a file to collect all the references to constants and methods
#
# source://spoom//lib/spoom/model/references_visitor.rb#7
class Spoom::Model::ReferencesVisitor < ::Spoom::Visitor
  # : (String file) -> void
  #
  # @return [ReferencesVisitor] a new instance of ReferencesVisitor
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#12
  sig { params(file: ::String).void }
  def initialize(file); end

  # : Array[Reference]
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#9
  sig { returns(T::Array[::Spoom::Model::Reference]) }
  def references; end

  # : (Prism::AliasMethodNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#21
  sig { override.params(node: ::Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  # : (Prism::AndNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#27
  sig { override.params(node: ::Prism::AndNode).void }
  def visit_and_node(node); end

  # : (Prism::BlockArgumentNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#34
  sig { override.params(node: ::Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  # : (Prism::CallAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#46
  sig { override.params(node: ::Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  # : (Prism::CallNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#73
  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end

  # : (Prism::CallOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#55
  sig { override.params(node: ::Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  # : (Prism::CallOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#64
  sig { override.params(node: ::Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  # : (Prism::ClassNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#91
  sig { override.params(node: ::Prism::ClassNode).void }
  def visit_class_node(node); end

  # : (Prism::ConstantAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#98
  sig { override.params(node: ::Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  # : (Prism::ConstantOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#105
  sig { override.params(node: ::Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  # : (Prism::ConstantOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#112
  sig { override.params(node: ::Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  # : (Prism::ConstantPathNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#119
  sig { override.params(node: ::Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  # : (Prism::ConstantPathWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#126
  sig { override.params(node: ::Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # : (Prism::ConstantReadNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#133
  sig { override.params(node: ::Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  # : (Prism::ConstantWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#139
  sig { override.params(node: ::Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # : (Prism::LocalVariableAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#145
  sig { override.params(node: ::Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  # : (Prism::LocalVariableOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#154
  sig { override.params(node: ::Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  # : (Prism::LocalVariableOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#163
  sig { override.params(node: ::Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  # : (Prism::LocalVariableWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#172
  sig { override.params(node: ::Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  # : (Prism::ModuleNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#179
  sig { override.params(node: ::Prism::ModuleNode).void }
  def visit_module_node(node); end

  # : (Prism::MultiWriteNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#185
  sig { override.params(node: ::Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # : (Prism::OrNode node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#197
  sig { override.params(node: ::Prism::OrNode).void }
  def visit_or_node(node); end

  private

  # : (Prism::Node node) -> Location
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#215
  sig { params(node: ::Prism::Node).returns(::Spoom::Location) }
  def node_location(node); end

  # : (String name, Prism::Node node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#205
  sig { params(name: ::String, node: ::Prism::Node).void }
  def reference_constant(name, node); end

  # : (String name, Prism::Node node) -> void
  #
  # source://spoom//lib/spoom/model/references_visitor.rb#210
  sig { params(name: ::String, node: ::Prism::Node).void }
  def reference_method(name, node); end
end

# A Sorbet signature (sig block)
#
# source://spoom//lib/spoom/model/model.rb#215
class Spoom::Model::Sig
  # : (String string) -> void
  #
  # @return [Sig] a new instance of Sig
  #
  # source://spoom//lib/spoom/model/model.rb#220
  sig { params(string: ::String).void }
  def initialize(string); end

  # : String
  #
  # source://spoom//lib/spoom/model/model.rb#217
  sig { returns(::String) }
  def string; end
end

# source://spoom//lib/spoom/model/model.rb#130
class Spoom::Model::SingletonClass < ::Spoom::Model::Namespace; end

# A Symbol is a uniquely named entity in the Ruby codebase
#
# A symbol can have multiple definitions, e.g. a class can be reopened.
# Sometimes a symbol can have multiple definitions of different types,
# e.g. `foo` method can be defined both as a method and as an attribute accessor.
#
# source://spoom//lib/spoom/model/model.rb#27
# A Symbol is a uniquely named entity in the Ruby codebase
# A symbol can have multiple definitions, e.g. a class can be reopened.
# Sometimes a symbol can have multiple definitions of different types,
class Spoom::Model::Symbol
  # : (String full_name) -> void
  #
  # @return [Symbol] a new instance of Symbol
  #
  # source://spoom//lib/spoom/model/model.rb#37
  sig { params(full_name: ::String).void }
  def initialize(full_name); end

  # The definitions of this symbol (where it exists in the code)
  # : Array[SymbolDef]
  #
  # source://spoom//lib/spoom/model/model.rb#34
  # The definitions of this symbol (where it exists in the code)
  sig { returns(T::Array[::Spoom::Model::SymbolDef]) }
  def definitions; end

  # The full, unique name of this symbol
  # : String
  #
  # source://spoom//lib/spoom/model/model.rb#30
  # The full, unique name of this symbol
  sig { returns(::String) }
  def full_name; end

  # The short name of this symbol
  # : -> String
  #
  # source://spoom//lib/spoom/model/model.rb#44
  # The short name of this symbol
  sig { returns(::String) }
  def name; end

  # : -> String
  #
  # source://spoom//lib/spoom/model/model.rb#49
  sig { returns(::String) }
  def to_s; end
end

# A SymbolDef is a definition of a Symbol
#
# It can be a class, module, constant, method, etc.
# A SymbolDef has a location pointing to the actual code that defines the symbol.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom//lib/spoom/model/model.rb#66
# A SymbolDef is a definition of a Symbol
# It can be a class, module, constant, method, etc.
class Spoom::Model::SymbolDef
  abstract!

  # : (Symbol symbol, owner: Namespace?, location: Location, ?comments: Array[Comment]) -> void
  #
  # @return [SymbolDef] a new instance of SymbolDef
  #
  # source://spoom//lib/spoom/model/model.rb#88
  sig do
    params(
      symbol: ::Spoom::Model::Symbol,
      owner: T.nilable(::Spoom::Model::Namespace),
      location: ::Spoom::Location,
      comments: T::Array[::Spoom::Model::Comment]
    ).void
  end
  def initialize(symbol, owner:, location:, comments:); end

  # The comments associated with this definition
  # : Array[Comment]
  #
  # source://spoom//lib/spoom/model/model.rb#85
  # The comments associated with this definition
  sig { returns(T::Array[::Spoom::Model::Comment]) }
  def comments; end

  # The full name of the symbol this definition belongs to
  # : -> String
  #
  # source://spoom//lib/spoom/model/model.rb#100
  # The full name of the symbol this definition belongs to
  sig { returns(::String) }
  def full_name; end

  # The actual code location of this definition
  # : Location
  #
  # source://spoom//lib/spoom/model/model.rb#81
  # The actual code location of this definition
  sig { returns(::Spoom::Location) }
  def location; end

  # The short name of the symbol this definition belongs to
  # : -> String
  #
  # source://spoom//lib/spoom/model/model.rb#106
  # The short name of the symbol this definition belongs to
  sig { returns(::String) }
  def name; end

  # The enclosing namespace this definition belongs to
  # : Namespace?
  #
  # source://spoom//lib/spoom/model/model.rb#77
  # The enclosing namespace this definition belongs to
  sig { returns(T.nilable(::Spoom::Model::Namespace)) }
  def owner; end

  # The symbol this definition belongs to
  # : Symbol
  #
  # source://spoom//lib/spoom/model/model.rb#73
  # The symbol this definition belongs to
  sig { returns(::Spoom::Model::Symbol) }
  def symbol; end
end

# source://spoom//lib/spoom/model/model.rb#54
class Spoom::Model::UnresolvedSymbol < ::Spoom::Model::Symbol
  # : -> String
  #
  # source://spoom//lib/spoom/model/model.rb#57
  sig { override.returns(::String) }
  def to_s; end
end

# source://spoom//lib/spoom/model/model.rb#187
class Spoom::Model::Visibility < ::T::Enum
  enums do
    Private = new
    Protected = new
    Public = new
  end
end

# source://spoom//lib/spoom/parse.rb#7
class Spoom::ParseError < ::Spoom::Error; end

# A Poset is a set of elements with a partial order relation.
#
# The partial order relation is a binary relation that is reflexive, antisymmetric, and transitive.
# It can be used to represent a hierarchy of classes or modules, the dependencies between gems, etc.
#
# source://spoom//lib/spoom/poset.rb#9
# A Poset is a set of elements with a partial order relation.
# The partial order relation is a binary relation that is reflexive, antisymmetric, and transitive.
class Spoom::Poset
  extend T::Generic

  E = type_member { { upper: Object } }

  # : -> void
  #
  # @return [Poset] a new instance of Poset
  #
  # source://spoom//lib/spoom/poset.rb#17
  sig { void }
  def initialize; end

  # Get the POSet element for a given value
  #
  # Raises if the element is not found
  # : (E value) -> Element[E]
  #
  # @raise [Error]
  #
  # source://spoom//lib/spoom/poset.rb#25
  # Get the POSet element for a given value
  # Raises if the element is not found
  sig { params(value: E).returns(Spoom::Poset::Element[E]) }
  def [](value); end

  # Add a direct edge from one element to another
  #
  # Transitive edges (transitive closure) are automatically computed.
  # Adds the elements if they don't exist.
  # If the direct edge already exists, nothing is done.
  # : (E from, E to) -> void
  #
  # source://spoom//lib/spoom/poset.rb#53
  # Add a direct edge from one element to another
  # Transitive edges (transitive closure) are automatically computed.
  # Adds the elements if they don't exist.
  # If the direct edge already exists, nothing is done.
  sig { params(from: E, to: E).void }
  def add_direct_edge(from, to); end

  # Add an element to the POSet
  # : (E value) -> Element[E]
  #
  # source://spoom//lib/spoom/poset.rb#34
  # Add an element to the POSet
  sig { params(value: E).returns(Spoom::Poset::Element[E]) }
  def add_element(value); end

  # Is there a direct edge from `from` to `to`?
  # : (E from, E to) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/poset.rb#100
  # Is there a direct edge from `from` to `to`?
  sig { params(from: E, to: E).returns(T::Boolean) }
  def direct_edge?(from, to); end

  # Is there an edge (direct or indirect) from `from` to `to`?
  # : (E from, E to) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/poset.rb#91
  # Is there an edge (direct or indirect) from `from` to `to`?
  sig { params(from: E, to: E).returns(T::Boolean) }
  def edge?(from, to); end

  # Is the given value a element in the POSet?
  # : (E value) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/poset.rb#43
  # Is the given value a element in the POSet?
  sig { params(value: E).returns(T::Boolean) }
  def element?(value); end

  # Show the POSet as a DOT graph using xdot (used for debugging)
  # : (?direct: bool, ?transitive: bool) -> void
  #
  # source://spoom//lib/spoom/poset.rb#106
  # Show the POSet as a DOT graph using xdot (used for debugging)
  sig { params(direct: T::Boolean, transitive: T::Boolean).void }
  def show_dot(direct: T.unsafe(nil), transitive: T.unsafe(nil)); end

  # Return the POSet as a DOT graph
  # : (?direct: bool, ?transitive: bool) -> String
  #
  # source://spoom//lib/spoom/poset.rb#115
  # Return the POSet as a DOT graph
  sig { params(direct: T::Boolean, transitive: T::Boolean).returns(::String) }
  def to_dot(direct: T.unsafe(nil), transitive: T.unsafe(nil)); end
end

# An element in a POSet
#
# source://spoom//lib/spoom/poset.rb#135
class Spoom::Poset::Element
  extend T::Generic
  include ::Comparable

  E = type_member { { upper: Object } }

  # : (E value) -> void
  #
  # @return [Element] a new instance of Element
  #
  # source://spoom//lib/spoom/poset.rb#150
  sig { params(value: E).void }
  def initialize(value); end

  # : (untyped other) -> Integer?
  #
  # source://spoom//lib/spoom/poset.rb#159
  sig { params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # Direct and indirect ancestors of this element
  # : -> Array[E]
  #
  # source://spoom//lib/spoom/poset.rb#178
  # Direct and indirect ancestors of this element
  sig { returns(T::Array[E]) }
  def ancestors; end

  # Direct children of this element
  # : -> Array[E]
  #
  # source://spoom//lib/spoom/poset.rb#184
  # Direct children of this element
  sig { returns(T::Array[E]) }
  def children; end

  # Direct and indirect descendants of this element
  # : -> Array[E]
  #
  # source://spoom//lib/spoom/poset.rb#190
  # Direct and indirect descendants of this element
  sig { returns(T::Array[E]) }
  def descendants; end

  # Edges (direct and indirect) from this element to other elements in the same POSet
  # : Set[Element[E]]
  #
  # source://spoom//lib/spoom/poset.rb#147
  # Edges (direct and indirect) from this element to other elements in the same POSet
  # @return [Set<Element[E]>]
  def dfroms; end

  # Edges (direct and indirect) from this element to other elements in the same POSet
  # : Set[Element[E]]
  #
  # source://spoom//lib/spoom/poset.rb#147
  # Edges (direct and indirect) from this element to other elements in the same POSet
  sig { returns(T::Set[Spoom::Poset::Element[E]]) }
  def dtos; end

  # Edges (direct and indirect) from this element to other elements in the same POSet
  # : Set[Element[E]]
  #
  # source://spoom//lib/spoom/poset.rb#147
  # Edges (direct and indirect) from this element to other elements in the same POSet
  # @return [Set<Element[E]>]
  def froms; end

  # Direct parents of this element
  # : -> Array[E]
  #
  # source://spoom//lib/spoom/poset.rb#172
  # Direct parents of this element
  sig { returns(T::Array[E]) }
  def parents; end

  # Edges (direct and indirect) from this element to other elements in the same POSet
  # : Set[Element[E]]
  #
  # source://spoom//lib/spoom/poset.rb#147
  # Edges (direct and indirect) from this element to other elements in the same POSet
  # @return [Set<Element[E]>]
  def tos; end

  # The value held by this element
  # : E
  #
  # source://spoom//lib/spoom/poset.rb#143
  # The value held by this element
  sig { returns(E) }
  def value; end
end

# source://spoom//lib/spoom/poset.rb#12
class Spoom::Poset::Error < ::Spoom::Error; end

# source://spoom//lib/spoom/printer.rb#7
class Spoom::Printer
  include ::Spoom::Colorize

  # : (?out: (IO | StringIO), ?colors: bool, ?indent_level: Integer) -> void
  #
  # @return [Printer] a new instance of Printer
  #
  # source://spoom//lib/spoom/printer.rb#14
  sig { params(out: T.any(::IO, ::StringIO), colors: T::Boolean, indent_level: ::Integer).void }
  def initialize(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # Colorize `string` with color if `@colors`
  # : (String string, *Spoom::Color color) -> String
  #
  # source://spoom//lib/spoom/printer.rb#75
  # Colorize `string` with color if `@colors`
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def colorize(string, *color); end

  # Decrease indent level
  # : -> void
  #
  # source://spoom//lib/spoom/printer.rb#28
  # Decrease indent level
  sig { void }
  def dedent; end

  # Increase indent level
  # : -> void
  #
  # source://spoom//lib/spoom/printer.rb#22
  # Increase indent level
  sig { void }
  def indent; end

  # : (IO | StringIO)
  #
  # source://spoom//lib/spoom/printer.rb#11
  sig { returns(T.any(::IO, ::StringIO)) }
  def out; end

  # : (IO | StringIO)
  #
  # source://spoom//lib/spoom/printer.rb#11
  # @return [IO, StringIO]
  def out=(_arg0); end

  # Print `string` into `out`
  # : (String? string) -> void
  #
  # source://spoom//lib/spoom/printer.rb#34
  # Print `string` into `out`
  sig { params(string: T.nilable(::String)).void }
  def print(string); end

  # Print `string` colored with `color` into `out`
  #
  # Does not use colors unless `@colors`.
  # : (String? string, *Color color) -> void
  #
  # source://spoom//lib/spoom/printer.rb#44
  # Print `string` colored with `color` into `out`
  # Does not use colors unless `@colors`.
  sig { params(string: T.nilable(::String), color: ::Spoom::Color).void }
  def print_colored(string, *color); end

  # Print `string` with indent and newline
  # : (String? string) -> void
  #
  # source://spoom//lib/spoom/printer.rb#59
  # Print `string` with indent and newline
  sig { params(string: T.nilable(::String)).void }
  def printl(string); end

  # Print a new line into `out`
  # : -> void
  #
  # source://spoom//lib/spoom/printer.rb#53
  # Print a new line into `out`
  sig { void }
  def printn; end

  # Print an indent space into `out`
  # : -> void
  #
  # source://spoom//lib/spoom/printer.rb#69
  # Print an indent space into `out`
  sig { void }
  def printt; end
end

# source://spoom//lib/spoom.rb#8
Spoom::SPOOM_PATH = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/assertions.rb#7
module Spoom::Sorbet; end

# source://spoom//lib/spoom/sorbet/assertions.rb#8
class Spoom::Sorbet::Assertions
  class << self
    # : (String, file: String) -> String
    #
    # source://spoom//lib/spoom/sorbet/assertions.rb#11
    sig { params(ruby_contents: ::String, file: ::String).returns(::String) }
    def rbi_to_rbs(ruby_contents, file:); end

    private

    # : (String, file: String) -> Array[AssignNode]
    #
    # source://spoom//lib/spoom/sorbet/assertions.rb#46
    sig { params(ruby_contents: ::String, file: ::String).returns(T::Array[::Spoom::Sorbet::Assertions::AssignNode]) }
    def collect_assigns(ruby_contents, file:); end

    # : (AssignNode) -> String
    #
    # source://spoom//lib/spoom/sorbet/assertions.rb#54
    sig { params(assign: ::Spoom::Sorbet::Assertions::AssignNode).returns(::String) }
    def dedent_value(assign); end
  end
end

# source://spoom//lib/spoom/sorbet/assertions.rb#122
class Spoom::Sorbet::Assertions::AssignNode
  # : (AssignType, Prism::Location, Prism::Node, Prism::Node) -> void
  #
  # @return [AssignNode] a new instance of AssignNode
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#133
  sig do
    params(
      node: T.any(::Prism::ClassVariableAndWriteNode, ::Prism::ClassVariableOperatorWriteNode, ::Prism::ClassVariableOrWriteNode, ::Prism::ClassVariableWriteNode, ::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode, ::Prism::GlobalVariableAndWriteNode, ::Prism::GlobalVariableOperatorWriteNode, ::Prism::GlobalVariableOrWriteNode, ::Prism::GlobalVariableWriteNode, ::Prism::InstanceVariableAndWriteNode, ::Prism::InstanceVariableOperatorWriteNode, ::Prism::InstanceVariableOrWriteNode, ::Prism::InstanceVariableWriteNode, ::Prism::LocalVariableAndWriteNode, ::Prism::LocalVariableOperatorWriteNode, ::Prism::LocalVariableOrWriteNode, ::Prism::LocalVariableWriteNode),
      operator_loc: ::Prism::Location,
      value: ::Prism::Node,
      type: ::Prism::Node
    ).void
  end
  def initialize(node, operator_loc, value, type); end

  # : AssignType
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#124
  sig do
    returns(T.any(::Prism::ClassVariableAndWriteNode, ::Prism::ClassVariableOperatorWriteNode, ::Prism::ClassVariableOrWriteNode, ::Prism::ClassVariableWriteNode, ::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode, ::Prism::GlobalVariableAndWriteNode, ::Prism::GlobalVariableOperatorWriteNode, ::Prism::GlobalVariableOrWriteNode, ::Prism::GlobalVariableWriteNode, ::Prism::InstanceVariableAndWriteNode, ::Prism::InstanceVariableOperatorWriteNode, ::Prism::InstanceVariableOrWriteNode, ::Prism::InstanceVariableWriteNode, ::Prism::LocalVariableAndWriteNode, ::Prism::LocalVariableOperatorWriteNode, ::Prism::LocalVariableOrWriteNode, ::Prism::LocalVariableWriteNode))
  end
  def node; end

  # : Prism::Location
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#127
  sig { returns(::Prism::Location) }
  def operator_loc; end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#141
  sig { returns(::String) }
  def rbs_type; end

  # : Prism::Node
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#130
  # @return [Prism::Node]
  def type; end

  # : Prism::Node
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#130
  sig { returns(::Prism::Node) }
  def value; end
end

# source://spoom//lib/spoom/sorbet/assertions.rb#93
Spoom::Sorbet::Assertions::AssignType = T.type_alias { T.any(::Prism::ClassVariableAndWriteNode, ::Prism::ClassVariableOperatorWriteNode, ::Prism::ClassVariableOrWriteNode, ::Prism::ClassVariableWriteNode, ::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode, ::Prism::GlobalVariableAndWriteNode, ::Prism::GlobalVariableOperatorWriteNode, ::Prism::GlobalVariableOrWriteNode, ::Prism::GlobalVariableWriteNode, ::Prism::InstanceVariableAndWriteNode, ::Prism::InstanceVariableOperatorWriteNode, ::Prism::InstanceVariableOrWriteNode, ::Prism::InstanceVariableWriteNode, ::Prism::LocalVariableAndWriteNode, ::Prism::LocalVariableOperatorWriteNode, ::Prism::LocalVariableOrWriteNode, ::Prism::LocalVariableWriteNode) }

# source://spoom//lib/spoom/sorbet/assertions.rb#146
class Spoom::Sorbet::Assertions::Locator < ::Spoom::Visitor
  # : -> void
  #
  # @return [Locator] a new instance of Locator
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#153
  sig { void }
  def initialize; end

  # : Array[AssignNode]
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#150
  sig { returns(T::Array[::Spoom::Sorbet::Assertions::AssignNode]) }
  def assigns; end

  # : (Prism::Node) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#245
  sig { params(node: ::Prism::Node).returns(T::Boolean) }
  def contains_heredoc?(node); end

  # Is this node a `T` or `::T` constant?
  # : (Prism::Node?) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#223
  # Is this node a `T` or `::T` constant?
  sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
  def t?(node); end

  # Is this node a `T.let` or `T.cast`?
  # : (Prism::CallNode) -> bool
  #
  # @return [Boolean]
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#236
  # Is this node a `T.let` or `T.cast`?
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def t_annotation?(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  sig do
    params(
      node: T.any(::Prism::ClassVariableAndWriteNode, ::Prism::ClassVariableOperatorWriteNode, ::Prism::ClassVariableOrWriteNode, ::Prism::ClassVariableWriteNode, ::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode, ::Prism::GlobalVariableAndWriteNode, ::Prism::GlobalVariableOperatorWriteNode, ::Prism::GlobalVariableOrWriteNode, ::Prism::GlobalVariableWriteNode, ::Prism::InstanceVariableAndWriteNode, ::Prism::InstanceVariableOperatorWriteNode, ::Prism::InstanceVariableOrWriteNode, ::Prism::InstanceVariableWriteNode, ::Prism::LocalVariableAndWriteNode, ::Prism::LocalVariableOperatorWriteNode, ::Prism::LocalVariableOrWriteNode, ::Prism::LocalVariableWriteNode)
    ).void
  end
  def visit_assign(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_class_variable_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_class_variable_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_class_variable_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_class_variable_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_path_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_path_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_path_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_path_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_constant_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_global_variable_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_global_variable_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_global_variable_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_global_variable_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_instance_variable_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_instance_variable_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_instance_variable_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_instance_variable_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_local_variable_and_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_local_variable_operator_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_local_variable_or_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_local_variable_write_node(node); end

  # : (AssignType) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#159
  def visit_multi_write_node(node); end
end

# source://spoom//lib/spoom/sorbet/assertions.rb#147
Spoom::Sorbet::Assertions::Locator::ANNOTATION_METHODS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/sorbet/assertions.rb#251
class Spoom::Sorbet::Assertions::Locator::HeredocVisitor < ::Spoom::Visitor
  # : -> void
  #
  # @return [HeredocVisitor] a new instance of HeredocVisitor
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#256
  sig { void }
  def initialize; end

  # : bool
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#253
  sig { returns(T::Boolean) }
  def contains_heredoc; end

  # : (Prism::Node?) -> void
  #
  # source://spoom//lib/spoom/sorbet/assertions.rb#264
  sig { override.params(node: T.nilable(::Prism::Node)).void }
  def visit(node); end
end

# source://spoom//lib/spoom/sorbet.rb#33
Spoom::Sorbet::BIN_PATH = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet.rb#30
Spoom::Sorbet::CONFIG_PATH = T.let(T.unsafe(nil), String)

# Parse Sorbet config files
#
# Parses a Sorbet config file:
#
# ```ruby
# config = Spoom::Sorbet::Config.parse_file("sorbet/config")
# puts config.paths   # "."
# ```
#
# Parses a Sorbet config string:
#
# ```ruby
# config = Spoom::Sorbet::Config.parse_string(<<~CONFIG)
#   a
#   --file=b
#   --ignore=c
# CONFIG
# puts config.paths   # "a", "b"
# puts config.ignore  # "c"
# ```
#
# source://spoom//lib/spoom/sorbet/config.rb#26
# Parse Sorbet config files
# Parses a Sorbet config file:
# ```ruby
# config = Spoom::Sorbet::Config.parse_file("sorbet/config")
# puts config.paths   # "."
# Parses a Sorbet config string:
# config = Spoom::Sorbet::Config.parse_string(<<~CONFIG)
#   a
#   --file=b
#   --ignore=c
# CONFIG
# puts config.paths   # "a", "b"
# puts config.ignore  # "c"
class Spoom::Sorbet::Config
  # : -> void
  #
  # @return [Config] a new instance of Config
  #
  # source://spoom//lib/spoom/sorbet/config.rb#36
  sig { void }
  def initialize; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  # @return [Array<String>]
  def allowed_extensions; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  # @return [Array<String>]
  def allowed_extensions=(_arg0); end

  # : -> Config
  #
  # source://spoom//lib/spoom/sorbet/config.rb#44
  sig { returns(::Spoom::Sorbet::Config) }
  def copy; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  # @return [Array<String>]
  def ignore; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  # @return [Array<String>]
  def ignore=(_arg0); end

  # : bool
  #
  # source://spoom//lib/spoom/sorbet/config.rb#33
  sig { returns(T::Boolean) }
  def no_stdlib; end

  # : bool
  #
  # source://spoom//lib/spoom/sorbet/config.rb#33
  # @return [Boolean]
  def no_stdlib=(_arg0); end

  # Returns self as a string of options that can be passed to Sorbet
  #
  # Example:
  # ~~~rb
  # config = Sorbet::Config.new
  # config.paths << "/foo"
  # config.paths << "/bar"
  # config.ignore << "/baz"
  # config.allowed_extensions << ".rb"
  #
  # puts config.options_string # "/foo /bar --ignore /baz --allowed-extension .rb"
  # ~~~
  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/config.rb#66
  # Returns self as a string of options that can be passed to Sorbet
  # Example:
  # ~~~rb
  # config = Sorbet::Config.new
  # config.paths << "/foo"
  # config.paths << "/bar"
  # config.ignore << "/baz"
  # config.allowed_extensions << ".rb"
  # puts config.options_string # "/foo /bar --ignore /baz --allowed-extension .rb"
  # ~~~
  sig { returns(::String) }
  def options_string; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  sig { returns(T::Array[::String]) }
  def paths; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/config.rb#30
  # @return [Array<String>]
  def paths=(_arg0); end

  class << self
    # : (String sorbet_config_path) -> Spoom::Sorbet::Config
    #
    # source://spoom//lib/spoom/sorbet/config.rb#77
    sig { params(sorbet_config_path: ::String).returns(::Spoom::Sorbet::Config) }
    def parse_file(sorbet_config_path); end

    # : (String sorbet_config) -> Spoom::Sorbet::Config
    #
    # source://spoom//lib/spoom/sorbet/config.rb#82
    sig { params(sorbet_config: ::String).returns(::Spoom::Sorbet::Config) }
    def parse_string(sorbet_config); end

    private

    # : (String line) -> String
    #
    # source://spoom//lib/spoom/sorbet/config.rb#143
    sig { params(line: ::String).returns(::String) }
    def parse_option(line); end
  end
end

# source://spoom//lib/spoom/sorbet/config.rb#27
Spoom::Sorbet::Config::DEFAULT_ALLOWED_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/sorbet.rb#15
class Spoom::Sorbet::Error < ::Spoom::Error
  # : (String message, ExecResult result) -> void
  #
  # @return [Error] a new instance of Error
  #
  # source://spoom//lib/spoom/sorbet.rb#23
  sig { params(message: ::String, result: ::Spoom::ExecResult).void }
  def initialize(message, result); end

  # : ExecResult
  #
  # source://spoom//lib/spoom/sorbet.rb#20
  sig { returns(::Spoom::ExecResult) }
  def result; end
end

# source://spoom//lib/spoom/sorbet.rb#16
class Spoom::Sorbet::Error::Killed < ::Spoom::Sorbet::Error; end

# source://spoom//lib/spoom/sorbet.rb#17
class Spoom::Sorbet::Error::Segfault < ::Spoom::Sorbet::Error; end

# source://spoom//lib/spoom/sorbet/errors.rb#6
module Spoom::Sorbet::Errors
  class << self
    # : (Array[Error] errors) -> Array[Error]
    #
    # source://spoom//lib/spoom/sorbet/errors.rb#11
    sig { params(errors: T::Array[::Spoom::Sorbet::Errors::Error]).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
    def sort_errors_by_code(errors); end
  end
end

# source://spoom//lib/spoom/sorbet/errors.rb#7
Spoom::Sorbet::Errors::DEFAULT_ERROR_URL_BASE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/errors.rb#121
class Spoom::Sorbet::Errors::Error
  include ::Comparable

  # : (String? file, Integer? line, String? message, Integer? code, ?Array[String] more) -> void
  #
  # @return [Error] a new instance of Error
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#138
  sig do
    params(
      file: T.nilable(::String),
      line: T.nilable(::Integer),
      message: T.nilable(::String),
      code: T.nilable(::Integer),
      more: T::Array[::String]
    ).void
  end
  def initialize(file, line, message, code, more = T.unsafe(nil)); end

  # By default errors are sorted by location
  # : (untyped other) -> Integer
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#149
  # By default errors are sorted by location
  sig { params(other: T.untyped).returns(::Integer) }
  def <=>(other); end

  # : Integer?
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#128
  # @return [Integer, nil]
  def code; end

  # : String?
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#125
  sig { returns(T.nilable(::String)) }
  def file; end

  # Other files associated with the error
  # : Set[String]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#135
  # Other files associated with the error
  sig { returns(T::Set[::String]) }
  def files_from_error_sections; end

  # : Integer?
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#128
  sig { returns(T.nilable(::Integer)) }
  def line; end

  # : String?
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#125
  # @return [String, nil]
  def message; end

  # : Array[String]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#131
  sig { returns(T::Array[::String]) }
  def more; end

  # : -> String
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#156
  sig { returns(::String) }
  def to_s; end
end

# Parse errors from Sorbet output
#
# source://spoom//lib/spoom/sorbet/errors.rb#16
class Spoom::Sorbet::Errors::Parser
  # : (?error_url_base: String) -> void
  #
  # @return [Parser] a new instance of Parser
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#39
  sig { params(error_url_base: ::String).void }
  def initialize(error_url_base: T.unsafe(nil)); end

  # : (String output) -> Array[Error]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#46
  sig { params(output: ::String).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
  def parse(output); end

  private

  # : (String line) -> void
  #
  # @raise [ParseError]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#110
  sig { params(line: ::String).void }
  def append_error(line); end

  # : -> void
  #
  # @raise [ParseError]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#102
  sig { void }
  def close_error; end

  # : (String error_url_base) -> Regexp
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#69
  sig { params(error_url_base: ::String).returns(::Regexp) }
  def error_line_match_regexp(error_url_base); end

  # : (String line) -> Error?
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#86
  sig { params(line: ::String).returns(T.nilable(::Spoom::Sorbet::Errors::Error)) }
  def match_error_line(line); end

  # : (Error error) -> void
  #
  # @raise [ParseError]
  #
  # source://spoom//lib/spoom/sorbet/errors.rb#95
  sig { params(error: ::Spoom::Sorbet::Errors::Error).void }
  def open_error(error); end

  class << self
    # : (String output, ?error_url_base: String) -> Array[Error]
    #
    # source://spoom//lib/spoom/sorbet/errors.rb#32
    sig { params(output: ::String, error_url_base: ::String).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
    def parse_string(output, error_url_base: T.unsafe(nil)); end
  end
end

# source://spoom//lib/spoom/sorbet/errors.rb#19
Spoom::Sorbet::Errors::Parser::HEADER = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/sorbet/errors.rb#17
class Spoom::Sorbet::Errors::Parser::ParseError < ::Spoom::Error; end

# source://spoom//lib/spoom/sorbet.rb#31
Spoom::Sorbet::GEM_PATH = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet.rb#32
Spoom::Sorbet::GEM_VERSION = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet.rb#35
Spoom::Sorbet::KILLED_CODE = T.let(T.unsafe(nil), Integer)

# source://spoom//lib/spoom/sorbet/metrics.rb#8
module Spoom::Sorbet::MetricsParser
  class << self
    # : (String path, ?String prefix) -> Hash[String, Integer]
    #
    # source://spoom//lib/spoom/sorbet/metrics.rb#13
    sig { params(path: ::String, prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_file(path, prefix = T.unsafe(nil)); end

    # : (Hash[String, untyped] obj, ?String prefix) -> Hash[String, Integer]
    #
    # source://spoom//lib/spoom/sorbet/metrics.rb#23
    sig { params(obj: T::Hash[::String, T.untyped], prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_hash(obj, prefix = T.unsafe(nil)); end

    # : (String string, ?String prefix) -> Hash[String, Integer]
    #
    # source://spoom//lib/spoom/sorbet/metrics.rb#18
    sig { params(string: ::String, prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_string(string, prefix = T.unsafe(nil)); end
  end
end

# source://spoom//lib/spoom/sorbet/metrics.rb#9
Spoom::Sorbet::MetricsParser::DEFAULT_PREFIX = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet.rb#36
Spoom::Sorbet::SEGFAULT_CODE = T.let(T.unsafe(nil), Integer)

# source://spoom//lib/spoom/sorbet/sigils.rb#9
module Spoom::Sorbet::Sigils
  class << self
    # changes the sigil in the file at the passed path to the specified new strictness
    # : ((String | Pathname) path, String new_strictness) -> bool
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#68
    # changes the sigil in the file at the passed path to the specified new strictness
    sig { params(path: T.any(::Pathname, ::String), new_strictness: ::String).returns(T::Boolean) }
    def change_sigil_in_file(path, new_strictness); end

    # changes the sigil to have a new strictness in a list of files
    # : (Array[String] path_list, String new_strictness) -> Array[String]
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#79
    # changes the sigil to have a new strictness in a list of files
    sig { params(path_list: T::Array[::String], new_strictness: ::String).returns(T::Array[::String]) }
    def change_sigil_in_files(path_list, new_strictness); end

    # returns a string containing the strictness of a sigil in a file at the passed path
    # * returns nil if no sigil
    # : ((String | Pathname) path) -> String?
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#59
    # returns a string containing the strictness of a sigil in a file at the passed path
    # * returns nil if no sigil
    sig { params(path: T.any(::Pathname, ::String)).returns(T.nilable(::String)) }
    def file_strictness(path); end

    # returns the full sigil comment string for the passed strictness
    # : (String strictness) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#34
    # returns the full sigil comment string for the passed strictness
    sig { params(strictness: ::String).returns(::String) }
    def sigil_string(strictness); end

    # returns the strictness of a sigil in the passed file content string (nil if no sigil)
    # : (String content) -> String?
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#46
    # returns the strictness of a sigil in the passed file content string (nil if no sigil)
    sig { params(content: ::String).returns(T.nilable(::String)) }
    def strictness_in_content(content); end

    # returns a string which is the passed content but with the sigil updated to a new strictness
    # : (String content, String new_strictness) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#52
    # returns a string which is the passed content but with the sigil updated to a new strictness
    sig { params(content: ::String, new_strictness: ::String).returns(::String) }
    def update_sigil(content, new_strictness); end

    # returns true if the passed string is a valid strictness (else false)
    # : (String strictness) -> bool
    #
    # @return [Boolean]
    #
    # source://spoom//lib/spoom/sorbet/sigils.rb#40
    # returns true if the passed string is a valid strictness (else false)
    sig { params(strictness: ::String).returns(T::Boolean) }
    def valid_strictness?(strictness); end
  end
end

# source://spoom//lib/spoom/sorbet/sigils.rb#29
Spoom::Sorbet::Sigils::SIGIL_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://spoom//lib/spoom/sorbet/sigils.rb#11
Spoom::Sorbet::Sigils::STRICTNESS_FALSE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#10
Spoom::Sorbet::Sigils::STRICTNESS_IGNORE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#15
Spoom::Sorbet::Sigils::STRICTNESS_INTERNAL = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#13
Spoom::Sorbet::Sigils::STRICTNESS_STRICT = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#14
Spoom::Sorbet::Sigils::STRICTNESS_STRONG = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#12
Spoom::Sorbet::Sigils::STRICTNESS_TRUE = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/sorbet/sigils.rb#17
Spoom::Sorbet::Sigils::VALID_STRICTNESS = T.let(T.unsafe(nil), Array)

# source://spoom//lib/spoom/sorbet/sigs.rb#8
class Spoom::Sorbet::Sigs
  class << self
    # : (String ruby_contents, positional_names: bool) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#24
    sig { params(ruby_contents: ::String, positional_names: T::Boolean).returns(::String) }
    def rbi_to_rbs(ruby_contents, positional_names: T.unsafe(nil)); end

    # : (String ruby_contents) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#46
    sig { params(ruby_contents: ::String).returns(::String) }
    def rbs_to_rbi(ruby_contents); end

    # : (String ruby_contents) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#12
    sig { params(ruby_contents: ::String).returns(::String) }
    def strip(ruby_contents); end

    private

    # : (String ruby_contents) -> Array[[RBI::RBSComment, (RBI::Method | RBI::Attr)]]
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#80
    sig { params(ruby_contents: ::String).returns(T::Array[[::RBI::RBSComment, T.any(::RBI::Attr, ::RBI::Method)]]) }
    def collect_rbs_comments(ruby_contents); end

    # : (String ruby_contents) -> Array[[RBI::Sig, (RBI::Method | RBI::Attr)]]
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#72
    sig { params(ruby_contents: ::String).returns(T::Array[[::RBI::Sig, T.any(::RBI::Attr, ::RBI::Method)]]) }
    def collect_sorbet_sigs(ruby_contents); end
  end
end

# source://spoom//lib/spoom/sorbet/sigs.rb#9
class Spoom::Sorbet::Sigs::Error < ::Spoom::Error; end

# source://spoom//lib/spoom/sorbet/sigs.rb#123
class Spoom::Sorbet::Sigs::RBIToRBSTranslator
  class << self
    # : (RBI::Sig sig, (RBI::Method | RBI::Attr) node, positional_names: bool) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#126
    sig do
      params(
        sig: ::RBI::Sig,
        node: T.any(::RBI::Attr, ::RBI::Method),
        positional_names: T::Boolean
      ).returns(::String)
    end
    def translate(sig, node, positional_names: T.unsafe(nil)); end

    private

    # : (RBI::Sig sig, RBI::Attr node, positional_names: bool) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#173
    sig { params(sig: ::RBI::Sig, node: ::RBI::Attr, positional_names: T::Boolean).returns(::String) }
    def translate_attr_sig(sig, node, positional_names: T.unsafe(nil)); end

    # : (RBI::Sig sig, RBI::Method node, positional_names: bool) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#138
    sig { params(sig: ::RBI::Sig, node: ::RBI::Method, positional_names: T::Boolean).returns(::String) }
    def translate_method_sig(sig, node, positional_names: T.unsafe(nil)); end
  end
end

# source://spoom//lib/spoom/sorbet/sigs.rb#182
class Spoom::Sorbet::Sigs::RBSToRBITranslator
  class << self
    # : (RBI::RBSComment comment, (RBI::Method | RBI::Attr) node) -> String?
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#187
    sig { params(comment: ::RBI::RBSComment, node: T.any(::RBI::Attr, ::RBI::Method)).returns(T.nilable(::String)) }
    def translate(comment, node); end

    private

    # : (RBI::RBSComment comment, RBI::Attr node) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#228
    sig { params(comment: ::RBI::RBSComment, node: ::RBI::Attr).returns(::String) }
    def translate_attr_sig(comment, node); end

    # : (RBI::RBSComment rbs_comment, RBI::Method node) -> String
    #
    # source://spoom//lib/spoom/sorbet/sigs.rb#201
    sig { params(rbs_comment: ::RBI::RBSComment, node: ::RBI::Method).returns(::String) }
    def translate_method_sig(rbs_comment, node); end
  end
end

# From https://github.com/Shopify/ruby-lsp/blob/9154bfc6ef/lib/ruby_lsp/document.rb#L127
#
# source://spoom//lib/spoom/sorbet/sigs.rb#248
class Spoom::Sorbet::Sigs::Scanner
  # : (String source) -> void
  #
  # @return [Scanner] a new instance of Scanner
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#252
  sig { params(source: ::String).void }
  def initialize(source); end

  # Finds the character index inside the source string for a given line and column
  # : (Integer line, Integer character) -> Integer
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#260
  # Finds the character index inside the source string for a given line and column
  sig { params(line: ::Integer, character: ::Integer).returns(::Integer) }
  def find_char_position(line, character); end
end

# source://spoom//lib/spoom/sorbet/sigs.rb#249
Spoom::Sorbet::Sigs::Scanner::LINE_BREAK = T.let(T.unsafe(nil), Integer)

# source://spoom//lib/spoom/sorbet/sigs.rb#88
class Spoom::Sorbet::Sigs::SigsLocator < ::RBI::Visitor
  # : -> void
  #
  # @return [SigsLocator] a new instance of SigsLocator
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#96
  sig { void }
  def initialize; end

  # : Array[[RBI::RBSComment, (RBI::Method | RBI::Attr)]]
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#93
  sig { returns(T::Array[[::RBI::RBSComment, T.any(::RBI::Attr, ::RBI::Method)]]) }
  def rbs_comments; end

  # : Array[[RBI::Sig, (RBI::Method | RBI::Attr)]]
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#90
  sig { returns(T::Array[[::RBI::Sig, T.any(::RBI::Attr, ::RBI::Method)]]) }
  def sigs; end

  # : (RBI::Node? node) -> void
  #
  # source://spoom//lib/spoom/sorbet/sigs.rb#104
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

# source://spoom//lib/spoom/timeline.rb#5
class Spoom::Timeline
  # : (Context context, Time from, Time to) -> void
  #
  # @return [Timeline] a new instance of Timeline
  #
  # source://spoom//lib/spoom/timeline.rb#7
  sig { params(context: ::Spoom::Context, from: ::Time, to: ::Time).void }
  def initialize(context, from, to); end

  # Return one commit for each date in `dates`
  # : (Array[Time] dates) -> Array[Git::Commit]
  #
  # source://spoom//lib/spoom/timeline.rb#34
  # Return one commit for each date in `dates`
  sig { params(dates: T::Array[::Time]).returns(T::Array[::Spoom::Git::Commit]) }
  def commits_for_dates(dates); end

  # Return all months between `from` and `to`
  # : -> Array[Time]
  #
  # source://spoom//lib/spoom/timeline.rb#21
  # Return all months between `from` and `to`
  sig { returns(T::Array[::Time]) }
  def months; end

  # Return one commit for each month between `from` and `to`
  # : -> Array[Git::Commit]
  #
  # source://spoom//lib/spoom/timeline.rb#15
  # Return one commit for each month between `from` and `to`
  sig { returns(T::Array[::Spoom::Git::Commit]) }
  def ticks; end
end

# source://spoom//lib/spoom/version.rb#5
Spoom::VERSION = T.let(T.unsafe(nil), String)

# source://spoom//lib/spoom/visitor.rb#7
class Spoom::Visitor < ::Prism::Visitor
  # : (Prism::AliasGlobalVariableNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#16
  sig { override.params(node: ::Prism::AliasGlobalVariableNode).void }
  def visit_alias_global_variable_node(node); end

  # : (Prism::AliasMethodNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#22
  sig { override.params(node: ::Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  # : (Prism::AlternationPatternNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#28
  sig { override.params(node: ::Prism::AlternationPatternNode).void }
  def visit_alternation_pattern_node(node); end

  # : (Prism::AndNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#34
  sig { override.params(node: ::Prism::AndNode).void }
  def visit_and_node(node); end

  # : (Prism::ArgumentsNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#40
  sig { override.params(node: ::Prism::ArgumentsNode).void }
  def visit_arguments_node(node); end

  # : (Prism::ArrayNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#46
  sig { override.params(node: ::Prism::ArrayNode).void }
  def visit_array_node(node); end

  # : (Prism::ArrayPatternNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#52
  sig { override.params(node: ::Prism::ArrayPatternNode).void }
  def visit_array_pattern_node(node); end

  # : (Prism::AssocNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#58
  sig { override.params(node: ::Prism::AssocNode).void }
  def visit_assoc_node(node); end

  # : (Prism::AssocSplatNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#64
  sig { override.params(node: ::Prism::AssocSplatNode).void }
  def visit_assoc_splat_node(node); end

  # : (Prism::BackReferenceReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#70
  sig { override.params(node: ::Prism::BackReferenceReadNode).void }
  def visit_back_reference_read_node(node); end

  # : (Prism::BeginNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#76
  sig { override.params(node: ::Prism::BeginNode).void }
  def visit_begin_node(node); end

  # : (Prism::BlockArgumentNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#82
  sig { override.params(node: ::Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  # : (Prism::BlockLocalVariableNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#88
  sig { override.params(node: ::Prism::BlockLocalVariableNode).void }
  def visit_block_local_variable_node(node); end

  # : (Prism::BlockNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#94
  sig { override.params(node: ::Prism::BlockNode).void }
  def visit_block_node(node); end

  # : (Prism::BlockParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#100
  sig { override.params(node: ::Prism::BlockParameterNode).void }
  def visit_block_parameter_node(node); end

  # : (Prism::BlockParametersNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#106
  sig { override.params(node: ::Prism::BlockParametersNode).void }
  def visit_block_parameters_node(node); end

  # : (Prism::BreakNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#112
  sig { override.params(node: ::Prism::BreakNode).void }
  def visit_break_node(node); end

  # : (Prism::CallAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#118
  sig { override.params(node: ::Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  # : (Prism::CallNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#124
  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end

  # : (Prism::CallOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#130
  sig { override.params(node: ::Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  # : (Prism::CallOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#136
  sig { override.params(node: ::Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  # : (Prism::CallTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#142
  sig { override.params(node: ::Prism::CallTargetNode).void }
  def visit_call_target_node(node); end

  # : (Prism::CapturePatternNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#148
  sig { override.params(node: ::Prism::CapturePatternNode).void }
  def visit_capture_pattern_node(node); end

  # : (Prism::CaseMatchNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#154
  sig { override.params(node: ::Prism::CaseMatchNode).void }
  def visit_case_match_node(node); end

  # : (Prism::CaseNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#160
  sig { override.params(node: ::Prism::CaseNode).void }
  def visit_case_node(node); end

  # : (Prism::Node node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#10
  sig { override.params(node: ::Prism::Node).void }
  def visit_child_nodes(node); end

  # : (Prism::ClassNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#166
  sig { override.params(node: ::Prism::ClassNode).void }
  def visit_class_node(node); end

  # : (Prism::ClassVariableAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#172
  sig { override.params(node: ::Prism::ClassVariableAndWriteNode).void }
  def visit_class_variable_and_write_node(node); end

  # : (Prism::ClassVariableOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#178
  sig { override.params(node: ::Prism::ClassVariableOperatorWriteNode).void }
  def visit_class_variable_operator_write_node(node); end

  # : (Prism::ClassVariableOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#184
  sig { override.params(node: ::Prism::ClassVariableOrWriteNode).void }
  def visit_class_variable_or_write_node(node); end

  # : (Prism::ClassVariableReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#190
  sig { override.params(node: ::Prism::ClassVariableReadNode).void }
  def visit_class_variable_read_node(node); end

  # : (Prism::ClassVariableTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#196
  sig { override.params(node: ::Prism::ClassVariableTargetNode).void }
  def visit_class_variable_target_node(node); end

  # : (Prism::ClassVariableWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#202
  sig { override.params(node: ::Prism::ClassVariableWriteNode).void }
  def visit_class_variable_write_node(node); end

  # : (Prism::ConstantAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#208
  sig { override.params(node: ::Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  # : (Prism::ConstantOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#214
  sig { override.params(node: ::Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  # : (Prism::ConstantOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#220
  sig { override.params(node: ::Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  # : (Prism::ConstantPathAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#226
  sig { override.params(node: ::Prism::ConstantPathAndWriteNode).void }
  def visit_constant_path_and_write_node(node); end

  # : (Prism::ConstantPathNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#232
  sig { override.params(node: ::Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  # : (Prism::ConstantPathOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#238
  sig { override.params(node: ::Prism::ConstantPathOperatorWriteNode).void }
  def visit_constant_path_operator_write_node(node); end

  # : (Prism::ConstantPathOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#244
  sig { override.params(node: ::Prism::ConstantPathOrWriteNode).void }
  def visit_constant_path_or_write_node(node); end

  # : (Prism::ConstantPathTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#250
  sig { override.params(node: ::Prism::ConstantPathTargetNode).void }
  def visit_constant_path_target_node(node); end

  # : (Prism::ConstantPathWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#256
  sig { override.params(node: ::Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # : (Prism::ConstantReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#262
  sig { override.params(node: ::Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  # : (Prism::ConstantTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#268
  sig { override.params(node: ::Prism::ConstantTargetNode).void }
  def visit_constant_target_node(node); end

  # : (Prism::ConstantWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#274
  sig { override.params(node: ::Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # : (Prism::DefNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#280
  sig { override.params(node: ::Prism::DefNode).void }
  def visit_def_node(node); end

  # : (Prism::DefinedNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#286
  sig { override.params(node: ::Prism::DefinedNode).void }
  def visit_defined_node(node); end

  # : (Prism::ElseNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#292
  sig { override.params(node: ::Prism::ElseNode).void }
  def visit_else_node(node); end

  # : (Prism::EmbeddedStatementsNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#298
  sig { override.params(node: ::Prism::EmbeddedStatementsNode).void }
  def visit_embedded_statements_node(node); end

  # : (Prism::EmbeddedVariableNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#304
  sig { override.params(node: ::Prism::EmbeddedVariableNode).void }
  def visit_embedded_variable_node(node); end

  # : (Prism::EnsureNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#310
  sig { override.params(node: ::Prism::EnsureNode).void }
  def visit_ensure_node(node); end

  # : (Prism::FalseNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#316
  sig { override.params(node: ::Prism::FalseNode).void }
  def visit_false_node(node); end

  # : (Prism::FindPatternNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#322
  sig { override.params(node: ::Prism::FindPatternNode).void }
  def visit_find_pattern_node(node); end

  # : (Prism::FlipFlopNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#328
  sig { override.params(node: ::Prism::FlipFlopNode).void }
  def visit_flip_flop_node(node); end

  # : (Prism::FloatNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#334
  sig { override.params(node: ::Prism::FloatNode).void }
  def visit_float_node(node); end

  # : (Prism::ForNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#340
  sig { override.params(node: ::Prism::ForNode).void }
  def visit_for_node(node); end

  # : (Prism::ForwardingArgumentsNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#346
  sig { override.params(node: ::Prism::ForwardingArgumentsNode).void }
  def visit_forwarding_arguments_node(node); end

  # : (Prism::ForwardingParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#352
  sig { override.params(node: ::Prism::ForwardingParameterNode).void }
  def visit_forwarding_parameter_node(node); end

  # : (Prism::ForwardingSuperNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#358
  sig { override.params(node: ::Prism::ForwardingSuperNode).void }
  def visit_forwarding_super_node(node); end

  # : (Prism::GlobalVariableAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#364
  sig { override.params(node: ::Prism::GlobalVariableAndWriteNode).void }
  def visit_global_variable_and_write_node(node); end

  # : (Prism::GlobalVariableOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#370
  sig { override.params(node: ::Prism::GlobalVariableOperatorWriteNode).void }
  def visit_global_variable_operator_write_node(node); end

  # : (Prism::GlobalVariableOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#376
  sig { override.params(node: ::Prism::GlobalVariableOrWriteNode).void }
  def visit_global_variable_or_write_node(node); end

  # : (Prism::GlobalVariableReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#382
  sig { override.params(node: ::Prism::GlobalVariableReadNode).void }
  def visit_global_variable_read_node(node); end

  # : (Prism::GlobalVariableTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#388
  sig { override.params(node: ::Prism::GlobalVariableTargetNode).void }
  def visit_global_variable_target_node(node); end

  # : (Prism::GlobalVariableWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#394
  sig { override.params(node: ::Prism::GlobalVariableWriteNode).void }
  def visit_global_variable_write_node(node); end

  # : (Prism::HashNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#400
  sig { override.params(node: ::Prism::HashNode).void }
  def visit_hash_node(node); end

  # : (Prism::HashPatternNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#406
  sig { override.params(node: ::Prism::HashPatternNode).void }
  def visit_hash_pattern_node(node); end

  # : (Prism::IfNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#412
  sig { override.params(node: ::Prism::IfNode).void }
  def visit_if_node(node); end

  # : (Prism::ImaginaryNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#418
  sig { override.params(node: ::Prism::ImaginaryNode).void }
  def visit_imaginary_node(node); end

  # : (Prism::ImplicitNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#424
  sig { override.params(node: ::Prism::ImplicitNode).void }
  def visit_implicit_node(node); end

  # : (Prism::ImplicitRestNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#430
  sig { override.params(node: ::Prism::ImplicitRestNode).void }
  def visit_implicit_rest_node(node); end

  # : (Prism::InNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#436
  sig { override.params(node: ::Prism::InNode).void }
  def visit_in_node(node); end

  # : (Prism::IndexAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#442
  sig { override.params(node: ::Prism::IndexAndWriteNode).void }
  def visit_index_and_write_node(node); end

  # : (Prism::IndexOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#448
  sig { override.params(node: ::Prism::IndexOperatorWriteNode).void }
  def visit_index_operator_write_node(node); end

  # : (Prism::IndexOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#454
  sig { override.params(node: ::Prism::IndexOrWriteNode).void }
  def visit_index_or_write_node(node); end

  # : (Prism::IndexTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#460
  sig { override.params(node: ::Prism::IndexTargetNode).void }
  def visit_index_target_node(node); end

  # : (Prism::InstanceVariableAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#466
  sig { override.params(node: ::Prism::InstanceVariableAndWriteNode).void }
  def visit_instance_variable_and_write_node(node); end

  # : (Prism::InstanceVariableOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#472
  sig { override.params(node: ::Prism::InstanceVariableOperatorWriteNode).void }
  def visit_instance_variable_operator_write_node(node); end

  # : (Prism::InstanceVariableOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#478
  sig { override.params(node: ::Prism::InstanceVariableOrWriteNode).void }
  def visit_instance_variable_or_write_node(node); end

  # : (Prism::InstanceVariableReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#484
  sig { override.params(node: ::Prism::InstanceVariableReadNode).void }
  def visit_instance_variable_read_node(node); end

  # : (Prism::InstanceVariableTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#490
  sig { override.params(node: ::Prism::InstanceVariableTargetNode).void }
  def visit_instance_variable_target_node(node); end

  # : (Prism::InstanceVariableWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#496
  sig { override.params(node: ::Prism::InstanceVariableWriteNode).void }
  def visit_instance_variable_write_node(node); end

  # : (Prism::IntegerNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#502
  sig { override.params(node: ::Prism::IntegerNode).void }
  def visit_integer_node(node); end

  # : (Prism::InterpolatedMatchLastLineNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#508
  sig { override.params(node: ::Prism::InterpolatedMatchLastLineNode).void }
  def visit_interpolated_match_last_line_node(node); end

  # : (Prism::InterpolatedRegularExpressionNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#514
  sig { override.params(node: ::Prism::InterpolatedRegularExpressionNode).void }
  def visit_interpolated_regular_expression_node(node); end

  # : (Prism::InterpolatedStringNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#520
  sig { override.params(node: ::Prism::InterpolatedStringNode).void }
  def visit_interpolated_string_node(node); end

  # : (Prism::InterpolatedSymbolNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#526
  sig { override.params(node: ::Prism::InterpolatedSymbolNode).void }
  def visit_interpolated_symbol_node(node); end

  # : (Prism::InterpolatedXStringNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#532
  sig { override.params(node: ::Prism::InterpolatedXStringNode).void }
  def visit_interpolated_x_string_node(node); end

  # : (Prism::KeywordHashNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#538
  sig { override.params(node: ::Prism::KeywordHashNode).void }
  def visit_keyword_hash_node(node); end

  # : (Prism::KeywordRestParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#544
  sig { override.params(node: ::Prism::KeywordRestParameterNode).void }
  def visit_keyword_rest_parameter_node(node); end

  # : (Prism::LambdaNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#550
  sig { override.params(node: ::Prism::LambdaNode).void }
  def visit_lambda_node(node); end

  # : (Prism::LocalVariableAndWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#556
  sig { override.params(node: ::Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  # : (Prism::LocalVariableOperatorWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#562
  sig { override.params(node: ::Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  # : (Prism::LocalVariableOrWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#568
  sig { override.params(node: ::Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  # : (Prism::LocalVariableReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#574
  sig { override.params(node: ::Prism::LocalVariableReadNode).void }
  def visit_local_variable_read_node(node); end

  # : (Prism::LocalVariableTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#580
  sig { override.params(node: ::Prism::LocalVariableTargetNode).void }
  def visit_local_variable_target_node(node); end

  # : (Prism::LocalVariableWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#586
  sig { override.params(node: ::Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  # : (Prism::MatchLastLineNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#592
  sig { override.params(node: ::Prism::MatchLastLineNode).void }
  def visit_match_last_line_node(node); end

  # : (Prism::MatchPredicateNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#598
  sig { override.params(node: ::Prism::MatchPredicateNode).void }
  def visit_match_predicate_node(node); end

  # : (Prism::MatchRequiredNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#604
  sig { override.params(node: ::Prism::MatchRequiredNode).void }
  def visit_match_required_node(node); end

  # : (Prism::MatchWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#610
  sig { override.params(node: ::Prism::MatchWriteNode).void }
  def visit_match_write_node(node); end

  # : (Prism::MissingNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#616
  sig { override.params(node: ::Prism::MissingNode).void }
  def visit_missing_node(node); end

  # : (Prism::ModuleNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#622
  sig { override.params(node: ::Prism::ModuleNode).void }
  def visit_module_node(node); end

  # : (Prism::MultiTargetNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#628
  sig { override.params(node: ::Prism::MultiTargetNode).void }
  def visit_multi_target_node(node); end

  # : (Prism::MultiWriteNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#634
  sig { override.params(node: ::Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # : (Prism::NextNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#640
  sig { override.params(node: ::Prism::NextNode).void }
  def visit_next_node(node); end

  # : (Prism::NilNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#646
  sig { override.params(node: ::Prism::NilNode).void }
  def visit_nil_node(node); end

  # : (Prism::NoKeywordsParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#652
  sig { override.params(node: ::Prism::NoKeywordsParameterNode).void }
  def visit_no_keywords_parameter_node(node); end

  # : (Prism::NumberedParametersNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#658
  sig { override.params(node: ::Prism::NumberedParametersNode).void }
  def visit_numbered_parameters_node(node); end

  # : (Prism::NumberedReferenceReadNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#664
  sig { override.params(node: ::Prism::NumberedReferenceReadNode).void }
  def visit_numbered_reference_read_node(node); end

  # : (Prism::OptionalKeywordParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#670
  sig { override.params(node: ::Prism::OptionalKeywordParameterNode).void }
  def visit_optional_keyword_parameter_node(node); end

  # : (Prism::OptionalParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#676
  sig { override.params(node: ::Prism::OptionalParameterNode).void }
  def visit_optional_parameter_node(node); end

  # : (Prism::OrNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#682
  sig { override.params(node: ::Prism::OrNode).void }
  def visit_or_node(node); end

  # : (Prism::ParametersNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#688
  sig { override.params(node: ::Prism::ParametersNode).void }
  def visit_parameters_node(node); end

  # : (Prism::ParenthesesNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#694
  sig { override.params(node: ::Prism::ParenthesesNode).void }
  def visit_parentheses_node(node); end

  # : (Prism::PinnedExpressionNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#700
  sig { override.params(node: ::Prism::PinnedExpressionNode).void }
  def visit_pinned_expression_node(node); end

  # : (Prism::PinnedVariableNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#706
  sig { override.params(node: ::Prism::PinnedVariableNode).void }
  def visit_pinned_variable_node(node); end

  # : (Prism::PostExecutionNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#712
  sig { override.params(node: ::Prism::PostExecutionNode).void }
  def visit_post_execution_node(node); end

  # : (Prism::PreExecutionNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#718
  sig { override.params(node: ::Prism::PreExecutionNode).void }
  def visit_pre_execution_node(node); end

  # : (Prism::ProgramNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#724
  sig { override.params(node: ::Prism::ProgramNode).void }
  def visit_program_node(node); end

  # : (Prism::RangeNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#730
  sig { override.params(node: ::Prism::RangeNode).void }
  def visit_range_node(node); end

  # : (Prism::RationalNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#736
  sig { override.params(node: ::Prism::RationalNode).void }
  def visit_rational_node(node); end

  # : (Prism::RedoNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#742
  sig { override.params(node: ::Prism::RedoNode).void }
  def visit_redo_node(node); end

  # : (Prism::RegularExpressionNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#748
  sig { override.params(node: ::Prism::RegularExpressionNode).void }
  def visit_regular_expression_node(node); end

  # : (Prism::RequiredKeywordParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#754
  sig { override.params(node: ::Prism::RequiredKeywordParameterNode).void }
  def visit_required_keyword_parameter_node(node); end

  # : (Prism::RequiredParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#760
  sig { override.params(node: ::Prism::RequiredParameterNode).void }
  def visit_required_parameter_node(node); end

  # : (Prism::RescueModifierNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#766
  sig { override.params(node: ::Prism::RescueModifierNode).void }
  def visit_rescue_modifier_node(node); end

  # : (Prism::RescueNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#772
  sig { override.params(node: ::Prism::RescueNode).void }
  def visit_rescue_node(node); end

  # : (Prism::RestParameterNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#778
  sig { override.params(node: ::Prism::RestParameterNode).void }
  def visit_rest_parameter_node(node); end

  # : (Prism::RetryNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#784
  sig { override.params(node: ::Prism::RetryNode).void }
  def visit_retry_node(node); end

  # : (Prism::ReturnNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#790
  sig { override.params(node: ::Prism::ReturnNode).void }
  def visit_return_node(node); end

  # : (Prism::SelfNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#796
  sig { override.params(node: ::Prism::SelfNode).void }
  def visit_self_node(node); end

  # : (Prism::SingletonClassNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#802
  sig { override.params(node: ::Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  # : (Prism::SourceEncodingNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#808
  sig { override.params(node: ::Prism::SourceEncodingNode).void }
  def visit_source_encoding_node(node); end

  # : (Prism::SourceFileNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#814
  sig { override.params(node: ::Prism::SourceFileNode).void }
  def visit_source_file_node(node); end

  # : (Prism::SourceLineNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#820
  sig { override.params(node: ::Prism::SourceLineNode).void }
  def visit_source_line_node(node); end

  # : (Prism::SplatNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#826
  sig { override.params(node: ::Prism::SplatNode).void }
  def visit_splat_node(node); end

  # : (Prism::StatementsNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#832
  sig { override.params(node: ::Prism::StatementsNode).void }
  def visit_statements_node(node); end

  # : (Prism::StringNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#838
  sig { override.params(node: ::Prism::StringNode).void }
  def visit_string_node(node); end

  # : (Prism::SuperNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#844
  sig { override.params(node: ::Prism::SuperNode).void }
  def visit_super_node(node); end

  # : (Prism::SymbolNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#850
  sig { override.params(node: ::Prism::SymbolNode).void }
  def visit_symbol_node(node); end

  # : (Prism::TrueNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#856
  sig { override.params(node: ::Prism::TrueNode).void }
  def visit_true_node(node); end

  # : (Prism::UndefNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#862
  sig { override.params(node: ::Prism::UndefNode).void }
  def visit_undef_node(node); end

  # : (Prism::UnlessNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#868
  sig { override.params(node: ::Prism::UnlessNode).void }
  def visit_unless_node(node); end

  # : (Prism::UntilNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#874
  sig { override.params(node: ::Prism::UntilNode).void }
  def visit_until_node(node); end

  # : (Prism::WhenNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#880
  sig { override.params(node: ::Prism::WhenNode).void }
  def visit_when_node(node); end

  # : (Prism::WhileNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#886
  sig { override.params(node: ::Prism::WhileNode).void }
  def visit_while_node(node); end

  # : (Prism::XStringNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#892
  sig { override.params(node: ::Prism::XStringNode).void }
  def visit_x_string_node(node); end

  # : (Prism::YieldNode node) -> void
  #
  # source://spoom//lib/spoom/visitor.rb#898
  sig { override.params(node: ::Prism::YieldNode).void }
  def visit_yield_node(node); end
end
