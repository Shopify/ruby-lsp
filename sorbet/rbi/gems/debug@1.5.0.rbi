# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `debug` gem.
# Please instead update this file by running `bin/tapioca gem debug`.

class Binding
  def b(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
  def break(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
end

# $VERBOSE = true
module DEBUGGER__
  class << self
    def add_catch_breakpoint(pat); end

    # manual configuration methods
    def add_line_breakpoint(file, line, **kw); end

    def capture_frames(_arg0); end

    # Unix domain socket configuration
    def check_dir_authority(path); end

    def commands; end

    # For case insensitive file system (like Windows)
    # Note that this check is not enough because case sensitive/insensitive is
    # depend on the file system. So this check is only roughly estimation.
    def compare_path(a, b); end

    def create_method_added_tracker; end
    def create_unix_domain_socket_name(base_dir = T.unsafe(nil)); end
    def create_unix_domain_socket_name_prefix(base_dir = T.unsafe(nil)); end
    def frame_depth; end
    def help; end
    def helps; end
    def info(msg); end
    def initialize_session(&init_ui); end
    def load_rc; end
    def log(level, msg); end

    # @private
    def method_added(tp); end

    def open(host: T.unsafe(nil), port: T.unsafe(nil), sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end
    def open_tcp(port:, host: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end
    def open_unix(sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

    # Help
    def parse_help; end

    # String for requiring location
    # nil for -r
    def require_location; end

    def safe_inspect(obj, max_length: T.unsafe(nil), short: T.unsafe(nil)); end

    # boot utilities
    def setup_initial_suspend; end

    # start methods
    def start(nonstop: T.unsafe(nil), **kw); end

    def step_in(&b); end
    def unix_domain_socket_dir; end
    def unix_domain_socket_homedir; end
    def unix_domain_socket_tmpdir; end
    def warn(msg); end
  end
end

class DEBUGGER__::Breakpoint
  include ::DEBUGGER__::SkipPathHelper
  include ::DEBUGGER__::Color

  # @return [Breakpoint] a new instance of Breakpoint
  def initialize(cond, command, path, do_enable: T.unsafe(nil)); end

  def delete; end

  # @return [Boolean]
  def deleted?; end

  def description; end
  def disable; end

  # @return [Boolean]
  def duplicable?; end

  def enable; end

  # @return [Boolean]
  def enabled?; end

  def generate_label(name); end

  # Returns the value of attribute key.
  def key; end

  # @return [Boolean]
  def oneshot?; end

  def safe_eval(b, expr); end
  def setup; end

  # @return [Boolean]
  def skip_path?(path); end

  def suspend; end
  def to_s; end
end

DEBUGGER__::CONFIG = T.let(T.unsafe(nil), DEBUGGER__::Config)
DEBUGGER__::CONFIG_MAP = T.let(T.unsafe(nil), Hash)
DEBUGGER__::CONFIG_SET = T.let(T.unsafe(nil), Hash)

class DEBUGGER__::CallTracer < ::DEBUGGER__::Tracer
  def setup; end

  # @return [Boolean]
  def skip_with_pattern?(tp); end
end

class DEBUGGER__::CatchBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [CatchBreakpoint] a new instance of CatchBreakpoint
  def initialize(pat, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def description; end

  # Returns the value of attribute last_exc.
  def last_exc; end

  def setup; end
  def to_s; end
end

class DEBUGGER__::CheckBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [CheckBreakpoint] a new instance of CheckBreakpoint
  def initialize(cond:, command: T.unsafe(nil), path: T.unsafe(nil)); end

  def setup; end
  def to_s; end
end

module DEBUGGER__::Color
  def color_pp(obj, width); end
  def colored_inspect(obj, width: T.unsafe(nil), no_color: T.unsafe(nil)); end
  def colorize(str, color); end
  def colorize_blue(str); end
  def colorize_code(code); end
  def colorize_cyan(str); end
  def colorize_dim(str); end
  def colorize_magenta(str); end
  def irb_colorize(str, color); end
  def with_inspection_error_guard; end
end

DEBUGGER__::Color::SUPPORT_COLORABLE_OPTION = T.let(T.unsafe(nil), TrueClass)

class DEBUGGER__::Config
  # @return [Config] a new instance of Config
  def initialize(argv); end

  def [](key); end
  def []=(key, val); end
  def append_config(key, val); end
  def inspect; end
  def set_config(**kw); end
  def update(conf); end

  private

  def config; end
  def disable_sigdump(old_sig); end
  def enable_sigdump(sig); end

  # @yield [old, new]
  def if_updated(old_conf, new_conf, key); end

  def parse_config_value(name, valstr); end

  # emergency simple sigdump.
  # Use `sigdump` gem for more rich features.
  def setup_sigdump(old_sig = T.unsafe(nil), sig = T.unsafe(nil)); end

  class << self
    def config; end
    def config_to_env_hash(config); end
    def parse_argv(argv); end
    def parse_config_value(name, valstr); end
  end
end

class DEBUGGER__::Console
  include ::DEBUGGER__::Color

  # @return [Console] a new instance of Console
  def initialize; end

  def deactivate; end
  def history; end
  def history_file; end
  def load_history; end
  def load_history_if_not_loaded; end
  def parse_input(buff, commands); end
  def read_history_file; end
  def readline(prompt); end
  def readline_setup(prompt); end

  private

  def get_command(line); end
end

DEBUGGER__::Console::FH = T.let(T.unsafe(nil), String)
DEBUGGER__::Console::SIGWINCH_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

class DEBUGGER__::ExceptionTracer < ::DEBUGGER__::Tracer
  def setup; end

  # @return [Boolean]
  def skip_with_pattern?(tp); end
end

module DEBUGGER__::ForkInterceptor
  def _fork; end

  private

  def __fork_setup_for_debugger; end
end

class DEBUGGER__::FrameInfo < ::Struct
  # Returns the value of attribute _callee
  #
  # @return [Object] the current value of _callee
  def _callee; end

  # Sets the attribute _callee
  #
  # @param value [Object] the value to set the attribute _callee to.
  # @return [Object] the newly set value
  def _callee=(_); end

  # Returns the value of attribute _local_variables
  #
  # @return [Object] the current value of _local_variables
  def _local_variables; end

  # Sets the attribute _local_variables
  #
  # @param value [Object] the value to set the attribute _local_variables to.
  # @return [Object] the newly set value
  def _local_variables=(_); end

  # Returns the value of attribute binding
  #
  # @return [Object] the current value of binding
  def binding; end

  # Sets the attribute binding
  #
  # @param value [Object] the value to set the attribute binding to.
  # @return [Object] the newly set value
  def binding=(_); end

  def block_identifier; end
  def c_identifier; end
  def callee; end

  # Returns the value of attribute class
  #
  # @return [Object] the current value of class
  def class; end

  # Sets the attribute class
  #
  # @param value [Object] the value to set the attribute class to.
  # @return [Object] the newly set value
  def class=(_); end

  # Returns the value of attribute dupped_binding
  #
  # @return [Object] the current value of dupped_binding
  def dupped_binding; end

  # Sets the attribute dupped_binding
  #
  # @param value [Object] the value to set the attribute dupped_binding to.
  # @return [Object] the newly set value
  def dupped_binding=(_); end

  def eval_binding; end
  def file_lines; end

  # Returns the value of attribute frame_depth
  #
  # @return [Object] the current value of frame_depth
  def frame_depth; end

  # Sets the attribute frame_depth
  #
  # @param value [Object] the value to set the attribute frame_depth to.
  # @return [Object] the newly set value
  def frame_depth=(_); end

  def frame_type; end

  # Returns the value of attribute has_raised_exception
  #
  # @return [Object] the current value of has_raised_exception
  def has_raised_exception; end

  # Sets the attribute has_raised_exception
  #
  # @param value [Object] the value to set the attribute has_raised_exception to.
  # @return [Object] the newly set value
  def has_raised_exception=(_); end

  # Returns the value of attribute has_return_value
  #
  # @return [Object] the current value of has_return_value
  def has_return_value; end

  # Sets the attribute has_return_value
  #
  # @param value [Object] the value to set the attribute has_return_value to.
  # @return [Object] the newly set value
  def has_return_value=(_); end

  # Returns the value of attribute iseq
  #
  # @return [Object] the current value of iseq
  def iseq; end

  # Sets the attribute iseq
  #
  # @param value [Object] the value to set the attribute iseq to.
  # @return [Object] the newly set value
  def iseq=(_); end

  def local_variables; end

  # Returns the value of attribute location
  #
  # @return [Object] the current value of location
  def location; end

  # Sets the attribute location
  #
  # @param value [Object] the value to set the attribute location to.
  # @return [Object] the newly set value
  def location=(_); end

  def location_str; end
  def method_identifier; end
  def name; end
  def other_identifier; end
  def path; end
  def pretty_path; end

  # Returns the value of attribute raised_exception
  #
  # @return [Object] the current value of raised_exception
  def raised_exception; end

  # Sets the attribute raised_exception
  #
  # @param value [Object] the value to set the attribute raised_exception to.
  # @return [Object] the newly set value
  def raised_exception=(_); end

  def realpath; end
  def return_str; end

  # Returns the value of attribute return_value
  #
  # @return [Object] the current value of return_value
  def return_value; end

  # Sets the attribute return_value
  #
  # @param value [Object] the value to set the attribute return_value to.
  # @return [Object] the newly set value
  def return_value=(_); end

  # Returns the value of attribute self
  #
  # @return [Object] the current value of self
  def self; end

  # Sets the attribute self
  #
  # @param value [Object] the value to set the attribute self to.
  # @return [Object] the newly set value
  def self=(_); end

  # Returns the value of attribute show_line
  #
  # @return [Object] the current value of show_line
  def show_line; end

  # Sets the attribute show_line
  #
  # @param value [Object] the value to set the attribute show_line to.
  # @return [Object] the newly set value
  def show_line=(_); end

  private

  def get_singleton_class(obj); end
  def klass_sig; end
  def local_variable_get(var); end
  def parameters_info; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

DEBUGGER__::FrameInfo::BLOCK_LABL_REGEXP = T.let(T.unsafe(nil), Regexp)
DEBUGGER__::FrameInfo::HOME = T.let(T.unsafe(nil), String)

class DEBUGGER__::ISeqBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [ISeqBreakpoint] a new instance of ISeqBreakpoint
  def initialize(iseq, events, oneshot: T.unsafe(nil)); end

  def enable; end
  def setup; end
end

DEBUGGER__::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class DEBUGGER__::LineBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [LineBreakpoint] a new instance of LineBreakpoint
  def initialize(path, line, cond: T.unsafe(nil), oneshot: T.unsafe(nil), hook_call: T.unsafe(nil), command: T.unsafe(nil)); end

  def activate(iseq, event, line); end
  def activate_exact(iseq, events, line); end

  # @return [Boolean]
  def duplicable?; end

  def enable; end
  def inspect; end

  # Returns the value of attribute iseq.
  def iseq; end

  # Returns the value of attribute line.
  def line; end

  # Returns the value of attribute path.
  def path; end

  def setup; end
  def to_s; end
  def try_activate; end
end

class DEBUGGER__::LineBreakpoint::NearestISeq < ::Struct
  # Returns the value of attribute events
  #
  # @return [Object] the current value of events
  def events; end

  # Sets the attribute events
  #
  # @param value [Object] the value to set the attribute events to.
  # @return [Object] the newly set value
  def events=(_); end

  # Returns the value of attribute iseq
  #
  # @return [Object] the current value of iseq
  def iseq; end

  # Sets the attribute iseq
  #
  # @param value [Object] the value to set the attribute iseq to.
  # @return [Object] the newly set value
  def iseq=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class DEBUGGER__::LineTracer < ::DEBUGGER__::Tracer
  def setup; end
end

DEBUGGER__::METHOD_ADDED_TRACKER = T.let(T.unsafe(nil), TracePoint)

class DEBUGGER__::MethodBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [MethodBreakpoint] a new instance of MethodBreakpoint
  def initialize(b, klass_name, op, method_name, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def enable; end
  def eval_class_name; end

  # Returns the value of attribute method.
  def method; end

  def override(klass); end
  def search_method; end
  def setup; end
  def sig; end

  # Returns the value of attribute sig_method_name.
  def sig_method_name; end

  def to_s; end
  def try_enable(added: T.unsafe(nil)); end
end

module DEBUGGER__::MultiProcessGroup
  def after_fork(child: T.unsafe(nil)); end
  def info(msg); end
  def lock; end

  # @return [Boolean]
  def locked?; end

  def multi_process!; end
  def sync(&b); end
  def unlock; end

  private

  def lock_level_down; end
  def lock_level_up; end
  def trylock; end
end

class DEBUGGER__::ObjectTracer < ::DEBUGGER__::Tracer
  # @return [ObjectTracer] a new instance of ObjectTracer
  def initialize(ui, obj_id, obj_inspect, **kw); end

  def colorized_obj_inspect; end
  def description; end
  def setup; end
end

class DEBUGGER__::PostmortemError < ::RuntimeError; end

class DEBUGGER__::PresetCommand < ::Struct
  # Returns the value of attribute auto_continue
  #
  # @return [Object] the current value of auto_continue
  def auto_continue; end

  # Sets the attribute auto_continue
  #
  # @param value [Object] the value to set the attribute auto_continue to.
  # @return [Object] the newly set value
  def auto_continue=(_); end

  # Returns the value of attribute commands
  #
  # @return [Object] the current value of commands
  def commands; end

  # Sets the attribute commands
  #
  # @param value [Object] the value to set the attribute commands to.
  # @return [Object] the newly set value
  def commands=(_); end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  def source; end

  # Sets the attribute source
  #
  # @param value [Object] the value to set the attribute source to.
  # @return [Object] the newly set value
  def source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class DEBUGGER__::ProcessGroup
  # @return [ProcessGroup] a new instance of ProcessGroup
  def initialize; end

  def after_fork; end
  def lock; end

  # @return [Boolean]
  def locked?; end

  # @return [Boolean]
  def multi?; end

  def multi_process!; end
  def sync; end
  def trylock; end
  def unlock; end
end

DEBUGGER__::SESSION = T.let(T.unsafe(nil), DEBUGGER__::Session)
DEBUGGER__::SHORT_INSPECT_LENGTH = T.let(T.unsafe(nil), Integer)
DEBUGGER__::SO_VERSION = T.let(T.unsafe(nil), String)

class DEBUGGER__::Session
  include ::DEBUGGER__::Color

  # @return [Session] a new instance of Session
  def initialize; end

  def activate(ui = T.unsafe(nil), on_fork: T.unsafe(nil)); end

  # @return [Boolean]
  def active?; end

  def add_bp(bp); end
  def add_catch_breakpoint(pat); end
  def add_check_breakpoint(cond, path, command); end
  def add_iseq_breakpoint(iseq, **kw); end
  def add_line_breakpoint(file, line, **kw); end
  def add_preset_commands(name, cmds, kick: T.unsafe(nil), continue: T.unsafe(nil)); end

  # tracers
  def add_tracer(tracer); end

  def after_fork_parent; end
  def ask(msg, default = T.unsafe(nil)); end
  def before_fork(need_lock = T.unsafe(nil)); end
  def bp_index(specific_bp_key); end

  # @return [Boolean]
  def break_at?(file, line); end

  def cancel_auto_continue; end
  def capture_exception_frames(*exclude_path); end
  def check_postmortem; end
  def clean_bps; end
  def clear_line_breakpoints(path); end
  def config_command(arg); end
  def config_set(key, val, append: T.unsafe(nil)); end
  def config_show(key); end
  def deactivate; end
  def delete_bp(arg = T.unsafe(nil)); end
  def enter_postmortem_session(exc); end

  # can be called by other threads
  def get_thread_client(th = T.unsafe(nil)); end

  # @return [Boolean]
  def in_subsession?; end

  def inspect; end
  def intercept_trap_sigint(flag, &b); end

  # @return [Boolean]
  def intercept_trap_sigint?; end

  def intercept_trap_sigint_end; end
  def intercept_trap_sigint_start(prev); end

  # Returns the value of attribute intercepted_sigint_cmd.
  def intercepted_sigint_cmd; end

  # breakpoint management
  def iterate_bps; end

  def managed_thread_clients; end
  def method_added(tp); end

  # event
  def on_load(iseq, src); end

  def on_thread_begin(th); end
  def parse_break(arg); end
  def pop_event; end
  def postmortem=(is_enable); end
  def process_command(line); end
  def process_event(evt); end

  # Returns the value of attribute process_group.
  def process_group; end

  def process_info; end
  def prompt; end
  def rehash_bps; end
  def repl_add_breakpoint(arg); end
  def repl_add_catch_breakpoint(arg); end
  def repl_add_watch_breakpoint(arg); end
  def repl_open; end
  def repl_open_setup; end
  def repl_open_tcp(host, port, **kw); end
  def repl_open_vscode; end
  def reset_ui(ui); end
  def resolve_path(file); end
  def save_int_trap(cmd); end
  def session_server_main; end
  def setup_threads; end
  def show_bps(specific_bp = T.unsafe(nil)); end
  def show_help(arg = T.unsafe(nil)); end
  def source(iseq); end
  def step_command(type, arg); end
  def switch_thread(n); end
  def thread_list; end

  # threads
  def update_thread_list; end

  def wait_command; end
  def wait_command_loop(tc); end
  def width; end

  private

  def ask_thread_client(th); end
  def create_thread_client(th); end
  def enter_subsession; end
  def leave_subsession(type); end
  def restart_all_threads; end
  def running_thread_clients_count; end
  def stop_all_threads; end
  def thread_stopper; end
  def waiting_thread_clients; end
end

DEBUGGER__::Session::BREAK_KEYWORDS = T.let(T.unsafe(nil), Array)

module DEBUGGER__::SkipPathHelper
  # @return [Boolean]
  def skip_internal_path?(path); end

  # @return [Boolean]
  def skip_location?(loc); end

  # @return [Boolean]
  def skip_path?(path); end
end

class DEBUGGER__::SourceRepository
  include ::DEBUGGER__::Color

  # @return [SourceRepository] a new instance of SourceRepository
  def initialize; end

  def add(iseq, src); end
  def get(iseq); end
  def get_colored(iseq); end
end

class DEBUGGER__::ThreadClient
  include ::DEBUGGER__::Color
  include ::DEBUGGER__::SkipPathHelper

  # @return [ThreadClient] a new instance of ThreadClient
  def initialize(id, q_evt, q_cmd, thr = T.unsafe(nil)); end

  def <<(req); end
  def assemble_arguments(args); end
  def class_method_map(classes); end
  def close; end
  def collect_locals(frame); end
  def current_frame; end
  def deactivate; end
  def default_frame_formatter(frame); end
  def event!(ev, *args); end
  def frame_eval(src, re_raise: T.unsafe(nil)); end
  def frame_eval_core(src, b); end
  def frame_str(i, frame: T.unsafe(nil)); end
  def generate_info; end
  def get_frame(index); end

  # Returns the value of attribute id.
  def id; end

  def inspect; end
  def location; end

  # cmd: breakpoint
  def make_breakpoint(args); end

  # @return [Boolean]
  def management?; end

  def mark_as_management; end
  def name; end
  def on_breakpoint(tp, bp); end
  def on_init(name); end
  def on_load(iseq, eval_src); end
  def on_pause; end
  def on_trace(trace_id, msg); end
  def on_trap(sig); end
  def outline_method(o, klass, obj); end
  def puts(str = T.unsafe(nil)); end
  def puts_variable_info(label, obj, pat); end

  # Returns the value of attribute recorder.
  def recorder; end

  def replay_suspend; end

  # @return [Boolean]
  def running?; end

  def set_mode(mode); end

  # cmd: show edit
  def show_by_editor(path = T.unsafe(nil)); end

  def show_consts(pat, only_self: T.unsafe(nil)); end
  def show_frame(i = T.unsafe(nil)); end

  # cmd: show frames
  def show_frames(max = T.unsafe(nil), pattern = T.unsafe(nil)); end

  def show_globals(pat); end
  def show_ivars(pat); end
  def show_locals(pat); end

  # cmd: show outline
  def show_outline(expr); end

  def show_src(frame_index: T.unsafe(nil), update_line: T.unsafe(nil), max_lines: T.unsafe(nil), start_line: T.unsafe(nil), end_line: T.unsafe(nil), dir: T.unsafe(nil)); end

  # cmd: show
  def special_local_variables(frame); end

  def step_tp(iter, events = T.unsafe(nil)); end
  def suspend(event, tp = T.unsafe(nil), bp: T.unsafe(nil), sig: T.unsafe(nil), postmortem_frames: T.unsafe(nil), replay_frames: T.unsafe(nil), postmortem_exc: T.unsafe(nil)); end

  # Returns the value of attribute thread.
  def thread; end

  def to_s; end
  def tp_allow_reentry; end
  def truncate(string, width:); end
  def wait_next_action; end
  def wait_next_action_; end

  # events
  def wait_reply(event_arg); end

  # @return [Boolean]
  def waiting?; end

  class << self
    def current; end
  end
end

# copied from irb
class DEBUGGER__::ThreadClient::Output
  include ::DEBUGGER__::Color

  # @return [Output] a new instance of Output
  def initialize(output); end

  def dump(name, strs); end

  private

  def col_widths(strs, cols:); end

  # @return [Boolean]
  def fits_on_line?(strs, cols:, offset: T.unsafe(nil)); end

  def screen_width; end
end

DEBUGGER__::ThreadClient::Output::MARGIN = T.let(T.unsafe(nil), String)

class DEBUGGER__::ThreadClient::Recorder
  include ::DEBUGGER__::SkipPathHelper

  # @return [Recorder] a new instance of Recorder
  def initialize; end

  # Returns the value of attribute backup_frames.
  def backup_frames; end

  # Sets the attribute backup_frames
  #
  # @param value the value to set the attribute backup_frames to.
  def backup_frames=(_arg0); end

  # @return [Boolean]
  def can_step_back?; end

  def current_frame; end

  # for debugging
  def current_position; end

  def disable; end
  def enable; end

  # @return [Boolean]
  def enabled?; end

  # Returns the value of attribute index.
  def index; end

  # Returns the value of attribute log.
  def log; end

  def log_index; end

  # @return [Boolean]
  def replaying?; end

  def step_back; end
  def step_forward; end
  def step_reset; end
end

DEBUGGER__::ThreadClient::SKIP_GLOBAL_LIST = T.let(T.unsafe(nil), Array)
DEBUGGER__::ThreadClient::SPECIAL_LOCAL_VARS = T.let(T.unsafe(nil), Array)
DEBUGGER__::ThreadClient::SUPPORT_TARGET_THREAD = T.let(T.unsafe(nil), TrueClass)
class DEBUGGER__::ThreadClient::SuspendReplay < ::Exception; end

class DEBUGGER__::Tracer
  include ::DEBUGGER__::SkipPathHelper
  include ::DEBUGGER__::Color

  # @return [Tracer] a new instance of Tracer
  def initialize(ui, pattern: T.unsafe(nil), into: T.unsafe(nil)); end

  def colorize(str, color); end
  def description; end
  def disable; end
  def enable; end
  def header(depth); end

  # Returns the value of attribute key.
  def key; end

  def minfo(tp); end
  def out(tp, msg = T.unsafe(nil), depth = T.unsafe(nil)); end
  def puts(msg); end

  # @return [Boolean]
  def skip?(tp); end

  # @return [Boolean]
  def skip_with_pattern?(tp); end

  def to_s; end

  # Returns the value of attribute type.
  def type; end
end

module DEBUGGER__::TrapInterceptor
  def trap(sig, *command, &command_proc); end
end

class DEBUGGER__::UI_Base
  def event(type, *args); end
  def flush; end
end

class DEBUGGER__::UI_LocalConsole < ::DEBUGGER__::UI_Base
  # @return [UI_LocalConsole] a new instance of UI_LocalConsole
  def initialize; end

  def activate(session, on_fork: T.unsafe(nil)); end
  def after_fork_parent; end
  def ask(prompt); end
  def deactivate; end
  def puts(str = T.unsafe(nil)); end
  def quit(n); end
  def readline(prompt = T.unsafe(nil)); end

  # @return [Boolean]
  def remote?; end

  def setup_interrupt; end
  def width; end
end

class DEBUGGER__::WatchIVarBreakpoint < ::DEBUGGER__::Breakpoint
  # @return [WatchIVarBreakpoint] a new instance of WatchIVarBreakpoint
  def initialize(ivar, object, current, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def setup; end
  def to_s; end
  def watch_eval(tp); end
end

module IRB::Color
  class << self
    def clear(colorable: T.unsafe(nil)); end
    def colorable?; end
    def colorize(text, seq, colorable: T.unsafe(nil)); end
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil)); end
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    def dispatch_seq(token, expr, str, in_symbol:); end
    def scan(code, allow_last_error:); end
    def without_circular_ref(obj, seen:, &block); end
  end
end

IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)
IRB::Color::DIM = T.let(T.unsafe(nil), Integer)
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)
IRB::Color::RED = T.let(T.unsafe(nil), Integer)
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

# trap
module Kernel
  def debugger(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
  def trap(sig, *command, &command_proc); end
end

# Also, modules included into Object need to be scanned and have their
# instance methods removed from blank slate.  In theory, modules
# included into Kernel would have to be removed as well, but a
# "feature" of Ruby prevents late includes into modules from being
# exposed in the first place.
class Module
  def method_added(mid); end
  def singleton_method_added(mid); end
end

class Reline::LineEditor
  def initialize(config, encoding); end

  def add_dialog_proc(name, p, context = T.unsafe(nil)); end
  def auto_indent_proc; end
  def auto_indent_proc=(_arg0); end
  def byte_pointer; end
  def byte_pointer=(val); end
  def call_completion_proc; end
  def call_completion_proc_with_checking_args(pre, target, post); end
  def completion_append_character; end
  def completion_append_character=(_arg0); end
  def completion_proc; end
  def completion_proc=(_arg0); end
  def confirm_multiline_termination; end
  def confirm_multiline_termination_proc; end
  def confirm_multiline_termination_proc=(_arg0); end
  def delete_text(start = T.unsafe(nil), length = T.unsafe(nil)); end
  def dig_perfect_match_proc; end
  def dig_perfect_match_proc=(_arg0); end
  def editing_mode; end
  def eof?; end
  def finalize; end
  def finish; end
  def finished?; end
  def input_key(key); end
  def insert_text(text); end
  def just_move_cursor; end
  def line; end
  def multiline_off; end
  def multiline_on; end
  def output=(_arg0); end
  def output_modifier_proc; end
  def output_modifier_proc=(_arg0); end
  def pre_input_hook; end
  def pre_input_hook=(_arg0); end
  def prompt_proc; end
  def prompt_proc=(_arg0); end
  def rerender; end
  def rerender_all; end
  def reset(prompt = T.unsafe(nil), encoding:); end
  def reset_line; end
  def reset_variables(prompt = T.unsafe(nil), encoding:); end
  def resize; end
  def retrieve_completion_block(set_completion_quote_character = T.unsafe(nil)); end
  def set_pasting_state(in_pasting); end
  def set_signal_handlers; end
  def simplified_rendering?; end
  def whole_buffer; end
  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end
  def wrap_method_call(method_symbol, method_obj, key, with_operator = T.unsafe(nil)); end

  private

  def argumentable?(method_obj); end
  def backward_char(key, arg: T.unsafe(nil)); end
  def backward_delete_char(key, arg: T.unsafe(nil)); end
  def backward_word(key); end
  def beginning_of_line(key); end
  def byteinsert(str, byte_pointer, other); end
  def byteslice!(str, byte_pointer, size); end
  def calculate_height_by_lines(lines, prompt); end
  def calculate_height_by_width(width); end
  def calculate_nearest_cursor(line_to_calc = T.unsafe(nil), cursor = T.unsafe(nil), started_from = T.unsafe(nil), byte_pointer = T.unsafe(nil), update = T.unsafe(nil)); end
  def calculate_scroll_partial_screen(highest_in_all, cursor_y); end
  def calculate_width(str, allow_escape_code = T.unsafe(nil)); end
  def capitalize_word(key); end
  def check_mode_string; end
  def check_multiline_prompt(buffer); end
  def clear_dialog; end
  def clear_each_dialog(dialog); end
  def clear_screen(key); end
  def clear_screen_buffer(prompt, prompt_list, prompt_width); end
  def complete(list, just_show_list = T.unsafe(nil)); end
  def complete_internal_proc(list, is_menu); end
  def copy_for_vi(text); end
  def delete_char(key); end
  def delete_char_or_list(key); end
  def downcase_word(key); end
  def ed_argument_digit(key); end
  def ed_clear_screen(key); end
  def ed_delete_next_char(key, arg: T.unsafe(nil)); end
  def ed_delete_prev_char(key, arg: T.unsafe(nil)); end
  def ed_delete_prev_word(key); end
  def ed_digit(key); end
  def ed_insert(key); end
  def ed_kill_line(key); end
  def ed_move_to_beg(key); end
  def ed_move_to_end(key); end
  def ed_newline(key); end
  def ed_next_char(key, arg: T.unsafe(nil)); end
  def ed_next_history(key, arg: T.unsafe(nil)); end
  def ed_prev_char(key, arg: T.unsafe(nil)); end
  def ed_prev_history(key, arg: T.unsafe(nil)); end
  def ed_prev_word(key); end
  def ed_quoted_insert(str, arg: T.unsafe(nil)); end
  def ed_search_next_history(key, arg: T.unsafe(nil)); end
  def ed_search_prev_history(key, arg: T.unsafe(nil)); end
  def ed_transpose_chars(key); end
  def ed_transpose_words(key); end
  def ed_unassigned(key); end
  def em_capitol_case(key); end
  def em_delete(key); end
  def em_delete_next_word(key); end
  def em_delete_or_list(key); end
  def em_delete_prev_char(key, arg: T.unsafe(nil)); end
  def em_exchange_mark(key); end
  def em_kill_line(key); end
  def em_kill_region(key); end
  def em_lower_case(key); end
  def em_next_word(key); end
  def em_set_mark(key); end
  def em_upper_case(key); end
  def em_yank(key); end
  def em_yank_pop(key); end
  def end_of_line(key); end
  def exchange_point_and_mark(key); end
  def forward_char(key, arg: T.unsafe(nil)); end
  def forward_search_history(key); end
  def forward_word(key); end
  def generate_searcher; end
  def history_search_backward(key, arg: T.unsafe(nil)); end
  def history_search_forward(key, arg: T.unsafe(nil)); end
  def inclusive?(method_obj); end
  def incremental_search_history(key); end
  def insert_new_line(cursor_line, next_line); end
  def key_delete(key); end
  def key_newline(key); end
  def kill_line(key); end
  def kill_whole_line(key); end
  def menu(target, list); end
  def modify_lines(before); end
  def move_completed_list(list, direction); end
  def move_cursor_down(val); end
  def move_cursor_up(val); end
  def next_history(key, arg: T.unsafe(nil)); end
  def normal_char(key); end
  def padding_space_with_escape_sequences(str, width); end
  def previous_history(key, arg: T.unsafe(nil)); end
  def process_auto_indent; end
  def process_insert(force: T.unsafe(nil)); end
  def process_key(key, method_symbol); end
  def quoted_insert(str, arg: T.unsafe(nil)); end
  def render_dialog(cursor_column); end
  def render_each_dialog(dialog, cursor_column); end
  def render_partial(prompt, prompt_width, line_to_render, this_started_from, with_control: T.unsafe(nil)); end
  def render_whole_lines(lines, prompt, prompt_width); end
  def rerender_added_newline(prompt, prompt_width); end
  def rerender_all_lines; end
  def rerender_changed_current_line; end
  def reset_dialog(dialog, old_dialog); end
  def reverse_search_history(key); end
  def run_for_operators(key, method_symbol, &block); end
  def scroll_down(val); end
  def search_next_char(key, arg, need_prev_char: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def search_prev_char(key, arg, need_next_char = T.unsafe(nil)); end
  def self_insert(key); end
  def set_mark(key); end
  def show_menu; end
  def split_by_width(str, max_width); end
  def transpose_chars(key); end
  def transpose_words(key); end
  def unix_line_discard(key); end
  def unix_word_rubout(key); end
  def upcase_word(key); end
  def vi_add(key); end
  def vi_add_at_eol(key); end
  def vi_change_meta(key, arg: T.unsafe(nil)); end
  def vi_command_mode(key); end
  def vi_delete_meta(key, arg: T.unsafe(nil)); end
  def vi_delete_prev_char(key); end
  def vi_end_big_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_end_of_transmission(key); end
  def vi_end_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_eof_maybe(key); end
  def vi_first_print(key); end
  def vi_histedit(key); end
  def vi_insert(key); end
  def vi_insert_at_bol(key); end
  def vi_join_lines(key, arg: T.unsafe(nil)); end
  def vi_kill_line_prev(key); end
  def vi_list_or_eof(key); end
  def vi_movement_mode(key); end
  def vi_next_big_word(key, arg: T.unsafe(nil)); end
  def vi_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_next_word(key, arg: T.unsafe(nil)); end
  def vi_paste_next(key, arg: T.unsafe(nil)); end
  def vi_paste_prev(key, arg: T.unsafe(nil)); end
  def vi_prev_big_word(key, arg: T.unsafe(nil)); end
  def vi_prev_char(key, arg: T.unsafe(nil)); end
  def vi_prev_word(key, arg: T.unsafe(nil)); end
  def vi_replace_char(key, arg: T.unsafe(nil)); end
  def vi_search_next(key); end
  def vi_search_prev(key); end
  def vi_to_column(key, arg: T.unsafe(nil)); end
  def vi_to_history_line(key); end
  def vi_to_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end
  def vi_to_prev_char(key, arg: T.unsafe(nil)); end
  def vi_yank(key, arg: T.unsafe(nil)); end
  def vi_zero(key); end
  def yank(key); end
  def yank_pop(key); end
end

Reline::LineEditor::CompletionJourneyData = Struct
Reline::LineEditor::DIALOG_DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)
Reline::LineEditor::MenuInfo = Struct
Reline::LineEditor::PROMPT_LIST_CACHE_TIMEOUT = T.let(T.unsafe(nil), Float)
Reline::LineEditor::VI_MOTIONS = T.let(T.unsafe(nil), Array)

class RubyVM::InstructionSequence
  def traceable_lines_norec(lines); end
  def traceable_lines_rec(lines); end
end
